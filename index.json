[{"categories":null,"contents":"这几天每天邮箱都会收到Github Actions执行错误的邮件：\n[BachWV/BachWV.github.io] Deploy Hugo workflow run Deploy Hugo: All jobs have failed\n点开一看\n1 2 3 4 Run hugo Start building sites … hugo v0.112.0-0a95d6704a8ac8d41cc5ca8fffaad8c5c7a3754a linux/amd64 BuildDate=2023-05-23T08:14:20Z VendorInfo=gohugoio ERROR 2023/05/23 23:17:26 render of \u0026#34;page\u0026#34; failed: \u0026#34;/home/runner/work/BachWV.github.io/BachWV.github.io/themes/hugo-theme-tokiwa/layouts/_default/single.html:19:4\u0026#34;: execute of template failed: template: _default/single.html:19:4: executing \u0026#34;aside\u0026#34; at \u0026lt;partial \u0026#34;page-aside.html\u0026#34; .\u0026gt;: error calling partial: \u0026#34;/home/runner/work/BachWV.github.io/BachWV.github.io/themes/hugo-theme-tokiwa/layouts/partials/page-aside.html:3:4\u0026#34;: execute of template failed: template: partials/page-aside.html:3:4: executing \u0026#34;partials/page-aside.html\u0026#34; at \u0026lt;partial \u0026#34;social-follow.html\u0026#34; .\u0026gt;: error calling partial: \u0026#34;/home/runner/work/BachWV.github.io/BachWV.github.io/themes/hugo-theme-tokiwa/layouts/partials/social-follow.html:10:6\u0026#34;: execute of template failed: template: partials/social-follow.html:10:6: executing \u0026#34;partials/social-follow.html\u0026#34; at \u0026lt;partial (printf \u0026#34;%s%s%s\u0026#34; \u0026#34;svg/\u0026#34; $key \u0026#34;-line.svg\u0026#34;) .\u0026gt;: error calling partial: partial \u0026#34;svg/_merge-line.svg\u0026#34; not found 新版本0.112.0不知道升级了什么东西，这是啥错？\n把hugo下载到本地，发现同样的错误，可以定位是hugo升级带来的不兼容问题了。\n定位bug文件\npartials/social-follow.html\n1 2 3 4 5 6 7 8 9 10 {{ range $key,$value:=.Site.Social }} \u0026lt;a href=\u0026#39;{{$value}}\u0026#39; target=\u0026#34;_blank\u0026#34; class=\u0026#34;{{- $key}} icon pl-1 text-eucalyptus-400 hover:text-java-400\u0026#34; title=\u0026#34;{{- $key}} link\u0026#34; rel=\u0026#34;noopener\u0026#34; aria-label=\u0026#34;follow on {{$key}}——Opens in a new window\u0026#34;\u0026gt; {{/* \u0026lt;object type=\u0026#34;image/svg+xml\u0026#34; data=\u0026#39;{{ relURL (printf \u0026#34;%s%s%s\u0026#34; \u0026#34;svg/\u0026#34; $key \u0026#34;.svg\u0026#34;) }}\u0026#39; class=\u0026#34;w-12 h-12 text-gray-200\u0026#34;\u0026gt;\u0026lt;/object\u0026gt; */}} \u0026lt;div class=\u0026#34;fill-current h-8 w-8\u0026#34;\u0026gt; {{ partial (printf \u0026#34;%s%s%s\u0026#34; \u0026#34;svg/\u0026#34; $key \u0026#34;-line.svg\u0026#34;) . }} \u0026lt;/div\u0026gt; \u0026lt;/a\u0026gt; {{ end }} 看了仓库的issue，没人提。问题在哪？\n找了半天，找到112的更新日志\nhttps://gohugo.io/content-management/multilingual/#changes-in-hugo-01120\n提到了配置文件config.toml映射的变化\n所以把第一行的\t{{ range $key,$value:=.Site.Social }}改成\t{{ range $key,$value:=.Site.Params.Social }}就好啦\n","date":"2023-05-27T15:00:00+08:00","permalink":"https://junling.li/posts/hugo/","section":"posts","tags":null,"title":"hugo update"},{"categories":null,"contents":"为你的静态站点添加一个观影页面 效果如 https://junling.li/movies/ 所示，这是不是也很酷。只需要在自己的豆瓣账号上为自己喜欢的电影评分，即可自动同步到影单，这也太酷辣。\n使用git管理的好处是，文件修改的历史记录能够轻易查看， 顺着时间轴来就能看到添加历史，我超，非常符合我对未来的想象，科技并带着趣味\n借助这个 https://imnerd.org/doumark.html 提到的工具，可以将豆瓣的评分导出为csv文件，然后再将csv文件放到自己的github仓库中，就可以了。 如何实现自动化，使用Github Actions，每小时的第30分钟执行一下脚本，查看豆瓣数据有没有更新。\n还记得怎么写每小说的30分钟执行一下脚本，可以去复习crontab 或者直接在（https://crontab.guru/#30__**）里看一下。\n有了定时更新的csv文件，那我们怎么把csv解析成html页面呢？\nHugo作为静态网页生成工具，早就为你想到了这一点，参考Hugo文档 只需要{{ $dataC := getCSV \u0026quot;separator\u0026quot; \u0026quot;url\u0026quot; }}一下，即可获得csv里的数据。使用{{index $movie 5}}即可获得csv文件第五列的数据。\n具体过程见movies.html\n重新构建一下，你也能拥有如此炫酷的页面啦\n","date":"2023-05-10T16:58:12+08:00","permalink":"https://junling.li/posts/movie-diy/","section":"posts","tags":null,"title":"Movie and Book"},{"categories":null,"contents":"kaggle的经历因为人工智能应用与挑战课程。这门课根据比赛排名来确定部分平时分数。\n一个给宠物照片打分的比赛，所以咱们有队友。\n项目概况简介 **竞赛题目：**PetFinder.my – Pawpularity Contest\n**竞赛类型：**Research Code Competition\n**开始时间：**2021.9.23\n**结束时间：**2022.1.6\n**竞赛地址：**https://www.kaggle.com/c/petfinder-pawpularity-score/\n竞赛内容：\nPetFinder.my是一个宠物收容网站。用户上传宠物的照片使用https://www.petfinder.my/cutenessmeter 的方法来预测宠物照片的受欢迎程度。\n要求：\n分析原始图像和元数据来预测宠物照片的“Pawpularity”。 对于测试集中的每个，预测目标图片的Pawpularity\n结果：\n截至22年1月1日，排名为46/3027，RSME为17.7948，有几率获得银牌\n我们使用的是swin_large_patch4_window7_224_22kto1k（开源预训练模型）\nswin是微软亚洲研究院去年3月提出的transformer，通过引入CNN中常用的层次化构建方式构建层次化Transformer以及引入locality思想解决transformer迁移至CV上的scale和分辨率的问题\n接下来就是调参了，最后的结果还是很不错滴。\n模型及参数 RMSE 排名 决策树模型 20.48770 1929 RAPIDS SVR Boost 18.02751 762 Swin transformer模型Batch size=32，n fold=10 17.94193 411 Batch size=8，n fold=5 17.90508 291 Batch size=8，n fold=8 17.83858 106 Batch size=8，n fold=7 17.81823 66 Batch size=8，n fold=7更改seed 17.79984 46 好吧，transform不是用在nlp的吗？怎么能做cv了？\n先复习一下Transformer吧\nAttention is all you need.\nInput-\u0026gt;Encoders -\u0026gt; Decoders -\u0026gt;Output\nencoder 部分：\n输入部分\nembedding 位置嵌入 位置编码 为什么需要位置编码？\n以rnn为例，需要时序关系，transformer需要单词之间的先后顺序。\n位置编码公式\n$$PE_{pos,2i}=\\sin(pos/1000^{2i/d_{model}})$$\n$$PE_{pos,2i}=\\cos(pos/1000^{2i/d_{model}})$$\n正弦、余弦相互交替。\n为什么位置嵌入会有用？\n好吧我没看懂\n注意力机制 基本注意力机制 对于一张图，对不同区域的注意力不同。\n$$Attention(Q,K,V)=softmax(\\frac{QK^T}{\\sqrt{D_k}})$$\n2.. transformer中的注意力机制\n更多内容正在施工中\n","date":"2022-09-12T22:00:12+08:00","permalink":"https://junling.li/posts/kaggle/","section":"posts","tags":null,"title":"kaggle"},{"categories":null,"contents":"简单复盘一下计院大二下的课程设计，也就这肝这个东西时的收获最多。\n看了一下群聊消息，创建于21年3月29日，从4月做到6月底（原计划是5月底，后来推迟到6月），每两个星期做一次线上汇报，因为有项目进度催着，所以进展挺快的，也学到不少的东西。\n一开学就可以选题了，当时看了一下人脸识别还是蛮有趣的，就想着挑战一下自己。其实项目的要求很简单，根据提供的代码做一个壳，完成一个可以正常使用的图形化界面就可以了。\n通过畅游GitHub，发现有一个dlib库可以实现人脸识别的过程。通过比对两张图片，生成一个相似度。\n但由于咱学术水平不深，很多基于这个库的论文都介绍的很浅，今天也想通过复盘，重新深入了解一下。\n首先人脸识别的相关工作\n基于几何特征 人脸由眼睛、鼻子、嘴巴、下巴等部件构成，正因为这些部件的形状、大小和结构上的各种差异才使得世界上每个人脸千差万别，因此对这些部件的形状和结构关系的几何描述，可以做为人脸识别的重要特征。几何特征最早是用于人脸侧面轮廓的描述与识别，首先根据侧面轮廓曲线确定若干显著点，并由这些显著点导出一组用于识别的特征度量如距离、角度等。\n采用几何特征进行正面人脸识别一般是通过提取人眼、口、鼻等重要特征点的位置和眼睛等重要器官的几何形状作为分类特征\n可变形模板法可以视为几何特征方法的一种改进，其基本思想是 :设计一个参数可调的器官模型 (即可变形模板),定义一个能量函数，通过调整模型参数使能量函数最小化，此时的模型参数即做为该器官的几何特征。存在两个问题，一是能量函数中各种代价的加权系数只能由经验确定，难以推广，二是能量函数优化过程十分耗时，难以实际应用。 基于参数的人脸表示可以实现对人脸显著特征的一个高效描述，但它需要大量的前处理和精细的参数选择。同时，采用一般几何特征只描述了部件的基本形状与结构关系，忽略了局部细微特征，造成部分信息的丢失，更适合于做粗分类，而且目前已有的特征点检测技术在精确率上还远不能满足要求，计算量也较大。\n特征脸方法（Eigenface或PCA） 特征脸方法是90年代初期由Turk和Pentland提出的目前最流行的算法之一，具有简单有效的特点, 也称为基于主成分分析(principal component analysis,简称PCA)的人脸识别方法。 特征子脸技术的基本思想是：从统计的观点，寻找人脸图像分布的基本元素，即人脸图像样本集协方差矩阵的特征向量，以此近似地表征人脸图像。这些特征向量称为特征脸(Eigenface)。\n实际上，特征脸反映了隐含在人脸样本集合内部的信息和人脸的结构关系。将眼睛、面颊、下颌的样本集协方差矩阵的特征向量称为特征眼、特征颌和特征唇，统称特征子脸。特征子脸在相应的图像空间中生成子空间，称为子脸空间。计算出测试图像窗口在子脸空间的投影距离，若窗口图像满足阈值比较条件，则判断其为人脸。 基于特征分析的方法，也就是将人脸基准点的相对比率和其它描述人脸脸部特征的形状参数或类别参数等一起构成识别特征向量，这种基于整体脸的识别不仅保留了人脸部件之间的拓扑关系，而且也保留了各部件本身的信息，而基于部件的识别则是通过提取出局部轮廓信息及灰度信息来设计具体识别算法。\n利用主元分析法 (即 Principle Component Analysis,简称 PCA)进行识别是由 Anderson和 Kohonen提出的。由于 PCA在将高维向量向低维向量转化时，使低维向量各分量的方差最大，且各分量互不相关，因此可以达到最优的特征抽取。\n看到一篇文章Joint Image Denoising and Disparity Estimation via Stereo Structure PCA and Noise-Tolerant Cost咱们还是复习一下PCA吧，以防被问到PCA的问题。\n当然我是不太喜欢PCA的，遥想某一年的数学建模使用了PCA做数据降维，然后那次数模啥奖都没有。算上是我个人的偏见。\n把n维的数据压缩成k维，核心步骤也比较简单。两个变换就结束了\n求协方差矩阵$C=\\frac{1}{m}XX^T$ 求协方差矩阵的特征值和对应的特征向量，特征向量按照特征值大小从上到下排列成矩阵，取前k行组成P $Y=PX$即为降维到k的数据 神经网络 Dlib是一个基于C++ 开发的开源第三方库，包含不少机器学习的成熟算法和模型，拥有全面的文档说明。它聚焦于人脸面部特征提取和识别。Dlib提供具有独立使用的可移植的代码，在不借用第三方库的情况下，可以直接移植到Python项目中使用。本程序使用了Dlib提供的人脸识别模型和人脸关键点检测器。以及对应的68点人脸检测器模型：shape_predictor_68_face_landmarks.dat和resnet残差学习神经网络模型dlib_face_recognition_resnet_model_v1.dat。\n施工中ing\n","date":"2022-09-11T22:32:41+08:00","permalink":"https://junling.li/posts/dlib-pyqt/","section":"posts","tags":null,"title":"课程设计"},{"categories":null,"contents":"这个实验的主要目标是构建一个决策树。\n决策树，实际上是用来分类的。树，体现了这个数据结构是逐层分叉的。那么怎么找到分叉点呢？\nID3 算法 在谈ID3算法前，首先介绍一下熵的概念。\n训练元组D有若干个属性，每个属性有一些值。则D的信息熵(entropy)表示为\n$$ info(D) = - \\sum_{i-1}^{m} p_i \\log_2 (p_i) $$\n其中$p_i$表示第i个类别在整个训练元组中出现的概率，可以用此类别元素的数量除以训练元组总数量作为估计。熵的实际意义表示的是D中元组的类标号所需要的平均信息量。现在我们假设将训练元组按属性A进行划分，则A对D划分的期望信息为：\n$$info_A(D)=\\sum_{j=1}^v \\frac{D_j} {D}info(D_j)$$\n而信息增益即为两者的差值：\n$$gain(A)=info(D)-info_A(D)$$\nID3算法就是在每次需要分裂时，计算每个属性的增益率，然后选择增益率最大的属性进行分裂。\n对于特征属性为连续值，可以将D中的元素按照特征属性排序，则每两个相邻元素的中间点可以看作潜在分裂点，从第一个潜在分裂点开始，分裂D并计算两个集合的期望信息，选择具有最小期望信息的点作为这个属性的最佳分裂点，此期望信息作为此属性的信息期望。\n施工中ing\n","date":"2022-09-10T22:32:41+08:00","permalink":"https://junling.li/posts/ai-lab-1/","section":"posts","tags":null,"title":"人工智能实验1"},{"categories":null,"contents":"第20讲 处理器调度 (RR, MLFQ 和 CFS；优先级翻转；多处理器调度)\n上下文切换的策略\n中断机制\n处理器以固定的频率被中断 Linux Kernel可以配置：100/250/300/1000hz 中断/系统调用返回时可以自由选择进程/线程执行 ","date":"2022-09-10T22:32:41+08:00","permalink":"https://junling.li/posts/os-jyy-20/","section":"posts","tags":null,"title":"操作系统-jyy-20"},{"categories":null,"contents":"第19讲 Xv6 上下文切换 (上下文切换的实现；状态机的封装与恢复)\n处理器虚拟化 os是什么，是保存许多进程状态机的状态。然后选一个做调度。\n为什么while(1)不会让操作系统卡死？\n中断。对xv6来说，强行执行了一条ecall\n切换到操作系统代码执行，操作系统决定让哪个进程继续执行。\n使得cpu在时间上分割成多个cpu。\n这件事究竟是如何发生的？\n热身:协程 co_yield()// snapshut and switch\n如果编译器会是不是帮你添加co_yield()是不是意味着你在用户态对状态机做调度，实际上是一个用户态的操作系统\n每个协程有独自的stack\n复习：程序的状态 寄存器\n内存\n虚拟化：状态机的管理 寄存器组 ($x0\u0026hellip;$x31, $pc) 只有一份，物理内存也只有一份\n寄存器的虚拟化：我们可以把寄存器保存到内存 内存的虚拟化：$satp 的数据结构 操作系统代码最重要的 invariant (假设单处理器)\n操作系统代码开始真正 “处理” 系统调用/中断时，所有进程的状态都被 “封存” 在操作系统中 可以通过 struct proc 里的指针访问 (struct trapframe) 中断/异常处理的一小段代码需要保证这一点 中断返回时，把进程的状态机 “恢复” 到 CPU 状态的封存：Trivial 的操作系统实现 用最直观的 “封存” 方式\n直接都保存到内存 假设操作系统代码直接 “看到” 所有物理内存 (L1) 1 2 3 4 5 struct page { int prot; void *va, *pa; } struct proc { uint64_t x1, x2, ... x31; struct page pages[MAXPAGES]; }; 保存：把 x1, \u0026hellip;, x31 保存到当前的 proc 即可 就满足了 “状态机封存” 的 invariant 恢复：把 pages 送到 $satp 对应的数据结构里 通常我们是把这个数据结构准备好，只要一个赋值就行 x86的中断/异常就比较麻烦了\n好处，中断处理程序就简单了，只需要push保存寄存器\n再次调试系统调用 ecall 指令的行为\n关闭中断 复制 $pc 到 $sepc 设置 $sstatus 为 S-mode，$scause 为 trap 的原因 (ecall, 8) 跳转到 $stvec (S-mode trap vector) 究竟是什么原因让某南大计算机老师的slides上出现了抽象的UESTC的厕所照片，这究竟是人性的扭曲还是道德的沦丧。\n是操作系统给进程戴了VR眼镜，给进程的地址是虚假的地址空间。\necall 时额外的系统状态\n$satp 控制了 “虚假” 的地址空间 进程访问内存时仿佛戴了 VR $sscratch 保存了进程的 trap frame 地址 均由操作系统设置 Trampoline 代码完成的工作 把寄存器保存到 trap frame\n全靠 (struct trapframe *)$sscratch 寄存器 切换到内核线程\n堆栈切换: $sp ← tf-\u0026gt;kernel_sp\n设置当前处理: $tp ← tf-\u0026gt;kernel_hartid\n设置页表: $satp ←\n1 tf-\u0026gt;kernel_trap xv6: 与物理内存一一映射 通过 info mem 查看内核线程的地址空间映射 低位的内存是 PLIC (0xc000000) 和 UART (0x10000000) 物理内存一一映射 (A = Access, D = Dirty, xv6 中不使用) 跳转到处理程序 tf-\u0026gt;kernel_trap 执行\n调用 usertrap() 后的系统状态 所有进程都被 “封存”\n通过 struct proc 就可以找到寄存器、内存、操作系统对象、…… 进程对应的 “内核线程” 开始执行 L2 - Kernel Multithreading 从另一个角度，“进程” 就是拥有了地址空间的线程 操作系统代码可以为所欲为\n修改任何一个状态机 例如，执行系统调用 执行系统调用时可能发生 I/O 中断 将任何另一个状态机调度到处理器上 (userret) 小结：状态机的封存 在执行完 “寄存器现场保存” 之后\n操作系统处于 “invariant 成立” 的状态 每个进程的状态机都被 “封存” 能被操作系统内核代码访问 xv6: struct proc 操作系统可以把任何一个状态机 “加载” 回 CPU 恢复寄存器和 $satp，然后 sret (保持 invariant, 包括 $scratch) 因为被封存，我们的处理器可以选择把任何一个状态机恢复\n机制：允许在中断/异常返回时把任何进程加载回 CPU 策略：处理器调度 (下次课) class: center, middle\n","date":"2022-09-09T22:32:41+08:00","permalink":"https://junling.li/posts/os-jyy-19/","section":"posts","tags":null,"title":"操作系统-jyy-19"},{"categories":null,"contents":"84. 柱状图中最大的矩形 给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。\n求在该柱状图中，能够勾勒出来的矩形的最大面积。\n示例 1:\n输入：heights = [2,1,5,6,2,3] 输出：10 解释：最大的矩形为图中红色区域，面积为 10 示例 2：\n输入： heights = [2,4] 输出： 4\n提示：\n1 \u0026lt;= heights.length \u0026lt;=10^5 0 \u0026lt;= heights[i] \u0026lt;= 10^4\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public int largestRectangleArea(int[] heights) { int n=heights.length; int []ph=new int [n+2]; int ans=0; for(int i=1;i\u0026lt;n+1;i++) ph[i]=heights[i-1]; Deque\u0026lt;Integer\u0026gt; stack=new ArrayDeque\u0026lt;\u0026gt;(); for(int i=0;i\u0026lt;n+2;i++){ // System.out.println(i+\u0026#34; \u0026#34;+stack); while(!stack.isEmpty()\u0026amp;\u0026amp;ph[stack.getLast()]\u0026gt;ph[i]){ int cur=stack.removeLast(); ans=Math.max(ans,(i-stack.getLast()-1)*ph[cur]); } stack.offer(i); } return ans; } } 这一题是干嘛呢？找到i左边和右边小于它的第一个数，中间就是最大面积了。\n方法是单调栈。\n注意栈里面记录的是下标。\n在Java中使用的是ArrayDeque数据结构。\n所以我建议看到有类似最右最左边找最小的数，优先来看看84是如何实现单调栈的。\n我们每次弹出的时候做计算！！\n为了加深印象，遂添加cpp题解\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public: int largestRectangleArea(vector\u0026lt;int\u0026gt;\u0026amp; heights) { int n=heights.size(); vector\u0026lt;int\u0026gt; v(n+2); for(int i=0;i\u0026lt;n;i++){ v[i+1]=heights[i]; } stack\u0026lt;int\u0026gt; s; int ans=0; for(int i=0;i\u0026lt;n+2;i++){ while(!s.empty()\u0026amp;\u0026amp;v[s.top()]\u0026gt;v[i]){ int cur=s.top(); s.pop(); ans=max(ans,v[cur]*(i-s.top()-1)); } s.push(i); } return ans; } }; 907. 子数组的最小值之和 难度中等402\n给定一个整数数组 arr，找到 min(b) 的总和，其中 b 的范围为 arr 的每个（连续）子数组。\n由于答案可能很大，因此 返回答案模 10^9 + 7 。\n示例 1：\n1 2 3 4 5 输入：arr = [3,1,2,4] 输出：17 解释： 子数组为 [3]，[1]，[2]，[4]，[3,1]，[1,2]，[2,4]，[3,1,2]，[1,2,4]，[3,1,2,4]。 最小值为 3，1，2，4，1，1，2，1，1，1，和为 17。 示例 2：\n1 2 输入：arr = [11,81,94,43,3] 输出：444 提示：\n1 \u0026lt;= arr.length \u0026lt;= 3 * 104 1 \u0026lt;= arr[i] \u0026lt;= 3 * 104 通过次数20,094\n提交次数58,149\n注意也是在弹出栈的时候做计算\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public: int sumSubarrayMins(vector\u0026lt;int\u0026gt;\u0026amp; arr) { int n=arr.size(); vector\u0026lt;int\u0026gt; v(n+2); for(int i=0;i\u0026lt;n;i++){ v[i+1]=arr[i]; } stack\u0026lt;int\u0026gt; s; int MOD=1000000007; long ans=0; for(int i=0;i\u0026lt;n+2;i++){ while(!s.empty()\u0026amp;\u0026amp;v[s.top()]\u0026gt;v[i]){ int cur=s.top(); s.pop(); // printf(\u0026#34;left:%d,mid=%d right%d,\\n\u0026#34;,s.top(),(cur),(i)); ans+=1l*(i-cur)%MOD*(cur-s.top())%MOD*v[cur]; ans%=MOD; } s.push(i); } return (int)ans%MOD; } }; ","date":"2022-09-06T17:08:11+08:00","permalink":"https://junling.li/leetcode/84.%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2/","section":"LeetCode","tags":null,"title":"84.柱状图中最大的矩形"},{"categories":null,"contents":"第17讲 Xv6 代码导读 (调试工具配置；调试系统调用执行) 经典UNIX v6的克隆\nxv6: UNIX v6 的现代 “克隆” 接近完整的 UNIX Shell 体验\n基本工具集 (wc, echo, cat, \u0026hellip;) 命令执行、管道、重定向 支持多处理器 Now in RISC-V! 下面是jyy狂吹xv6的code\n文档也十分不错，甚至可以当作操作系统的教科书。\n（你需要一个riscv-gnu-toolchain)\n工具链安装也十分简单，我们只需clone仓库，https://github.com/riscv-collab/riscv-gnu-toolchain\n1 2 3 4 sudo apt-get install autoconf automake autotools-dev curl python3 libmpc-dev libmpfr-dev libgmp-dev gawk build-essential bison flex texinfo gperf libtool patchutils bc zlib1g-dev libexpat-dev ./configure --prefix=/opt/riscv make linux 如何自动生成 compile_commands.json\nbear A tool to generate compilation json database\n使用 make qemu -\u0026gt; bear make qemu\n为什么要配置好工具？\n因为它可以让你愿意去读这个代码。 你内心里总有两股势力在斗争，一种是看代码好麻烦，我不想做了，另一个是老师说xv6代码很经典，值得学。 最终看哪一个势力取胜。\n有了工具就能帮你战胜惰性。\n这一点我很有感触。这一篇我整整写了4天，为什么，因为我clone 的时候一直fail，导致riscv的gcc一直没装好。就导致我的惰性取胜了。\nxv6进程发地址空间 init.c\ninit试图打开console，如果没有就创建它再打开。\n并执行一个while(1)，shell退出了就会立即再起一个shell\n神奇的页面 tarpframe和trampoline 调试用户代码 initcode-\u0026gt;ecall\ngdb初始化输入那么多你能接受吗？ gdb init，在执行gdb时自动执行脚本make qemu-gdb\necall是什么\n关中断 pc-\u0026gt;sepc 控制寄存器中会有一个flag stvec-\u0026gt;pc\n在 xv6 中\nTrampoline: $stvec = 0x3ffffff000 (只读) Trapframe (0x3fffffe000): 保存进程寄存器现场的内存 Trampoline (跳板) trampoline.S (汇编代码)\n对 ecall 瞬间的状态做快照\n填充 struct trapframe (proc.h)\n利用 $sscratch (S-mode scratch) 保存所有寄存器\n切换到内核栈 (相当于切换到进程对应的 “内核线程”, L2)\n切换到内核地址空间\n修改 $satp (S-mode address translation and protection) sfence.vma 跳转到\n1 tf-\u0026gt;kernel_trap 痛苦时间解除，进入 C 代码 系统调用处理 1 struct proc *p = myproc() 我们可以在 gdb 中查看 “进程” 在操作系统内的数据结构表示\n1 p/x *p 可以看到 trapframe 的地址 (和地址空间中映射的完全一样) p/x *p-\u0026gt;trapframe (a7 = 0x7)\n检查\n1 scause == 8 (syscall)\n$epc += 4 (更正返回地址) 打开中断 执行系统调用 1 usertrapret() 返回\necall 的逆操作 ","date":"2022-09-05T22:32:41+08:00","permalink":"https://junling.li/posts/os-jyy-18/","section":"posts","tags":null,"title":"操作系统-jyy-18"},{"categories":null,"contents":"第17讲 动态链接和加载 (静态 ELF 加载器实现；调试 Linux 内核；动态链接和加载) 从这里开始了看不懂的旅程\n若干真正的静态elf加载器 a.out:ELF header \u0026hellip;\nloader 需要做哪些工作：解析数据结构+复制到内存+跳转\n用mmap系统调用把elf描述的结构搬到内存中相应的位置loader-static.c\n设置运行时状态 argv,envp\n这是魔法？有没有偷偷调用其他的加载器？jyy的loader对env做了处理，过滤掉了带下划线的环境变量，以此证明在这短短的几行里确实实现了一个loader-static\n定义的函数功能与execve一样，用来从第一个参数中取file，直接映射文件的4096B到内存中。\n下面是抄手册的过程\nBoot Loader Load kernel 过程\n准备，load program\n下面开始编译内核\n动态链接 自然有运行时链接的需求\njyy表示elf内容很多，由于咱们的短时记忆能力有限，一灌输就会让我们栈溢出，导致咱们跟不少老师的思路\n我们需要实现什么?\n加载动态库 加载外部符号 为动态库导出符号 动态符号链接 1 2 3 4 5 6 7 8 9 10 11 12 13 14 DL_HEAD LOAD(\u0026#34;libc.dl\u0026#34;) # 加载动态库 IMPORT(putchar) # 加载外部符号 EXPORT(hello) # 为动态库导出符号 DL_CODE hello: ... call DSYM(putchar) # 动态链接符号 ... DL_END 让我们自己打造一套加载dl的工具链（大部分偷来的\ndlbox！\n","date":"2022-09-03T22:32:41+08:00","permalink":"https://junling.li/posts/os-jyy-17/","section":"posts","tags":null,"title":"操作系统-jyy-17"},{"categories":null,"contents":"minix2 请不要使用wsl2 mnt会有问题\n以后的课堂： 老师提出prompt，同学去问ai，不懂的全部去问ai\njyy:未来的教育会发生真真正正翻天覆地的变化\n第16讲 什么是可执行文件 (调试信息；Stack Unwinding；静态链接中的重定位) 今天的例子只有静态链接\n一个重要的手册System V ABI，一切的内容都在这里面了。\n如何读手册？\n需要前置知识才能读懂。对我们入门的人来说怎么办？\n关键的内容的部分，找到关键内容再去dfs扩散\n可执行文件是最重要的操作系统对象。用来被execve系统调用使用。\n状态机的状态，实际上是内存和寄存器的状态\nexec执行一个非可执行文件自然会失败，为什么？操作系统不让你执行 execve=-1,ENOEXEC 这是什么？\n查看手册\n1 2 3 ENOEXEC An executable is not in a recognized format, is for the wrong architecture, or has some other format error that means it cannot be executed. she-bang的方法偷梁换柱 a.c\n1 2 #!/usr/bin/python3 print(\u0026#34;hello\u0026#34;) 这也可以执行。\n那么b.c，执行./b.c实际上会执行a.out\n1 2 #!./a.out argv1 argv2 相当于execve帮你偷传参数了，相当于execve(\u0026quot;./a.out\u0026quot;,\u0026ldquo;argv1\u0026rdquo;, \u0026ldquo;argv2\u0026rdquo;)\n在手册中是这么写的\n1 2 3 4 5 6 7 8 9 10 Interpreter scripts An interpreter script is a text file that has execute permission enabled and whose first line is of the form: #!interpreter [optional-arg] The interpreter must be a valid pathname for an executable file. If the pathname argument of execve() specifies an interpreter script, then inter‐ preter will be invoked with the following arguments: 二进制工具集 binutils\n数据结构查看修改工具\n调试器读取运行时状态。为什么gdb知道出错的位置？\n靠的是二进制文件中的info。\ngcc -g\n关于popcount，我好像还有一点话要说 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include \u0026lt;stdio.h\u0026gt; __attribute__((noinline)) int popcount(int x) { int s = 0; int b0 = (x \u0026gt;\u0026gt; 0) \u0026amp; 1; s += b0; int b1 = (x \u0026gt;\u0026gt; 1) \u0026amp; 1; s += b1; int b2 = (x \u0026gt;\u0026gt; 2) \u0026amp; 1; s += b2; int b3 = (x \u0026gt;\u0026gt; 3) \u0026amp; 1; s += b3; return s; } int main() { printf(\u0026#34;%d\\n\u0026#34;, popcount(0b1101)); } 在某个知乎回答上我提过bitcount 底下就有z友评论了，不是有内建的popcount吗？😅建议不要用这种代码。内建的popcount 有些实现是汇编使用cpu机器指令，比这个快一倍轻轻松松。\n当然我看到的小技巧不一定比汇编实现的快，啊对对对。\n编译和链接 compile and link relocation\nS+A-P 太难了，没看懂\n重新理解编译、链接流程 编译器 (gcc)\nHigh-level semantics (C 状态机) → low-level semantics (汇编)\n汇编器 (as)\nLow-level semantics → Binary semantics (状态机容器)\n“一一对应” 地翻译成二进制代码\nsections, symbols, debug info 不能决定的要留下 “之后怎么办” 的信息 relocations 链接器 (ld)\n合并所有容器，得到 “一个完整的状态机”\nldscript (-Wl,\u0026ndash;verbose); 和 C Runtime Objects (CRT) 链接 missing/duplicate symbol 会出错 奇怪，我们完全没有讲 ELF 的细节？ ELF 就是一个 “容器数据结构”，包含了必要的信息\n你完全可以试着自己定义二进制文件格式 (dump it to disk)！\n1 2 3 4 5 6 7 8 9 struct executable { uint32_t entry; struct segment *segments; struct reloc *relocs; struct symbol *symbols; }; struct segment { uint32_t flags, size; char data[0]; } struct reloc { uint32_t S, A, P; char name[32]; }; struct symbol { uint32_t off; char name[32]; }; 当然，这有很多缺陷\n“名字” 其实应该集中存储 (const char * 而不是 char[]) 慢慢理解了 ELF 里的各种设计 (例如 memsz 和 filesz 不一样大) ","date":"2022-09-02T22:32:41+08:00","permalink":"https://junling.li/posts/os-jyy-16/","section":"posts","tags":null,"title":"操作系统-jyy-16"},{"categories":null,"contents":"众所周知，四川在今年夏天遭受了严重的缺电危机。为了保障居民用电，许多工业企业停电长达一周，写字楼、地铁也关了空调。春熙路关闭了外灯。\n某高校的寝室电费高达10元/每天。作为留守儿童，常常50元的电费5天就用完了。每个月的额度根本不够用。\n前几天在微信公众号乱逛的时候，发现了一个查询UESTC寝室用电量的接口。相比于支付宝仅仅能查询余额，多了一个查询用电量的功能。\nhttps://wx.uestc.edu.cn/oneCartoon/index.html?code=9fa9fa82ac76ea8d9703c948f4f6eba7\n当然查询也非常的简单，只需要 用Chrome的开发者工具，来看看点下搜索键以后发生了什么。\n向这个url发送了一个post请求，body为\u0026quot;roomCode=cep4NgTh7AgzjAeoLsMElQ==\u0026quot; 当然这个编号是经过加密的。\n我试了BASE64,BASE62,BASE100都不是，查看源码发现一个power.js，发现里面内置了各种加密的库。\n前端的这个加密index.js是混淆过的，由于我前端也没会多少，很难看出是怎么调用power.js的。虽然不影响咱们查询需要的房间号，但源码之上无事可做可真让人难受。\n下一步吧，做一个自动化的查询工具，帮我们自动发送post请求就好。\n查看一下请求头(Header)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 OST /power/oneCartoon/list HTTP/1.1 Accept: application/json, text/javascript, */*; q=0.01 Accept-Encoding: gzip, deflate, br Accept-Language: zh-CN,zh;q=0.9 Connection: keep-alive Content-Length: 37 Content-Type: application/x-www-form-urlencoded; charset=UTF-8 Cookie: UM_distinctid=182cfbdf0487ee-0cb4448310dd45-26021d51-240000-182cfbdf04913f3; iPlanetDirectoryPro=bclskTTZD3XboNv2eZmD6l Host: wx.uestc.edu.cn Origin: https://wx.uestc.edu.cn Referer: https://wx.uestc.edu.cn/oneCartoon/index.html?code=9fa9fa82ac76ea8d9703c948f4f6eba7\u0026amp;account=2019081305013 Sec-Fetch-Dest: empty Sec-Fetch-Mode: cors Sec-Fetch-Site: same-origin User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/104.0.0.0 Safari/537.36 X-Requested-With: XMLHttpRequest sec-ch-ua: \u0026#34;Chromium\u0026#34;;v=\u0026#34;104\u0026#34;, \u0026#34; Not A;Brand\u0026#34;;v=\u0026#34;99\u0026#34;, \u0026#34;Google Chrome\u0026#34;;v=\u0026#34;104\u0026#34; sec-ch-ua-mobile: ?0 sec-ch-ua-platform: \u0026#34;Windows\u0026#34; 通过我简单的二分发现只有 Content-Type: application/x-www-form-urlencoded; charset=UTF-8这一行是有用的，它指明了body的编解码格式。\nbody只有一个 roomCode=cep4NgTh7AgzjAeoLsMElQ==\n这一个加密是怎么来的，已经迷糊了我一天了？\n当然我们可以不用管，直接看看服务器返回我们什么：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 { \u0026#34;data\u0026#34;:{ \u0026#34;retcode\u0026#34;: \u0026#34;0\u0026#34;, \u0026#34;areaId\u0026#34;: null, \u0026#34;buiId\u0026#34;: \u0026#34;43\u0026#34;, \u0026#34;roomId\u0026#34;: \u0026#34;7240\u0026#34;, \u0026#34;roomName\u0026#34;: \u0026#34;120335\u0026#34;, \u0026#34;sydl\u0026#34;: \u0026#34;75.05\u0026#34;, \u0026#34;syje\u0026#34;: \u0026#34;40.26\u0026#34;, \u0026#34;msg\u0026#34;: \u0026#34;查询成功\u0026#34; }, \u0026#34;httpCode\u0026#34;: 200, \u0026#34;msg\u0026#34;: \u0026#34;请求成功\u0026#34;, \u0026#34;timestamp\u0026#34;: 1661950340964 } 算得上是非常好读了，sydl是还剩多少度电，syje是还剩多少钱。\n作为Java用户。下面就是用熟练的方式发送这个请求。\n咱们上一次在matu的怎么有人用码图啊中使用了jsoup，这次我们用OKhttp这个库来试试。\n核心代码如下：没有考虑到出错处理，请大家轻拍。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 public static Response ppp(String url) throws IOException { //创建OkHttpClient对象 OkHttpClient client = new OkHttpClient(); RequestBody requestBody=RequestBody.create(\u0026#34;roomCode=cep4NgTh7AgzjAeoLsMElQ%3D%3D\u0026#34;,MediaType.parse(\u0026#34;application/x-www-form-urlencoded; charset=UTF-8\u0026#34;)); //创建Request Request request = new Request.Builder() .url(url)//访问连接 .post(requestBody) .addHeader(\u0026#34;Content-Type\u0026#34;,\u0026#34;application/x-www-form-urlencoded; charset=UTF-8\u0026#34;) .build(); //创建Call对象 Call call = client.newCall(request); //通过execute()方法获得请求响应的Response对象 Response response = call.execute(); return response; } public static String dianfei() throws IOException { Response r = OkHttpUtils.ppp(\u0026#34;https://wx.uestc.edu.cn/power/oneCartoon/list\u0026#34;); String ans = r.body().string(); JSONObject ele = new JSONObject(ans); JSONObject data = ele.getJSONObject(\u0026#34;data\u0026#34;); try { String syje = data.getString(\u0026#34;syje\u0026#34;); String sydl = data.getString(\u0026#34;sydl\u0026#34;); return \u0026#34;Last count:\u0026#34; + syje + \u0026#34;CNY\\n Last power:\u0026#34; + sydl + \u0026#34;kwh\u0026#34;; } catch (JSONException e) { e.printStackTrace(); } return \u0026#34;\u0026#34;; } 作为一个mirai机器人选手，自然少不了通过群聊的方式查询功能。\n我们在qq群聊中监听查询请求（这里直接指定群聊），调用上述函数，即可完成实时查询电费。以下是效果：\n这个项目还是有遗憾的地方，目前roomcode的构建方式还知道，只能通过开发者工具看看前端计算的roomcode。目前来说，这个机器人只能查询咱们寝室的电费。实在是太逊了。\n但是经过一天的猜想和学习。\n我学废了nodejs，可以直接用node发送请求\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 function SendRequest(datatosend) { function OnResponse(response) { var data = \u0026#39;\u0026#39;; response.on(\u0026#39;data\u0026#39;, function(chunk) { data += chunk; //Append each chunk of data received to this variable. }); response.on(\u0026#39;end\u0026#39;, function() { var jsonParsed = JSON.parse(data); // console.log(data); var vals=jsonParsed[\u0026#39;data\u0026#39;] var roomName=vals[\u0026#39;roomName\u0026#39;] var dl=vals[\u0026#39;sydl\u0026#39;] var je=vals[\u0026#39;syje\u0026#39;] console.log(\u0026#34;房间号：\u0026#34;+roomName+\u0026#34;\\n剩余电量：\u0026#34;+dl+\u0026#34;kWh\\n剩余金额：\u0026#34;+je+\u0026#34;元\u0026#34;); //Display the server\u0026#39;s response, if any. }); } var request = http.request(urlparams, OnResponse); //Create a request object. request.write(datatosend); //Send off the request. request.end(); //End the request. } SendRequest(\u0026#34;roomCode=\u0026#34;+crynum); //Execute the function the request is in. } 既然nodejs入门了（不是），那我们是不是能看懂加密的过程了\n我灵机一动，看到index.js里roomCode\n{roomcode:_0x477250[_0x33e7('0x213','zw!i')](encrypt,_0x1e1aee)}\n虽然我啥都不知道它干了啥，但是在控制台上输入encrypt(\u0026ldquo;120335\u0026rdquo;)，然后就给我打印了cep4NgTh7AgzjAeoLsMElQ==\n这真是振奋人心的好结果。当然我也找到了函数原型，嗯谁能看懂？\n1 2 3 4 5 6 7 8 9 10 11 function encrypt(_0x461dd2) { var _0xc95c0 = {}; _0xc95c0[_0x33e7(\u0026#39;0x1e7\u0026#39;, \u0026#39;W[(T\u0026#39;)] = _0x33e7(\u0026#39;0x1c9\u0026#39;, \u0026#39;3iDq\u0026#39;); var _0x2c854d = _0xc95c0; var _0x29656e = CryptoJS[_0x33e7(\u0026#39;0x362\u0026#39;, \u0026#39;x3AB\u0026#39;)][_0x33e7(\u0026#39;0x14a\u0026#39;, \u0026#39;MQfJ\u0026#39;)][_0x33e7(\u0026#39;0x217\u0026#39;, \u0026#39;e$AE\u0026#39;)](_0x2c854d[_0x33e7(\u0026#39;0x20c\u0026#39;, \u0026#39;B9iG\u0026#39;)]); var _0x113ce7 = CryptoJS[_0x33e7(\u0026#39;0x289\u0026#39;, \u0026#39;wvF(\u0026#39;)][_0x33e7(\u0026#39;0x299\u0026#39;, \u0026#39;b7w3\u0026#39;)][_0x33e7(\u0026#39;0x12f\u0026#39;, \u0026#39;66GX\u0026#39;)](_0x461dd2); var _0x5c922b = CryptoJS[_0x33e7(\u0026#39;0x24d\u0026#39;, \u0026#39;U\u0026amp;UX\u0026#39;)][_0x33e7(\u0026#39;0x90\u0026#39;, \u0026#39;gln^\u0026#39;)](_0x113ce7, _0x29656e, { \u0026#39;mode\u0026#39;: CryptoJS[_0x33e7(\u0026#39;0x130\u0026#39;, \u0026#39;gln^\u0026#39;)][_0x33e7(\u0026#39;0x13f\u0026#39;, \u0026#39;MQfJ\u0026#39;)], \u0026#39;padding\u0026#39;: CryptoJS[_0x33e7(\u0026#39;0xd8\u0026#39;, \u0026#39;[0J^\u0026#39;)][_0x33e7(\u0026#39;0x2f\u0026#39;, \u0026#39;n$4Y\u0026#39;)] }); return _0x5c922b[_0x33e7(\u0026#39;0x243\u0026#39;, \u0026#39;jc)R\u0026#39;)](); } 经过我好几天的逆向(实际上是一晚上)\n1 2 3 4 5 6 7 8 9 10 function encrypt(_0x461dd2) { var _0xc95c0 = {}; var _0x29656e = CryptoJS[\u0026#39;enc\u0026#39;][\u0026#39;Utf8\u0026#39;][\u0026#39;parse\u0026#39;](\u0026#39;wxUESTCpowerqwer\u0026#39;); var _0x113ce7 = CryptoJS[\u0026#39;enc\u0026#39;][\u0026#39;Utf8\u0026#39;][\u0026#39;parse\u0026#39;](_0x461dd2); var _0x5c922b = CryptoJS[\u0026#39;AES\u0026#39;][\u0026#39;encrypt\u0026#39;](_0x113ce7, _0x29656e, { \u0026#39;mode\u0026#39;: CryptoJS[\u0026#39;mode\u0026#39;][\u0026#39;ECB\u0026#39;], \u0026#39;padding\u0026#39;: CryptoJS[\u0026#39;pad\u0026#39;][\u0026#39;Pkcs7\u0026#39;] }); return _0x5c922b[\u0026#39;toString\u0026#39;](); } 其实就是crypto-js的第一个示例代码,aseKey是\u0026rsquo;wxUESTCpowerqwer\u0026rsquo;，有了密钥能做的事情就很多了\n1 2 3 4 5 6 7 8 9 10 11 12 const CryptoJS = require(\u0026#39;crypto-js\u0026#39;); function cryptoEncryption(aseKey,message){ //aseKey为密钥（必须为：8/16/32位），message为要加密的密文 var encrypt = CryptoJS.AES.encrypt(message,CryptoJS.enc.Utf8.parse(aseKey),{ mode:CryptoJS.mode.ECB, padding:CryptoJS.pad.Pkcs7 }).toString(); return encrypt } var aseKey = \u0026#39;wxUESTCpowerqwer\u0026#39; var encrpytText = \u0026#34;120335\u0026#34;; console.log(cryptoEncryption(aseKey,encrpytText)); //调用加密方法 把上述解密和发送post请求合并为一个js文件，添加控制台传入参数，这就很优雅。甚至我们添加了错误处理（警觉）。 咱们是否可以通过公众号提供接口，为广大成电水友提供查询服务？\n在我飞速阅读了微信公众号平台的文档以后，\n使用 Python 快速踩坑（不是),快速起了一个web server。\n接收用户输入，经过简单判断是否为房间号，再fork-exec运行nodejs，\n微信公众平台的接口可比QQ机器人稳定多了。打通了这一过程还是有不少坑的。\n只需要向公众号的后台发送房间号，就可以看到电费使用情况了。\n欢迎关注我在微信平台的号哦（疯狂引流\n附上python\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 from Crypto.Cipher import AES from Crypto.Util.Padding import pad, unpad import requests import json import time import os import urllib def send_power(msgs): aseKey = \u0026#39;wxUESTCpowerqwer\u0026#39; try: headers = { \u0026#39;Content-Type\u0026#39;: \u0026#39;application/x-www-form-urlencoded; charset=UTF-8\u0026#39;, #Specifying to the server that we are sending JSON } key = \u0026#34;wxUESTCpowerqwer\u0026#34; def aes_ecb_encrypt(plaintext): cipher = AES.new(key.encode(),AES.MODE_ECB) return b64encode(cipher.encrypt(pad(plaintext.encode(),16))) def aes_ecb_decrypt(ciphertext): cipher = AES.new(key.encode(),AES.MODE_ECB) return unpad(cipher.decrypt(b64decode(ciphertext.encode())),16).decode() print(msgs) encryptStr=aes_ecb_encrypt(msgs) print(encryptStr) ss=str(encryptStr, encoding = \u0026#34;utf-8\u0026#34;) send_msg=\u0026#34;roomCode=\u0026#34;+urllib.parse.quote(ss) print(send_msg) #response = requests.post(\u0026#39;https://api.openai.com/v1/chat/completions\u0026#39;, headers=headers, json=json_data,timeout=14.2) response = requests.post(\u0026#39;https://wx.uestc.edu.cn/power/oneCartoon/list\u0026#39;, headers=headers, data=send_msg,timeout=4.2) response_parse = json.loads(response.text) data=response_parse[\u0026#34;data\u0026#34;] roomName=data[\u0026#39;roomName\u0026#39;] dl=data[\u0026#39;sydl\u0026#39;] je=data[\u0026#39;syje\u0026#39;] return \u0026#34;房间号：\u0026#34;+roomName+\u0026#34;\\n剩余电量：\u0026#34;+dl+\u0026#34;kWh\\n剩余金额：\u0026#34;+je+\u0026#34;元\u0026#34; except Exception as e: print(e) return \u0026#39;请求超时，请稍后再试！\u0026#39; ","date":"2022-09-02T22:09:23+08:00","permalink":"https://junling.li/posts/power/","section":"posts","tags":null,"title":"UESTC-电费查询"},{"categories":null,"contents":"第15讲 fork 的应用 (文件描述符的复制；写时复制；创建平行宇宙的魔法)\n既然前面都说过fork的形式语义，那你还不知道能用fork做哪些奇怪的事？\n关于fork的故事：\n一次fork引发的惨案！ 脚本之家 2021-11-03 17:00\n以下文章来源于编程技术宇宙 ，作者轩辕之风O\n编程技术宇宙.用故事说技术，编程从未如此有趣\n关注\n“脚本之家\n”，与百万开发者在一起\n作者 | 轩辕之风O\n来源 | 编程技术宇宙（ID：xuanyuancoding）\n“你还有什么要说的吗？没有的话我就要动手了”，kill程序最后问道。\n这一次，我没有再回答。\n只见kill老哥手起刀落，我短暂的一生就这样结束了···\n我是一个网络程序，一直以来都运行在Windows系统上，日子过得很舒服。可前段时间，程序员告诉我要把我移植到Linux系统下运行，需要对我大动手术，我平静的生活就这样被打破了。\n来到这个叫Linux的地方运行，一切对我都很陌生，没有了熟悉的C盘、D盘和E盘，取而代之的是各种各样的目录。\n1 2 3 4 5 6 7 8 9 10 11 12 /bin /boot /etc /dev /mnt /opt /proc /home /usr /usr64 /var /sys... 这里很有意思，一切都是文件，硬件设备是文件、管道是文件、网络套接字也是文件，搞得我很不适应。\n这些都还好，我都还能接受，但直到今天···\n*- 1 -*\n奇怪的fork 今天早上，我收到了一个网络请求，需要完成一个功能，这个工作比较耗时，我准备创建一个子进程，让我的小弟去完成。\n这是我第一次在Linux系统上创建进程，有点摸不着北，看了半天，只看到程序员在我的代码里写了一个fork函数：\n1 2 3 4 pid_t pid=fork(); if ( pid \u0026gt; 0 ) { ···} else if( pid == 0 ) { ···} else { ···} 我晃晃悠悠的来到fork函数的门前，四处观察。\n“您是要创建进程吗？”，fork函数好像看出了我的来意。\n“是的，我是第一次在这里创建进程，以前我在Windows那片儿的时候，都是调用CreateProcess，但这里好像没有叫这个名字的函数···”\nfork函数听后笑了起来，说道：“别找了，我就是负责创建进程的函数”\n“你？fork不是叉子的意思吗，好端端的干嘛取这么个名字？”，我一边说，一边朝fork函数走去。\nfork没有理会我的问题，只是说道：“您这边稍坐一下，我要跟内核通信一下，让内核创建一个子进程”\n这下我倒是明白他的意思，像创建进程这种操作，都是由操作系统内核中的系统调用来完成的，而像fork这些我们可以直接调用的函数只是应用层的接口而已，这跟以前在Windows上是一样的。\n不过我突然反应过来，着急问道：“唉，我还没告诉你要创建的进程参数呢，你怎么知道要启动哪个程序？”\nfork扑哧一下笑出了声，不过并没有回答我的问题。\n人生地不熟的，我也没好再多问，只好耐心等待，等待期间我竟然睡着了。\n“醒醒”，不知过了多久，fork函数叫醒了我：“创建完成了，请拿好，这是进程号pid”，说完给了我一个数字。\n我摊开一看，居然写了一个大大的0！\n“怎么搞的，创建失败了？”，我问到。\n“没有啊，您就是刚刚创建的子进程”\n“啥？你是不是搞错了，我就是专程来创建子进程的，我自己怎么会是子进程？”\nfork函数又笑了，“我没有搞错，您其实已经不是原来的你了，而是一个复制品，是内核刚刚复制出来的”\n“复制品？什么意思？”，我越听越懵！\n“每个进程在内核中都是一个task_struct结构，刚才您睡着期间，内核在创建进程的时候，把内核中原来的你的task_struct复制了一份，还创建了一个全新的进程地址空间和堆栈，现在的你和原来的你除了极少数地方不一样，基本上差不多”\n“那原来的我呢？去哪里了”\n“他已经变成你的父进程了，我是一个特殊的函数，一次调用会返回两次，在父进程和子进程中都会返回。在原来的进程中，我把你的进程号给了他，而我返回给你0，就表示你现在就是子进程”\n原来是这样，我大受震撼，这简直颠覆我的认知，居然还有如此奇特的函数，调用一次，就变成了两个进程，思考之间，我忽然有些明白这个函数为什么要叫fork的原因了。\n*- 2 -*\n写时拷贝 “您是刚来咱们这里吧，可能还不太熟悉，慢慢就习惯了”\n“你们这效率也太高了吧，整个进程地址空间那么大，居然这么快就复制了一份！”\nfork函数又笑了！难道我又说错话了？\n“进程的内存地址空间可没有复制，你现在和父进程是共享的内存空间的”\n“啥？共享？你刚才不是说创建了新的进程空间和堆栈吗？”\n“您看到的内存地址空间是虚拟的，您的内存页面和父进程的内存页面实际上是映射的同一个物理内存页，所以实际上是共享的哟”\n“原来是这样，可是弄成共享了，两个进程一起用，岂不是要出乱子？”\n“放心，内核把这些页面都设置成了只读，如果你们只是读的话，不会有问题，但只要有一方尝试写入，就会触发异常，内核发现异常后再去分配一个新的页面让你们分开使用。哦对了，这个叫写时拷贝（COW） 机制”\n“有点意思，你们倒是挺聪明的”\n“没办法，尽量压缩成本，提高创建进程的效率嘛，因为进程中的很多内存页面都只会去读，如果全部无脑拷贝一份，那不是太浪费资源和时间了吗”，fork函数说到。\n“有道理，有道理”，我点了点头，告别了fork函数，准备回去继续工作。\n- 3 -\n消失的线程们 本以为这奇怪的进程创建方式已经让我大开眼界了，没想到可怕的事情才刚刚开始。\n告别fork函数没多久，我就卡在了一个地方没法执行下去，原来，前面有一把锁被别的线程占用了，而我现在也需要占用它。\n这倒也不足为奇，以往工作的时候，也经常碰到锁被别的线程锁定的情况，但这一次，我等了很久也一直不见有线程来释放。\n“喂，醒醒”\n不知过了多久，我竟然又睡着了。\n睁开眼睛，另一个程序站出现在了我的面前。\n“你是？”\n“你好，我是kill”\n“kill？那个专门杀进程的kill程序？你来找我干嘛”，我惊的一下睡意全无。\nkill程序从背后拿出了两个数字：9，1409\n“你看，这是我收到的参数，1409是你的进程号PID，9表示要强制杀死你”\n“啊？为什么？”，那一刻，我彻底慌了。\n“可能是你卡死在这里太久了吧，人类才启动我来结束你的运行”，kill程序说到。\n“是啊，不知道是哪个该死的线程占用了这把锁一直不释放，我才卡在这里”，我委屈的说到。\n“哪里有别的线程，我看了一下，你这进程就只有一个线程啊！”\n“你看错了吧？”，说完，我认真检查了起来，居然还真只有一个线程了！我白等了这么久！\n“奇怪了，我明明是一个多线程的程序啊！”，我眉头紧锁。\n“你仔细想想，刚才有没有发生什么事情？”，kill程序问到。\n“我就执行了一下fork，生成了一个子进程，哦对了，我就是那个子进程”\n“难怪！”，kill程序恍然大悟。\n“难怪什么？\n“fork那家伙创建子进程的时候，只会复制当前的线程，其他线程不会被复制！”，Kill程序说完叹了口气，仿佛已经见怪不怪了。\n“what？怎么会这样？其他线程没复制，那岂不是要出乱子？”\nkill程序不紧不慢地说道：“这都是历史遗留问题了，早期都是单线程的程序，一个task_struct就是一个进程，fork这样做是没有问题的，后来出现了多线程技术，一个task_struct实际上是一个线程了，多个task_struct通过共享地址空间，成为一个线程组，也就是进程，但fork仍然只复制当前的线程，就有了这个问题”\n“我去，这坑爹的fork！”\n“你不是第一个被坑的了！等着程序员把你重新改造下吧”\n“唉···”，我长长的叹了口气。\n“你还有什么要说的吗？没有的话我就要动手了”，kill程序最后问道。\n这一次，我没有再回答。\n只见kill老哥手起刀落，一切都消失了···\n【完】\n看看jyy是怎么把fork玩出花的。\nsh-xv6.c\nfork状态机复制包括持有的所有操作系统对象 execve重置状态机，但继承持有的所有操作系统对象 由此可以轻松实现管道。\n什么是文件描述符？\n一个指向操作系统内对象的指针\nO_CLOEXEC 关闭execve继承的文件描述符\n对于数据文件，文件描述符会记住上一次打开的位置。(offset)\n一个例子\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 $ cat a.c #include\u0026lt;fcntl.h\u0026gt; #include\u0026lt;unistd.h\u0026gt; #include\u0026lt;assert.h\u0026gt; int main(){ int fd = open(\u0026#34;a.txt\u0026#34;, O_WRONLY | O_CREAT); assert(fd \u0026gt; 0); pid_t pid = fork(); assert(pid \u0026gt;= 0); if (pid == 0) { write(fd, \u0026#34;Hello\u0026#34;,5); } else { write(fd, \u0026#34;World\u0026#34;,5); } } $ cat a.txt WorldHello 使用dup复制文件描述符，\n两个文件描述符是共享offset的，但不共享descriptor flags\nfork还需要考虑的问题\n1GB内存的进程，fork以后这1GB完全复制吗?\n解决办法：写时复制\n进程的页面是由操作系统管理的，进程看到的页面是由一层映射关系的。\n这一段 jyy讲的很细，一步一步来很舒服。\n对于libc.so，复制是假的复制。整个系统只有一份libc.so的实体。\n例子 cow-test.c 好吧，看来今天还是颠覆了我的一点认知的，因为共享的存在，进程的内存占用空间不可信了。\n状态机并行还可以做什么？\n平行宇宙！\n1.dfs记住状态，fork的魔法。 dfs-fork.c 这个跑起来还是蛮震撼的，让快睡着的我顿时来了兴趣。\n2.跳过初始化 QEMU,JVM初始化加载\n3.备份 创建快照\n容错计算\nfork带来的一些麻烦 引入信号以后如何处理\n线程怎么办？\n更\u0026hellip;的解决方案 POSIX spawn\n","date":"2022-09-01T22:32:41+08:00","permalink":"https://junling.li/posts/os-jyy-15/","section":"posts","tags":null,"title":"操作系统-jyy-15"},{"categories":null,"contents":"第14讲 C标准库的实现 系统调用的封装，内存空间管理\n不会有人想用汇编来写操作系统吧，不会有人想直接用系统调用构建吧。 不会真的有人在oj上写题，不用printf用write系统调用吧。\n对系统调用进行封装，是自然而然的想法。\n重新认识libc 一个例子\nexecve的pathname是绝对路径，但是你希望使用PATH下的路径可以吗?你想不按照规定来?没门。\nexeclp帮助你去遍历env的PATH，挨个执行execve看看能不能找到合适的pathname。高情商api，这才是人民群众喜闻乐见的api\n封装纯粹的计算，比如memset。 标准库要正确，并快。兼容很多cpu\n多个线程同时memset怎么办？库函数要考虑的问题比自己写的要多得多。\n标准库只对“标准库内部数据”的线程安全性负责\n更多标准库需要做的：排序，查找,atoi,atol,atoll\n计算就更复杂了 怎样在IEEE754这个浮点数优化计算，754在-1到1之间很密，怎么利用这个特性，怎么避免-INF精度爆炸的问题。\n封装操作系统的对象 在UNIX的世界里，实际上就是封装文件描述符\nFILE * 背后是一个文件描述符\n1 2 3 4 5 6 7 #include\u0026lt;stdlib.h\u0026gt; #include\u0026lt;stdio.h\u0026gt; int main(){ FILE *fp=fopen(\u0026#34;a.txt\u0026#34;,\u0026#34;w\u0026#34;); fprintf(fp,\u0026#34;Hello os\u0026#34;); } 窥探glibc的内部实现\n1 2 3 openat(AT_FDCWD, \u0026#34;a.txt\u0026#34;, O_WRONLY|O_CREAT|O_TRUNC, 0666) = 3 fstat(3, {st_mode=S_IFREG|0644, st_size=0, ...}) = 0 write(3, \u0026#34;Hello os\u0026#34;, 8) = 8 返回了一个3 的文件描述符，并在3这里做了一个write的系统调用\n我们甚至可以在gdb上p *fp或者p *stdin，会发现stdin的filenum=0\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 $1 = {_flags = -72539004, _IO_read_ptr = 0x0, _IO_read_end = 0x0, _IO_read_base = 0x0, _IO_write_base = 0x0, _IO_write_ptr = 0x0, _IO_write_end = 0x0, _IO_buf_base = 0x0, _IO_buf_end = 0x0, _IO_save_base = 0x0, _IO_backup_base = 0x0, _IO_save_end = 0x0, _markers = 0x0, _chain = 0x7ffff7fb85c0 \u0026lt;_IO_2_1_stderr_\u0026gt;, _fileno = 3, _flags2 = 0, _old_offset = 0, _cur_column = 0, _vtable_offset = 0 \u0026#39;\\000\u0026#39;, _shortbuf = \u0026#34;\u0026#34;, _lock = 0x555555559380, _offset = -1, _codecvt = 0x0, _wide_data = 0x555555559390, _freeres_list = 0x0, _freeres_buf = 0x0, __pad5 = 0, _mode = 0, _unused2 = \u0026#39;\\000\u0026#39; \u0026lt;repeats 19 times\u0026gt;} (gdb)n (gdb)p *fp $2 = {_flags = -72536956, _IO_read_ptr = 0x555555559480 \u0026#34;Hello os\u0026#34;, _IO_read_end = 0x555555559480 \u0026#34;Hello os\u0026#34;, _IO_read_base = 0x555555559480 \u0026#34;Hello os\u0026#34;, _IO_write_base = 0x555555559480 \u0026#34;Hello os\u0026#34;, _IO_write_ptr = 0x555555559488 \u0026#34;\u0026#34;, _IO_write_end = 0x55555555a480 \u0026#34;\u0026#34;, _IO_buf_base = 0x555555559480 \u0026#34;Hello os\u0026#34;, _IO_buf_end = 0x55555555a480 \u0026#34;\u0026#34;, _IO_save_base = 0x0, _IO_backup_base = 0x0, _IO_save_end = 0x0, _markers = 0x0, _chain = 0x7ffff7fb85c0 \u0026lt;_IO_2_1_stderr_\u0026gt;, _fileno = 3, _flags2 = 0, _old_offset = 0, _cur_column = 0, _vtable_offset = 0 \u0026#39;\\000\u0026#39;, _shortbuf = \u0026#34;\u0026#34;, _lock = 0x555555559380, _offset = -1, _codecvt = 0x0, _wide_data = 0x555555559390, _freeres_list = 0x0, _freeres_buf = 0x0, __pad5 = 0, _mode = -1, _unused2 = \u0026#39;\\000\u0026#39; \u0026lt;repeats 19 times\u0026gt;} 怪?\n这就是UNIX\n封装更多的东西 err,error,perror\n为什么你在很多地方都能看到No such file or directory?\n我们也可以打印一个这样的error msg\n1 2 3 4 5 6 7 8 9 10 #include\u0026lt;stdlib.h\u0026gt; #include\u0026lt;stdio.h\u0026gt; #include\u0026lt;err.h\u0026gt; int main(){ const char *fname = \u0026#34;xxx.c\u0026#34;; FILE *fp=fopen(fname,\u0026#34;r\u0026#34;); if(!fp){ warn(\u0026#34;%s\u0026#34;,fname); } } 原来大家和我用的是同一个标准库\n1 2 3 4 charon@DESKTOP-EIMRFTO:~/jyy/14$ gcc a.c charon@DESKTOP-EIMRFTO:~/jyy/14$ ./a.out a.out: xxx.c: No such file or directory charon@DESKTOP-EIMRFTO:~/jyy/14$ cat a.c 下一个关于env的魔术\n1 2 3 4 5 6 7 8 #include \u0026lt;stdio.h\u0026gt; int main() { extern char **environ; for (char **env = environ; *env; env++) { printf(\u0026#34;%s\\n\u0026#34;, *env); } } 链接的时候会找到这个**environ 那么状态机重置以后**environ会变成什么?\n我们通过gdb一步一步看一下哪一步**environ被赋值的\n静态链接结果:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 (gdb) wa (char**)environ Hardware watchpoint 1: (char**)environ (gdb) c The program is not being run. (gdb) start Temporary breakpoint 2 at 0x401d05: file env.c, line 3. Starting program: /home/charon/jyy/14/a.out Watchpoint 1: (char**)environ Old value = (char **) 0x0 New value = (char **) 0x7fffffffe1b8 0x000000000040213a in __libc_start_main () (gdb) 是__libc_start_main()赋值的\n动态链接结果：\n1 2 3 4 5 6 7 8 9 10 11 12 (gdb) wa (char**)environ Hardware watchpoint 1: (char**)environ (gdb) start Temporary breakpoint 2 at 0x1149: file env.c, line 3. Starting program: /home/charon/jyy/14/a.out Watchpoint 1: (char**)environ Old value = (char **) 0x0 New value = (char **) 0x7fffffffe1b8 _init (argc=1, argv=\u0026lt;optimized out\u0026gt;, envp=\u0026lt;optimized out\u0026gt;) at init-first.c:77 77 init-first.c: No such file or directory. 封装地址空间 malloc和free\n标准库的实现要考虑什么?\n用户的使用场景\n小对象的创建/分配迅速（需要考虑并发） 大的数组和对象拥有更长的生命周期（不太需要并发） 设置两套系统，考虑fast path和slow path\nfast path 性能极好、并行度极高、覆盖大部分情况 但有小概率会失败 (fall back to slow path) slow path 不在乎那么快 但把困难的事情做好 计算机系统里有很多这样的例子 (比如 cache) 人类也是这样的系统\nDaniel Kahneman. Thinking, Fast and Slow. Farrar, Straus and Giroux, 2011.\n小内存：Segregated List\n分配: Segregated List (Slab)\n每个 slab 里的每个对象都一样大 每个线程拥有每个对象大小的 slab fast path → 立即在线程本地分配完成 slow path → pgalloc() 两种实现 全局大链表 v.s. List sharding (per-page 小链表)\n回收\n直接归还到 slab 中 注意这可能是另一个线程持有的 slab，需要 per-slab 锁 (小心数据竞争) 大内存：一把大锁保平安 Buddy system (1963)\n如果你想分配 1, 2, 3, 4, \u0026hellip; 个连续的页面？ 例如：64 KB/页面 那就 first fit 或者 best fit 吧…… 你只需要一个数据结构解决问题\n区间树；线段树……\n更多标准库的设计推荐阅读libc的手册\n","date":"2022-09-01T00:09:23+08:00","permalink":"https://junling.li/posts/os-jyy-14/","section":"posts","tags":null,"title":"操作系统-jyy-14"},{"categories":null,"contents":"第13讲 系统调用和Shell freestanding shell, 终端和 job control\nUNIX Shell的设计和实现\n0依赖的shell 1 ld sh-xv6.o -o sh 管道实现\n左子树右子树抽象| (echo a;echo b)|wc -l fork的子进程拥有pipefd[0]以及pipefd[1]，相当于父子进程共享管道 子线程执行左边，主进程执行右边，\npipe() creates a pipe, a unidirectional data channel that can be used for interpro‐ cess communication. The array pipefd is used to return two file descriptors refer‐ ring to the ends of the pipe. pipefd[0] refers to the read end of the pipe. pipefd[1] refers to the write end of the pipe. Data written to the write end of the pipe is buffered by the kernel until it is read from the read end of the pipe. For further details, see pipe(7).\n具体来说，对子进程，关闭编号为1的文件描述符（stdout），拷贝1到一个空闲的文件描述符。相当于把stdout指向管道的写口。 然后关闭p0和p1.执行|左边内容\n之后又执行一个fork。子进程关闭编号为0的文件描述符（stdin），拷贝0到空闲文件描述符，关闭p0和p1.执行|右边内容\n父进程关闭p0和p1，执行两个wait，等待父子都执行完成。\n我们通过strace来探究一下./sh究竟做了什么。\n小技巧tail -f filename 实现热更新查看文件\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 29949 read(0, \u0026#34;.\u0026#34;, 1) = 1 29949 read(0, \u0026#34;/\u0026#34;, 1) = 1 29949 read(0, \u0026#34;a\u0026#34;, 1) = 1 29949 read(0, \u0026#34;.\u0026#34;, 1) = 1 29949 read(0, \u0026#34;o\u0026#34;, 1) = 1 29949 read(0, \u0026#34;u\u0026#34;, 1) = 1 29949 read(0, \u0026#34;t\u0026#34;, 1) = 1 29949 read(0, \u0026#34; \u0026#34;, 1) = 1 29949 read(0, \u0026#34;|\u0026#34;, 1) = 1 29949 read(0, \u0026#34;/\u0026#34;, 1) = 1 29949 read(0, \u0026#34;b\u0026#34;, 1) = 1 29949 read(0, \u0026#34;i\u0026#34;, 1) = 1 29949 read(0, \u0026#34;n\u0026#34;, 1) = 1 29949 read(0, \u0026#34;/\u0026#34;, 1) = 1 29949 read(0, \u0026#34;w\u0026#34;, 1) = 1 29949 read(0, \u0026#34;c\u0026#34;, 1) = 1 29949 read(0, \u0026#34; \u0026#34;, 1) = 1 29949 read(0, \u0026#34;-\u0026#34;, 1) = 1 29949 read(0, \u0026#34;l\u0026#34;, 1) = 1 29949 read(0, \u0026#34;\\n\u0026#34;, 1) = 1 29949 fork() = 30089 29949 wait4(-1, \u0026lt;unfinished ...\u0026gt; 30089 pipe([3, 4]) = 0 30089 fork( \u0026lt;unfinished ...\u0026gt; 30090 close(1 \u0026lt;unfinished ...\u0026gt; 30089 \u0026lt;... fork resumed\u0026gt;) = 30090 30090 \u0026lt;... close resumed\u0026gt;) = 0 30089 fork( \u0026lt;unfinished ...\u0026gt; 30090 dup(4) = 1 30091 close(0 \u0026lt;unfinished ...\u0026gt; 30090 close(3 \u0026lt;unfinished ...\u0026gt; 30091 \u0026lt;... close resumed\u0026gt;) = 0 30089 \u0026lt;... fork resumed\u0026gt;) = 30091 30091 dup(3 \u0026lt;unfinished ...\u0026gt; 30090 \u0026lt;... close resumed\u0026gt;) = 0 30091 \u0026lt;... dup resumed\u0026gt;) = 0 30089 close(3 \u0026lt;unfinished ...\u0026gt; 30091 close(3 \u0026lt;unfinished ...\u0026gt; 30090 close(4 \u0026lt;unfinished ...\u0026gt; 30091 \u0026lt;... close resumed\u0026gt;) = 0 30089 \u0026lt;... close resumed\u0026gt;) = 0 30091 close(4 \u0026lt;unfinished ...\u0026gt; 30090 \u0026lt;... close resumed\u0026gt;) = 0 30091 \u0026lt;... close resumed\u0026gt;) = 0 30089 close(4 \u0026lt;unfinished ...\u0026gt; 30091 execve(\u0026#34;/bin/wc\u0026#34;, [\u0026#34;/bin/wc\u0026#34;, \u0026#34;-l\u0026#34;], NULL \u0026lt;unfinished ...\u0026gt; 30090 execve(\u0026#34;./a.out\u0026#34;, [\u0026#34;./a.out\u0026#34;], NULL \u0026lt;unfinished ...\u0026gt; 30089 \u0026lt;... close resumed\u0026gt;) = 0 30089 wait4(-1, \u0026lt;unfinished ...\u0026gt; 30090 \u0026lt;... execve resumed\u0026gt;) = 0 30091 \u0026lt;... execve resumed\u0026gt;) = 0 30090 write(1, \u0026#34;\\33[01;31mHello, OS World\\33[0m\\n\u0026#34;, 28 \u0026lt;unfinished ...\u0026gt; 30091 brk(NULL \u0026lt;unfinished ...\u0026gt; 30090 \u0026lt;... write resumed\u0026gt;) = 28 30091 \u0026lt;... brk resumed\u0026gt;) = 0x55b702392000 30090 exit(1 \u0026lt;unfinished ...\u0026gt; 30091 arch_prctl(0x3001 /* ARCH_??? */, 0x7ffc435e6820 \u0026lt;unfinished ...\u0026gt; 30090 \u0026lt;... exit resumed\u0026gt;) = ? 30091 \u0026lt;... arch_prctl resumed\u0026gt;) = -1 EINVAL (Invalid argument) 30090 +++ exited with 1 +++ 30089 \u0026lt;... wait4 resumed\u0026gt;NULL, 0, NULL) = 30090 30091 access(\u0026#34;/etc/ld.so.preload\u0026#34;, R_OK \u0026lt;unfinished ...\u0026gt; 30089 --- SIGCHLD {si_signo=SIGCHLD, si_code=CLD_EXITED, si_pid=30090, si_uid=1000, si_status=1, si_utime=0, si_stime=0} --- 30091 \u0026lt;... access resumed\u0026gt;) = -1 ENOENT (No such file or directory) 30089 wait4(-1, \u0026lt;unfinished ...\u0026gt; 30091 openat(AT_FDCWD, \u0026#34;/etc/ld.so.cache\u0026#34;, O_RDONLY|O_CLOEXEC) = 3 30091 fstat(3, {st_mode=S_IFREG|0644, st_size=42648, ...}) = 0 30091 mmap(NULL, 42648, PROT_READ, MAP_PRIVATE, 3, 0) = 0x7f6abd690000 30091 close(3) = 0 30091 openat(AT_FDCWD, \u0026#34;/lib/x86_64-linux-gnu/libc.so.6\u0026#34;, O_RDONLY|O_CLOEXEC) = 3 30091 read(3, \u0026#34;\\177ELF\\2\\1\\1\\3\\0\\0\\0\\0\\0\\0\\0\\0\\3\\0\u0026gt;\\0\\1\\0\\0\\0\\300A\\2\\0\\0\\0\\0\\0\u0026#34;..., 832) = 832 30091 pread64(3, \u0026#34;\\6\\0\\0\\0\\4\\0\\0\\0@\\0\\0\\0\\0\\0\\0\\0@\\0\\0\\0\\0\\0\\0\\0@\\0\\0\\0\\0\\0\\0\\0\u0026#34;..., 784, 64) = 784 30091 pread64(3, \u0026#34;\\4\\0\\0\\0\\20\\0\\0\\0\\5\\0\\0\\0GNU\\0\\2\\0\\0\\300\\4\\0\\0\\0\\3\\0\\0\\0\\0\\0\\0\\0\u0026#34;, 32, 848) = 32 30091 pread64(3, \u0026#34;\\4\\0\\0\\0\\24\\0\\0\\0\\3\\0\\0\\0GNU\\0\\30x\\346\\264ur\\f|Q\\226\\236i\\253-\u0026#39;o\u0026#34;..., 68, 880) = 68 30091 fstat(3, {st_mode=S_IFREG|0755, st_size=2029592, ...}) = 0 30091 mmap(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f6abd68e00030091 pread64(3, \u0026#34;\\6\\0\\0\\0\\4\\0\\0\\0@\\0\\0\\0\\0\\0\\0\\0@\\0\\0\\0\\0\\0\\0\\0@\\0\\0\\0\\0\\0\\0\\0\u0026#34;..., 784, 64) = 784 30091 pread64(3, \u0026#34;\\4\\0\\0\\0\\20\\0\\0\\0\\5\\0\\0\\0GNU\\0\\2\\0\\0\\300\\4\\0\\0\\0\\3\\0\\0\\0\\0\\0\\0\\0\u0026#34;, 32, 848) = 32 30091 pread64(3, \u0026#34;\\4\\0\\0\\0\\24\\0\\0\\0\\3\\0\\0\\0GNU\\0\\30x\\346\\264ur\\f|Q\\226\\236i\\253-\u0026#39;o\u0026#34;..., 68, 880) = 68 30091 mmap(NULL, 2037344, PROT_READ, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0x7f6abd49c000 30091 mmap(0x7f6abd4be000, 1540096, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x22000) = 0x7f6abd4be000 30091 mmap(0x7f6abd636000, 319488, PROT_READ, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x19a000) = 0x7f6abd636000 30091 mmap(0x7f6abd684000, 24576, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x1e7000) = 0x7f6abd684000 30091 mmap(0x7f6abd68a000, 13920, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0x7f6abd68a000 30091 close(3) = 0 30091 arch_prctl(ARCH_SET_FS, 0x7f6abd68f580) = 0 30091 mprotect(0x7f6abd684000, 16384, PROT_READ) = 0 30091 mprotect(0x55b702127000, 4096, PROT_READ) = 0 30091 mprotect(0x7f6abd6c8000, 4096, PROT_READ) = 0 30091 munmap(0x7f6abd690000, 42648) = 0 30091 brk(NULL) = 0x55b702392000 30091 brk(0x55b7023b3000) = 0x55b7023b3000 30091 fadvise64(0, 0, 0, POSIX_FADV_SEQUENTIAL) = -1 ESPIPE (Illegal seek) 30091 read(0, \u0026#34;\\33[01;31mHello, OS World\\33[0m\\n\u0026#34;, 16384) = 28 30091 read(0, \u0026#34;\u0026#34;, 16384) = 0 30091 fstat(1, {st_mode=S_IFCHR|0620, st_rdev=makedev(0x88, 0), ...}) = 0 30091 write(1, \u0026#34;1\\n\u0026#34;, 2) = 2 30091 close(0) = 0 30091 close(1) = 0 30091 close(2) = 0 shell的一些有趣的操作 The Shell Programming Language 基于文本替换的快速工作流搭建\n重定向: cmd \u0026gt; file \u0026lt; file 2\u0026gt; /dev/null 顺序结构: cmd1; cmd2, cmd1 \u0026amp;\u0026amp; cmd2, cmd1 || cmd2 管道: cmd1 | cmd2 预处理: $(), \u0026lt;() 变量/环境变量、控制流……\nShell 还有一些未解之谜 为什么 Ctrl-C 可以退出程序？\n为什么有些程序又不能退出？\n没有人 read 这个按键，为什么进程能退出？ Ctrl-C 到底是杀掉一个，还是杀掉全部？ 如果我 fork 了一份计算任务呢？ 如果我 fork-execve 了一个 shell 呢？ Hmmm……\nshell 和终端的区别\n这也是我一直迷惑的地方。有的时候，比如gdb在调试一个a.out此时需要另一个窗口做一些别的事情。除了!命令以外，我一般会在terminal里开另外一个窗口。\n通过tty命令知道，每一个窗口其实是一个块设备。\n1 2 $ tty /dev/pts/0 甚至可以直接用重定向向另一个窗口发送信息，这太神奇了\n1 $ echo hello \u0026gt;\u0026gt; /dev/pts/1 ctrl +c的故事\n终端产生信号\n通过signal-handler.c这个例子可以改写收到信号之后的操作。\n我通过另一个终端的htop向a.out发送SIGINT发现./a.out输出Received SIGIN还是挺神奇的。\n","date":"2022-08-30T21:09:23+08:00","permalink":"https://junling.li/posts/os-jyy-13/","section":"posts","tags":null,"title":"操作系统-jyy-13"},{"categories":null,"contents":"第12讲 进程的地址空间 堆区，栈只是对平坦的内存地址空间进行的抽象。对于汇编来说，能看见的只有地址，寄存器。 比如定义一个指针，可以指向任何地方，但是你不能访问。就算你可以访问，也不一定能写它。\npmap report memory of a process 是通过访问procfs(/proc/)实现的\n(gdb)info inferiors 查看进程号\n1 2 3 4 5 6 7 8 9 10 11 (gdb) info inferiors Num Description Executable * 1 process 25732 /home/charon/jyy/12/a.out (gdb) !pmap 25732 25732: /home/charon/jyy/12/a.out 0000000000400000 4K r---- a.out 0000000000401000 4K r-x-- a.out 00007ffff7ffa000 16K r---- [ anon ] 00007ffff7ffe000 4K r-x-- [ anon ] 00007ffffffde000 132K rw--- [ stack ] total 160K 操作系统在用execve创建进程时，就会把参数，环境变量放到stack里\npmap究竟执行了什么系统调用，可以通过strace pmap pid来探究一下\nopenat打开了一个文件 /proc/25732/maps\n1 2 3 4 5 6 (gdb) !cat /proc/25732/maps 00400000-00401000 r--p 00000000 08:10 1591 /home/charon/jyy/12/a.out 00401000-00402000 r-xp 00001000 08:10 1591 /home/charon/jyy/12/a.out 7ffff7ffa000-7ffff7ffe000 r--p 00000000 00:00 0 [vvar] 7ffff7ffe000-7ffff7fff000 r-xp 00000000 00:00 0 [vdso] 7ffffffde000-7ffffffff000 rw-p 00000000 00:00 0 [stack] 推荐宝藏手册man 5 proc\n[vdso] The virtual dynamically linked shared object. See vdso(7).\n我们可以对照 readelf中的Program Header 来验证\n1 2 3 4 5 6 7 Program Headers: Type Offset VirtAddr PhysAddr FileSiz MemSiz Flags Align LOAD 0x0000000000000000 0x0000000000400000 0x0000000000400000 0x00000000000000b0 0x00000000000000b0 R 0x1000 LOAD 0x0000000000001000 0x0000000000401000 0x0000000000401000 0x000000000000004a 0x000000000000004a R E 0x1000 对于动态链接来说，地址空间又复杂了一些。 这时.so动态链接库也被放入内存中，但是出现了啥都没有的地址空间映像，这是什么？ 是不是bss？\n这时jyy做了一个实验.\n1 2 3 char big[1\u0026lt;\u0026lt;30]={0}; int main(){ } 看看这么大的数组究竟在哪?\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 (gdb) info inferiors Num Description Executable * 1 process 25796 /home/charon/jyy/12/a.out (gdb) !pmap 25796 25796: /home/charon/jyy/12/a.out 0000555555554000 4K r---- a.out 0000555555555000 4K r-x-- a.out 0000555555556000 4K r---- a.out 0000555555557000 8K rw--- a.out 0000555555559000 1048576K rw--- [ anon ] 00007ffff7fca000 16K r---- [ anon ] 00007ffff7fce000 4K r-x-- [ anon ] 00007ffff7fcf000 4K r---- ld-2.31.so 00007ffff7fd0000 140K r-x-- ld-2.31.so 00007ffff7ff3000 32K r---- ld-2.31.so 00007ffff7ffc000 8K rw--- ld-2.31.so 00007ffff7ffe000 4K rw--- [ anon ] 00007ffffffde000 132K rw--- [ stack ] total 1048936K 确实在堆区heap\n启动之后甚至吃了我1g的内存\n1 2 3 $htop PID VIRT Command 25805 1024M /home/charon/jyy/12/a.out vdso 既想执行系统调用，又不想通过syscall进入内核执行\ntime 跳转到0x7ffff7fce730\n在内存中的vdso段， 再把rip减掉-0x469，进入vvar。 而且这个内存gdb无法访问。 查看rax的值，发现就是unix时间秒数，说明这个0x7fffff7fca0a0中存的是操作系统的秒数\n1 ┌─────────────────────────────────────────────────────────────────────────────────────────────┐│ \u0026gt;0x7ffff7fce730 \u0026lt;time\u0026gt; test %rdi,%rdi ││ 0x7ffff7fce733 \u0026lt;time+3\u0026gt; mov -0x469a(%rip),%rax # 0x7ffff7fca0a0 ││ 0x7ffff7fce73a \u0026lt;time+10\u0026gt; je 0x7ffff7fce73f \u0026lt;time+15\u0026gt; ││ 0x7ffff7fce73c \u0026lt;time+12\u0026gt; mov %rax,(%rdi) vvar是什么？由操作系统维护的一个秒数。\n与其费劲心力一定要通过陷入内核的方式来读取这些数据，不如在内核与用户态之间建立一段共享内存区域，由内核定期“推送”最新的值到该共享内存区域，然后由用户态程序在调用这些glibc库函数的时候，库函数并不真正执行系统调用。\n那么能不能让其他系统调用也 trap 进入内核？\n疯狂的事情也许真的是能实现的 (这算是魔法吗？) FlexSC: Flexible system call scheduling with exception-less system calls (OSDI'10). https://www.usenix.org/conference/osdi10/flexsc-flexible-system-call-scheduling-exception-less-system-calls\n使用共享内存和内核通信！\nmap是动态变化的。 动态链接库在开始阶段并没有加载到地址空间。\nmmap map or unmap files or devices into memory\n在状态上增改一段可访问的内存。\n1 2 3 4 5 6 7 8 // 映射 void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset); int munmap(void *addr, size_t length); // 修改映射权限 int mprotect(void *addr, size_t length, int prot); 把文件映射到进程的地址空间\n这个mmap特别有用，再此基础上实现加载器就非常容易。\nelf文件会告诉你把什么段加载到哪里Program Headers\nmmap会把内存标记为已分配，等到缺页的时候再说。 所以mmap申请大量内存空间几乎是瞬间完成的。\n地址空间的隔离 每个ptr只能访问本进程的内存\n剩下的40分钟都是jyy介绍上一个时代的游戏\n红警、金山游侠、\n如何制造外挂？\n动态修改一个运行中的程序（热更新）\n","date":"2022-08-30T16:09:19+08:00","permalink":"https://junling.li/posts/os-jyy-12/","section":"posts","tags":null,"title":"操作系统-jyy-12"},{"categories":null,"contents":"今天有人放着Premium Pro不用，执意要使用ffmpeg剪视频，这种症状一看就是被Fabrice Bellard冲昏了头脑，先是qemu然后就入坑了ffmpeg。\n因为自己的需求比较简单，不需要精确贴图的位置，不需要调色，就是简简单单的cut和加字幕，这就很好符合了大道至简思想，也只需要两段代码就能实现剪辑工作。\n安装 我是用的是winget包管理安装，只需要winget install ffmpeg然后直接YYYY。这样不用配置环境变量啥的。\n当然之前是使用wsl2上的apt包管理安装的，sudo apt install ffmpeg可能还需要一些依赖。\n怎么cut 剪辑，顾名思义，就是剪出一个视频片段，\nffmpeg -i todo.flv -ss 02:03:24 -to 02:07:41 output.flv\n这里使用-i指定待剪辑的文件，-ss指明片段的起始时间02:03:24就是2小时3分钟24秒了\n-to指明片段的结尾，02:07:41就是2小时7分钟41秒了，可见输出的视频应该是4分17秒的片段。最后的output.flv写在最后，表示输出的文件名。\n怎么加字幕 首先，我们可以使用一些工具获得srt字幕文件。当然你也可以手打\n1 2 3 4 5 6 7 8 9 10 11 1 00:00:10,430 --\u0026gt; 00:00:12,220 哪里有彩虹告诉我 2 00:00:13,690 --\u0026gt; 00:00:17,320 能不能把我的愿望还给我 3 00:00:19,320 --\u0026gt; 00:00:23,550 为什么天这么安静 接下来重要的参数就是字幕样式了。 srt字幕需要使用subtitles滤镜， ，通过force_style设置样式，比如字体，颜色，字幕边框，以及位置。 PrimaryColour为字幕颜色，\n注意它使用的不是我们常见的RGB颜色，而是BGR，你可以理解成RGB的B和R调换了顺序。比如你想要#74a9b4，这里就变成了b4a974，有点奇怪但是这点转换人脑就可以做到\noutlineColour就是边框颜色。\n1 2 3 ffmpeg -i output.flv -vf \u0026#34;subtitles=output.srt:force_style=\u0026#39;fontname=MicrosoftYaHeiUI, FontSize=30,PrimaryColour=\u0026amp;H00b4a974, outlineColour=\u0026amp;Hffffff,outline=1\u0026#39;\u0026#34; -c:v libx264 output-srt-color-white-2.flv 这就完成了我们的全部需求了。\n","date":"2022-08-22T22:00:12+08:00","permalink":"https://junling.li/posts/ffmpeg/","section":"posts","tags":null,"title":"ffmpeg"},{"categories":null,"contents":"今天出结果了，只能说尽力了，没获得国一还是有点遗憾的。\n从去年12月开始准备，到6月提交初赛，8月决赛，每周一次组会。半年也很快的。\n初次线下见面应该是12月底，在宾诺咖啡见到了各位\n我们在Tencent的coding平台做版本管理。使用的是private的仓库，只有团队成员才能看到。不用GitHub的原因当然是网不好。\n现在已经放到GitHub上了 Another-me\ngit 除了merge的时候过于难受，其他时候做分支管理挺舒适的。\n我们究竟做了一个什么东东？\n简单说，是一个浏览器app，在使用此app查询当地天气时，会有js获取位置信息发送出去，这样可能造成你的位置隐私出现泄露。我们的浏览器会根据你的轨迹信息，映射到新的城市，在发送真实位置信息的同时，发送一串假位置。\n这时候就有人要来杠了，谁用浏览器查天气啊，不都是用系统自带的天气应用。确实，咱们的系统也考虑过对系统层面的位置信息做替换，比如乐健打卡、钉钉假签到类似的，但是看到虚拟位置的app被打击入刑。所以头到尾也没想过做应用内的信息修改。\n2021 年 10 月 8 日，北京市海淀区人民法院披露了一起破坏计算机信息系统罪的案件，犯罪人被判处有期徒刑 5 年 6 个月。该软件是一款名叫“大牛助手”的 APP，其通过虚拟定位技术，将虚假的位置传送至钉钉系统，以达到“打卡”的效果，主要供上班族和学生使用。该软件为收费软件，年费为 89 元，月费 25 元。截止案发，用户近10万余人/次，收取费用四五百万元。犯罪人已于 2019 年 5 月 31 日被羁押，同年 7 月 4 日被逮捕。\nhttps://www.zhihu.com/question/491806902/answer/2168531030\n所以我们做的东东的应用范围很狭窄，只能通过浏览器层面做处理。什么点外卖，定酒店就别想了。现在这个\n那又有人要问了，简单替换也没啥技术含量啊，随便用一个城市替代轻而易举啊。\n确实，大概在1月初的时候，简单的位置替换的demo就做好了。\n那我们多做了哪些工作呢？又比别人前进了多少呢？\n相关工作 基于空间隐匿的位置隐私保护方案\nCheng 等人[1] 提出了在攻击者知道目标用户的伪装区域和最大速度时降低攻击影响的修补和 延迟方法。Chow 等人[2]提出了一种基于组的方法, 即隐匿区域必须始终覆盖连 续发送查询的组成员, 这可以抵抗位置相关的攻击。Xu 等人[18]将众多用户的历 史轨迹信息引入到隐匿区域的计算过程中, 从而实现更小的隐匿区域, 提高服务 质量。Lin 等人[19]提出了一种补救解决方案, 将所有真实位置转换为一个新域, 从而完全防止准确和连续位置的泄漏。 基于空间隐匿的位置隐私保护方法大多依赖于可信第三方, 并且需包含具 有相同职责的位置匿名器。此外, 此类方案多将用户的位置泛化为一个区域, 基 第 5 页 共 94 页 于位置服务的隐私级别取决于伪装区域的大小, 这在一定程度上会降低服务质 量。\n首先是\n所以最终我们不是做了一个应用狭窄的APP，而是实现了一个位置映射的完整解决方案，但是受限于不能对系统内部的位置信息做修改，导致我们的应用范围比较窄。\n算法 文档 文档部分算是一个大难题吧，初赛的化评委老师重点还是看文档的，所以从5月开始，咱们就很少加新功能了，开发按上了暂停键。\n作为一个很少写文档的程序员，对于如何讲清楚一个功能是如何实现的很简单，但是结果就是别人看不懂，给评委老师加密通话，这一点是大忌。\n所以改文档前前后后开了不少组会。\n除了纠结每个功能点的实现，还究竟各个模块之间是如何耦合的。\n记得很清楚的一点就是，有一个模块叫做http请求模块，实际上就是对okhttp3做了一个简单的封装。但我们很纠结究竟是放在核心模块里说，贯穿整个系统，还是作为一个单独的模块拿出来讲。当时真的是吵了一个下午。\n其实很慌文档写不完，提交的时候正好是期末周，当时改了有10几个版本，\n测试 测功耗，属于体力活了，端午节的三天，每天都拿着3台手机，测试静置功耗和apk的功耗。作为常年混迹酷安等论坛的机友，私认为测功耗是一件很难的事，它受到电池寿命，基带功耗，屏幕亮度方方面的影响，如何保证对照实验的准确性。\n测位置混淆是否准确，这一点让黄同学做的。总共用了K最近邻分类算法，高斯过程回归算法测试和神经网络来看究竟是否是假位置。\n具体操作：手动点重复\n决赛 当初还想去长沙喝茶颜悦色，但是疫情嘛，一切都线上了。\n[1]Cheng R, Zhang Y, Bertino E, et al. Preserving user location privacy in mobile data management infrastructures[C]//International Workshop on Privacy Enhancing Technologies. Springer, Berlin, Heidelberg, 2006: 393-412.\n[2]Chow C Y, Mokbel M F. Enabling private continuous queries for revealed user locations[C]//International Symposium on Spatial and Temporal Databases. Springer, Berlin, Heidelberg, 2007: 258-275.\n","date":"2022-08-22T16:00:12+08:00","permalink":"https://junling.li/posts/contest-ciscn/","section":"posts","tags":null,"title":"信息安全大赛"},{"categories":null,"contents":"今天心血来潮注册了junling.li\n?? copilot 已经如此智能了吗？\n整个过程很顺利，首先是尝试了一家 瑞士的注册商叫 metanet，我嫌他太慢了，而且没有能付chz的卡。冲浪时看到 https://jun.li/tech/202.html 下面的评论，发现 https://gandi.net 可以注册，而且可以支付宝，有中文页面，遂付了98大洋注册。\n之后改一下默认dns到dnspod.cn,\n?? 过于智能了\n就遇到了当初一样的备案问题，先不说备案的要花时间和精力，.li.能不能备案都是一个问题，所以想到了\n?? 看来copilot提供的解决方案简单粗暴。 事实上我想用 vercel 加速 Github pages，这样\n??听君一席话?? 这样就直接把 junling.li cname到 vercel给的域名或者a记录到vercel服务器ip，就跳过了备案。\nvercel的操作远远比我想的要简单，添加github仓库 自动选择hugo，点击部署 设置a记录，结束！\n整个过程不超过5分钟\n至此，Blog 已经“一键”搬到 junling.li了，还免去了配置ssl证书\n在junling.xyz过期以后，咱也能通过 junling.li在找到我了。\n历史：\n本文最初选择的metanet.ch的.ch是瑞士的顶级域名，ch是取自这个瑞士的拉丁文名字Confoederatio Helvetica (Helvetic (Swiss)Confederation)（所有瑞士的硬币上都标有这个名字）。瑞士使用最广泛的语言是德语，所以metanet.ch发我的邮件都是德语，hhh。瑞士3w平方千米，人口约870w，东南是阿尔卑斯山脉，铁路里程5000km，有世界上最长的隧道。为什么突然介绍瑞士呢，因为马前卒今天恰巧说到了瑞士。\n.li是列支敦士登的顶级域名，这个小国在瑞士旁边，只有160.5平方公里，人口3w，是澳门的1/10，人口不及中国一个镇。按理说不值得我关心，但还是挺有意思的： 2011年，列支敦士登决定将允许出租整个国家，每晚租金是4万英镑（约42.5万人民币）。该国的临时“拥有者”会在议会仪式上得到一把象征性的钥匙，然后就可以使用土地，甚至调用当地警察。\n盘点历史买过的域名 uest.xyz 2021-3-15 godaddy\nlijunling.xyz 2019-08-25 阿里云\nbestboyofuestc.xyz 2019-08-24 阿里云（万网\nIAMAPPALLED.TODAY 2017-8-17 godaddy\n","date":"2022-08-09T16:00:12+08:00","permalink":"https://junling.li/posts/junling-li/","section":"posts","tags":null,"title":"junling.li"},{"categories":null,"contents":"qemu入门\nQEMU QEMU是一款开源的模拟处理器，由Fabrice Bellard打造，接触他的原因是想用Loongarch，但是市面上龙芯的版U可以说想到少，又不向个人买家出售，咱想支持国产也没办法。\n但是别急，Qemu在7.0rc0支持了loongarch，就是说我们可以轻松在x86上模拟loongarch了\n下载源代码并编译\n1 2 3 4 mkdir build cd build ../configure make 编译QEMU 编译中会出现一些问题\nconfigure\n缺少ninja:apt install ninja-build\n中间可能会遇到各种报错，此处引用大佬的博客（提及的问题我大部分都遇到了）：\n问题1： 出现：ERROR: Python not found. Use --python=/path/to/python 解决：添加--python=python3，还是不行提示Note that Python 3 or later is not yet supported。安装python2.7，然后使用--python=python2.7选项。 问题2： 出现：ERROR: pkg-config binary 'pkg-config' not found 解决：执行apt-get install -y pkg-config 问题3： 出现：ERROR: zlib check failed. Make sure to have the zlib libs and headers installed. 解决：执行sudo apt-get install zlib1g-dev 问题4： 出现：ERROR: glib-2.12 gthread-2.0 is required to compile QEMU 解决：sudo apt-get install libglib2.0-dev 问题5： 出现：ERROR: pixman \u0026gt;= 0.21.8 not present. 解决：sudo apt-get install libpixman-1-dev 问题6： 出现：vl.c: In function ‘main’: vl.c:2778:5: error: ‘g_mem_set_vtable’ is deprecated [-Werror=deprecated-declarations] g_mem_set_vtable(\u0026amp;mem_trace); ^ In file included from /usr/include/glib-2.0/glib/glist.h:32:0, from /usr/include/glib-2.0/glib/ghash.h:33, from /usr/include/glib-2.0/glib.h:50, from vl.c:59: /usr/include/glib-2.0/glib/gmem.h:357:7: note: declared here void g_mem_set_vtable (GMemVTable *vtable); ^ cc1: all warnings being treated as errors rules.mak:57: recipe for target 'vl.o' fai·led make: *** [vl.o] Error 1 解决：QEMU源码根目录下的Makefile文件最后加上一行 QEMU_CFLAGS+=-w优化 如果遇到undefined reference to 'major'，在报错的源文件中添加#include \u0026lt;sys/sysmacros.h\u0026gt;\n模拟loongarch 下面是大佬的启动脚本，但是它没有给出源文件\n1 2 3 4 5 6 7 8 9 qemu-system-loongarch64 \\ -nographic \\ -serial mon:stdio \\ -m 1024 \\ -kernel vmlinuz \\ -initrd build/initramfs.cpio.gz \\ -append \u0026#34;console=ttyS0 quiet acpi=off\u0026#34; BOOTROM=0x110000000 SIMPLEVGA=800x600-16:0x0e800000 ./qemu-system-loongarch64 -M ls2k -bios ./gzrom.bin -kernel ./vmlinuz -serial stdio -m 4096 -s -monitor tcp::1235,server,nowait -netdev user,id=n1,net=10.20.41.0/24,host=10.20.41.50,tftp=/srv/tftp/ -device pci-synopgmac,netdev=n1 -usb -smp 1 于是我又混迹龙芯bbs，找到一个构建的archlinux启动镜像。 https://mirrors.wsyu.edu.cn/loongarch/2022.03/iso/2022.06/loongarchlinux-2022.06.22.1-loongarch64.iso\n1 ./qemu-system-loongarch64 -cdrom ~/loongarchlinux-2022.06.22.1-loongarch64.iso -device qemu-xhci,id=xhci -device qemu-xhci,id=verylongson -device usb-kbd,bus=xhci.0 -device usb-mouse,bus=verylongson.0 -vnc :0 -m 1g -vga virtio -boot a -bios ~/QEMU_EFI.fd 接下来就是见证奇迹的时刻\nqemu使用指南 info register 查看寄存器\nctrl+a c从跳出模拟机的tty到qemu控制台\n","date":"2022-07-28T14:05:38+08:00","permalink":"https://junling.li/posts/qemu/","section":"posts","tags":null,"title":"Qemu"},{"categories":null,"contents":"今天开始整理一下大学的一些项目\n首先看的是一个俄罗斯方块的实现，这应该是我大学以来的第一个项目\n那个时候，我c语言还是刚入门，还没写明白if-else，还不知道什么是编译，什么是链接，却能借助visual studio通过简单的点点操作，基于翁恺的acllib库跑一个图形程序，我自己都佩服我自己。\n现在知道了汇编，操作系统，回来 再看看这个实验。\n很久很久以前，在一个遥远的银河系，有一个小男孩，它写的俄罗斯方块的所有源代码，都写在一个文件里。\n源.cpp-\u0026gt;src.cpp\n一眼钉真，鉴定visual studio已经过时，作为GNU社区的忠实拥护者，怎么能使用msvc这种编译器。\n编译！\n1 2 3 4 5 gcc src.cpp c:/mingw/bin/../lib/gcc/mingw32/9.2.0/../../../../mingw32/bin/ld.exe: C:\\Users\\Charon\\AppData\\Local\\Temp\\ccxKdSbR.o:acllib.c:(.text+0x1b74): undefined reference to `__mingw_free\u0026#39; c:/mingw/bin/../lib/gcc/mingw32/9.2.0/../../../../mingw32/bin/ld.exe: C:\\Users\\Charon\\AppData\\Local\\Temp\\ccxKdSbR.o:acllib.c:(.text+0x1be8): undefined reference to `mciSendStringA@16\u0026#39; c:/mingw/bin/../lib/gcc/mingw32/9.2.0/../../../../mingw32/bin/ld.exe: C:\\Users\\Charon\\AppData\\Local\\Temp\\ccxKdSbR.o:acllib.c:(.text+0x1c31): undefined reference to `mciSendStringA@16\u0026#39; collect2.exe: error: ld returned 1 exit status 一长串报错，当时的我一定会看懵了，这啥啊。但是现在的我不一样了，一眼鉴定是链接器的问题，acllib.c里的mciSendString()函数原型没找到，也就是编译以后，有一个call mciSendString ()函数，跳转到未知地址。链接器这时候就懵了，这啥啊，没见过啊，给他链接啥地址啊，然后就报错了。\n解决也很简单，-l把他找到函数原型就好了。那问题来了，在哪？\n搜索引擎，启动！\n有人告诉我devcpp使用acllib库应该这样用\n1，新建项目—\u0026gt;Windows application—\u0026gt;C项目–\u0026gt;输入项目名称 2，将acllib.c和acllib.h文件拷贝到创建的项目目录 3，菜单栏–\u0026gt;项目–\u0026gt;项目属性–\u0026gt;参数–\u0026gt;链接–\u0026gt;加入库文件，如下：（Dev C++具体目录以安装时为准）\n32位下，库文件是： “C:/Program Files/Dev-Cpp/MinGW32/lib/libwinmm.a”\n“C:/Program Files/Dev-Cpp/MinGW32/lib/libmsimg32.a”\n“C:/Program Files/Dev-Cpp/MinGW32/lib/libkernel32.a”\n“C:/Program Files/Dev-Cpp/MinGW32/lib/libuser32.a”\n“C:/Program Files/Dev-Cpp/MinGW32/lib/libgdi32.a”\n“C:/Program Files/Dev-Cpp/MinGW32/lib/libole32.a”\n“C:/Program Files/Dev-Cpp/MinGW32/lib/liboleaut32.a”\n“C:/Program Files/Dev-Cpp/MinGW32/lib/libuuid.a”\n64位下，库文件是： C:/Program Files/Dev-Cpp/MinGW64/x86_64-w64-mingw32/lib/libwinmm.a\nC:/Program Files/Dev-Cpp/MinGW64/x86_64-w64-mingw32/lib/libmsimg32.a\nC:/Program Files/Dev-Cpp/MinGW64/x86_64-w64-mingw32/lib/libkernel32.a\nC:/Program Files/Dev-Cpp/MinGW64/x86_64-w64-mingw32/lib/libuser32.a\nC:/Program Files/Dev-Cpp/MinGW64/x86_64-w64-mingw32/lib/libgdi32.a\nC:/Program Files/Dev-Cpp/MinGW64/x86_64-w64-mingw32/lib/libole32.a\nC:/Program Files/Dev-Cpp/MinGW64/x86_64-w64-mingw32/lib/liboleaut32.a\nC:/Program Files/Dev-Cpp/MinGW64/x86_64-w64-mingw32/lib/libuuid.a\n如果出现“undefined reference to TransparentBlt ”这个错误，两个解决方案： 打开acllib.c，找到“TransparentBlt”所在的行，把整行注释掉； 打开工程配置，找到编译器选项，加入-DWINVER=0x0500。 ———————————————— 版权声明：本文为CSDN博主「sandonz」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。 原文链接：https://blog.csdn.net/sandonz/article/details/118385519\n虽然很奇怪，为什么gcc不能给我自动引用呢？\n1 gcc acllib.c src.cpp -lwinmm -DWINVER=0x0501 -o src 尝试使用devcpp\n按照上述方法配置，手动添加LIBS\n偷看makefile.win\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 # Project: Project2 # Makefile created by Dev-C++ 5.5.3 CPP = g++.exe CC = gcc.exe WINDRES = windres.exe OBJ = acllib.o main.o LINKOBJ = acllib.o main.o LIBS = -L\u0026#34;C:/Program Files (x86)/Dev-Cpp/MinGW32/lib\u0026#34; .... BIN = Project2.exe CXXFLAGS = $(CXXINCS) -g3 -DWINVER=0x0500 CFLAGS = $(INCS) -g3 RM = rm -f .PHONY: all all-before all-after clean clean-custom all: all-before $(BIN) all-after clean: clean-custom ${RM} $(OBJ) $(BIN) $(BIN): $(OBJ) $(CC) $(LINKOBJ) -o $(BIN) $(LIBS) acllib.o: acllib.c $(CC) -c acllib.c -o acllib.o $(CFLAGS) main.o: main.cpp $(CC) -c main.cpp -o main.o $(CFLAGS) 还是报错，就跟没引入lib一样\n尝试clion打开，\n在函数名上按下ctrl，函数原型在C:\\MinGW\\include\\mmsystem.h里面，那么动态链接库在lib里为啥不给我链上？\n看了一波了cmakelist\n1 2 3 4 5 6 cmake_minimum_required(VERSION 3.20) project(RU) set(CMAKE_CXX_STANDARD 14) set(CMAKE_CXX_FLAGS \u0026#34;-DWINVER=0x0500\u0026#34;) add_executable(RU src.cpp acllib.c) 还是报错\n1 2 3 4 5 6 C:/Users/Charon/Desktop/code/RU/acllib.c:816: undefined reference to `mciSendStringA@16\u0026#39; c:/mingw/bin/../lib/gcc/mingw32/9.2.0/../../../../mingw32/bin/ld.exe: CMakeFiles\\RU.dir/objects.a(acllib.c.obj): in function `playSound\u0026#39;: C:/Users/Charon/Desktop/code/RU/acllib.c:828: undefined reference to `mciSendStringA@16\u0026#39; c:/mingw/bin/../lib/gcc/mingw32/9.2.0/../../../../mingw32/bin/ld.exe: CMakeFiles\\RU.dir/objects.a(acllib.c.obj): in function `stopSound\u0026#39;: C:/Users/Charon/Desktop/code/RU/acllib.c:835: undefined reference to `mciSendStringA@16\u0026#39; collect2.exe: error: ld returned 1 exit status 最后的最后:\n突然看到翁老师acllib的git repo好像有sample，那例子能不能运行呢？\n我直接一个clone，一个make，好家伙，给的例子研究一下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 SRC = ..\\..\\src\\acllib.c INCLUDE_DIR = ..\\..\\src LIB = gdi32 ole32 oleaut32 uuid winmm msimg32 all : keyboard mouse_move mouse_click image clock char src keyboard : gcc $(SRC) $@.c -I$(INCLUDE_DIR) $(LIB:%=-l%) -DWINVER=0x0501 -o $@ mouse_move : gcc $(SRC) $@.c -I$(INCLUDE_DIR) $(LIB:%=-l%) -DWINVER=0x0501 -o $@ mouse_click : gcc $(SRC) $@.c -I$(INCLUDE_DIR) $(LIB:%=-l%) -DWINVER=0x0501 -o $@ image : gcc $(SRC) $@.c -I$(INCLUDE_DIR) $(LIB:%=-l%) -DWINVER=0x0501 -o $@ clock : gcc $(SRC) $@.c -I$(INCLUDE_DIR) $(LIB:%=-l%) -DWINVER=0x0501 -o $@ char : gcc $(SRC) $@.c -I$(INCLUDE_DIR) $(LIB:%=-l%) -DWINVER=0x0501 -o $@ 好像这么一瞬间，我已经完全懂了，我就看懂了makefile，多么简单明了，比cmakelist.txt好读多了。\n1 2 $mingw32-make -nB gcc acllib.c src.cpp -lgdi32 -lole32 -loleaut32 -luuid -lwinmm -lmsimg32 -DWINVER=0x0501 -o src 其实和刚开始的差不多，感谢makefile，\n复盘了一下，看到devcpp添加lib是多余的，只要在参数加-lgdi32 -lole32 -loleaut32 -luuid -lwinmm -lmsimg32才是关键，我之前只加了-lwinmm所以还是报错\n搞定！\n虽然很简单的一个项目，和b站小学生写操作系统没法比\n还是说明一下啊\n根据以上流程图和游戏操作，本阶段的介绍分三个部分：\n1） 基本图形的存储与绘制\n2） 下落定时与键盘控制\n3） 图形界面和音效设计\n下面将就这三个方面做分别说明\n1） 基本图形的存储与绘制\n俄罗斯方块有5类19种不同的图形，分别为1字形（2种），Z字形（4种），T字形（4种），L字形（8种），田字形（1种），每类之间可以通过旋转对称得到，每次生成图形时要使用这19种图形来绘制。本游戏使用一个三维数组Graphics[19][4][4]来存储该图形，19对应编号，两个4对应4*4矩阵。0代表空，1代表黑块。\n例如\n对应\n0 0 0 0\n0 1 0 0\n0 1 0 0\n1 1 0 0\n绘图时，使用循环语句遍历4*4数组，当值为1时，在适当位置（下文会详细说明这个适当位置）绘制正方形，这里使用ACLLIB库中提供的rectangle命令绘制矩形。\n所有图形保存在TXT文件中，可以通过改变TXT文件中的值获得任何你想要的形状，每次运行时使用文件操作读取所有的19种图形。对于已经下落的图形，使用二维数组allPixel[30][15]存储像素点，如图所示建立坐标系：\n30对应y轴，15对应x轴\n数组值为1对应黑块，值为0对应空。初始值全为0。绘图时，遍历allPixel数组，遇到1时使用ACLLIB库中提供的rectangle命令在相应位置绘制矩形。\n2）下落定时与键盘控制\n**下落定时：**考虑到俄罗斯方块匀速下落，本游戏使用ACLLIB库提供的定时器来控制下落，用整型变量x，y记录每一个下落的方块的位置，初始位置为上方正中，4*4矩形左上方点在整个坐标系的位置，每隔300ms，刷新一次界面（清屏并对已存在的和正在下落的方块进行重绘）\n每次下落（达到300ms）将y的加1，并且对下方进行预判断，如果方块下方存在障碍或者达到最底行，停止移动并将该方块的值写入allPixel中。\n**键盘控制：**每次按下按键时，触发keyEvent事件，对应改变bool变量的值。本游戏设计5个有交互的键。\n左右键：先对移动后的图形是否遇到障碍进行预判断，如果遇到边界或者碰到已经存在的方块，则不移动，否则移动（变更x的值）。\n上键：则改变俄罗斯方块的形状（在同一类中改变，比如L形变成倒L），这里使用随机数决定下一个图形是什么形状，注意这里也需要判断是否变形后遇到障碍，如果有，则不变形。\n下键：加速，改变计时器为50ms，刷新时间缩短到50ms，下落速度达到原来的6倍。\n空格键：长按暂停游戏；\n松开空格键继续。\n3）图形界面和音效设计\n本游戏操作界面如下：\n左侧框中为正在下落的方块和已经下落的方块，右侧为计分和提示文字\n计分和等级功能：每下降一个方块加1分，每消去一行方块升1级。并播放升级音效。如果方块堆积到达顶部，则显示游戏结束。\n核心算法的详细设计与实现 下面列举本游戏的核心算法：\n**判断障碍算法：**在每次左右移动时，需要判断是否遇到障碍，拿右移的代码举例，该判断算法的步骤如下：\n当收到键盘请求isToRight==true后，首先设置布尔变量isReach值为false，对下落的方块的4*4矩阵进行遍历，如果某一位置为1，进行下一步判断：移动后的位置是否超出右侧边界？移动后的位置是否有已知方块？\n只要有一个回答是，则说明有障碍，无法移动，标记isReach为true，结束循环。当遍历结束后isReach仍然为false，即中间一次没有被标记，则说明右移后没有障碍，可以放心移动，令位置变量x加1。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 void isMoveRight() { if (isToRight) { isToRight = false; isReach = false; for (int i = 0; i \u0026lt; 4; i++) for (int j = 0; j \u0026lt; 4; j++) { if (Graphic[num][i][j]) { if ( j+1+x \u0026gt;= Width || allPixel[y + i][x + 1 + j]) { isReach = true; break; } } } if (!isReach) x++; } } 绘制正在下落的俄罗斯方块图形：\n绘制俄罗斯方块图像是本游戏的基础，需要正在下落的坐标参数x,y和图形序号参数num（初始num由随机数确定），对确定序号num的三维数组Graphic进行遍历，若(0,1)处值为1，x=3,y=4则将该点绘制到整个窗口的(20+4 * pixelWidth, 4* pixelWidth)位置，为了让整个窗口居中的统一在x轴增加了20。代码如下\n1 2 3 4 5 6 7 for (int i = 0; i \u0026lt; 4; i++) { for (int j = 0; j \u0026lt; 4; j++) { if (Graphic[num][i][j]) { rectangle(20+(j + x) * pixelWidth, (i + y) * pixelWidth, 20+(j + 1 + x) * pixelWidth, (i + 1 + y) * pixelWidth); } } } 绘制已经存在的像素点与此大同小异。\n判断某一行是否填满方块：\n对allPixel每一行的值进行遍历，如果某一行全为0，即为满格，此时播放音效并升级，再将上面多行的各值向下平移一行，这里代码较为简单，不再贴出。\n","date":"2022-07-28T00:55:59+08:00","permalink":"https://junling.li/posts/cpp-acllib/","section":"posts","tags":null,"title":"Cpp Acllib"},{"categories":null,"contents":"真实世界的并发编程\n(高性能计算/数据中心/人机交互中的并发编程) 之前跳过了两节，之后补。\n本节课回答的问题：什么样的任务是需要并发、并行的？它们改如何实现\n本次内容：\n高性能计算中的并发编程 数据中心里的并发编程 我们身边的并发编程 高性能计算中的并发编程 先河：CRAY-1 supercomputer 1976 138MFLOPS\n46岁，是超算。\n应用于如下领域\n系统模拟：天气预报、分子生物学\n人工智能\n挖矿，hash。\n主要挑战 计算任务如何分解 比如一个dp最长子序列，就很难分解，拓扑排序。\nmpi\n线程之间如何通信 不仅是节点、线程之间，还发生在共享内存访问\n例子 Mandelbrot Set 注意，这个例子会用shell执行viu，这是一个将图片用unicode打印到终端的工具（想到了命令行浏览器browsh），请先pamac install viu\ngcc mandelbrot.c -lpthread -lm -O2 \u0026amp;\u0026amp; ./a.out 1\nargv=1 2 4 8线程数\n还是有点炫的\n截图\nconvert mandelbrot.ppm a.jpg\nppm这种rgb数字构成的图片格式\n数据中心的并行编程 与超算的区别点在于数据和存储\n支撑互联网应用，导致现代人获取知识的门槛降低，效率升高；如何抗住高并发\n主要挑战 多副本情况下的高可靠、低延迟数据访问\n多副本的数据一致性 Consistency\n对用户高可用，立即生效 Available\n容忍机器离线 Partition tolerance\n虽然本课程的主要内容是如何管理一台计算机，但这里和数据中心不矛盾\n一个尽可能相应多地服务的并行请求\n切换线程是有代价的\n一个有趣的小实验\nco_yield 函数调用\nGo 协程coroutines\n多个执行流 切换代价小，协程里的切换不受操作系统调度 线程的一般执行模型 read() syscall() write()，可以多处理器并行；但是需要占有较多的资源\n协程 遇到read()会阻塞线程，其他协程就无法执行\nGo和Goroutine 多处理器并行和协程全都要\n每个cpu上绑定一个线程 go work，每个线程有多个协程。\n任何一个协程IO时，用不block的系统调用read_nonblock，读取时会跳到另一个协程执行。这么巧妙的设计甚至不需要切换cpu，所以可以创建百万级的goroutine。\nfib.go 轮番打印字符 ，实现了一个进度条\n为什么进度条在算出fib后终止了？\n因为运行的协程spinner在主协程main终止后就终止了\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; ) func main() { go spinner(100 * time.Millisecond) //创建go ruutine 概念是线程实现是协程 const n = 45 fibN := fib(n) // slow fmt.Printf(\u0026#34;\\rFibonacci(%d) = %d\\n\u0026#34;, n, fibN) } func spinner(delay time.Duration) {//轮番打印字符 ，实现了一个进度条 for { for _, r := range `-\\|/` { fmt.Printf(\u0026#34;\\r%c\u0026#34;, r)//回到行首 time.Sleep(delay) } } } func fib(x int) int { if x \u0026lt; 2 { return x } return fib(x - 1) + fib(x - 2) } 操作系统上讲的并发算法，不意味着在真正写代码时用这些并发算法，因为接近底层的锁太难写了，我们写不对。\n共享内存在奇怪调度发生各种bugs，我们把握不住。\n如果生产者-消费者能解决大部分问题，那操作系统提供一个API给我们调用更好。\nchannel go协程之间通信的机制 stream \u0026lt;- i把i丢进channel\nx:=\u0026lt;- stream 从channel拉出\n通过别人为我们提供的模型，我们能轻易写出生产者-消费者模型的代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 package main import \u0026#34;fmt\u0026#34; var stream = make(chan int, 10) const n = 4 func produce() { for i := 0; ; i++ { fmt.Println(\u0026#34;produce\u0026#34;, i) stream \u0026lt;- i } } func consume() { for { x := \u0026lt;- stream fmt.Println(\u0026#34;consume\u0026#34;, x) } } func main() { for i := 0; i \u0026lt; n; i++ { go produce() } consume() } 我们身边的并发编程 Web交互式的年代 web2.0\n浏览器中的并发编程 asynchronous js+xml (ajax)\nHTML(DOM Tree)+CSS\n通过js改变html 通过js建立连接本地和服务器 扩展阅读 标准I/O函数库提供了popen函数，它启动另外一个进程去执行一个shell命令行。\n这里我们称调用popen的进程为父进程，由popen启动的进程称为子进程。\npopen函数还**创建一个管道用于父子进程间通信。**父进程要么从管道读信息，要么向管道写信息，至于是读还是写取决于父进程调用popen时传递的参数。下在给出popen、pclose的定义：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include \u0026lt;stdio.h\u0026gt; /* 函数功能：popen（）会调用fork（）产生子进程，然后从子进程中调用/bin/sh -c来执行参数command的指令。 参数type可使用“r”代表读取，“w”代表写入。 依照此type值，popen（）会建立管道连到子进程的标准输出设备或标准输入设备，然后返回一个文件指针。 随后进程便可利用此文件指针来读取子进程的输出设备或是写入到子进程的标准输入设备中 返回值：若成功则返回文件指针，否则返回NULL，错误原因存于errno中 */ FILE * popen( const char * command,const char * type); /* 函数功能：pclose（）用来关闭由popen所建立的管道及文件指针。参数stream为先前由popen（）所返回的文件指针 返回值：若成功返回shell的终止状态(也即子进程的终止状态)，若出错返回-1，错误原因存于errno中 */ int pclose(FILE * stream); 下面通过例子看下popen的使用：\n假如我们想取得当前目录下的文件个数，在shell下我们可以使用：\n1 1\tls | wc -l 我们可以在程序中这样写：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 /*取得当前目录下的文件个数*/ #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;errno.h\u0026gt; #include \u0026lt;sys/wait.h\u0026gt; #define MAXLINE 1024 int main() { char result_buf[MAXLINE], command[MAXLINE]; int rc = 0; // 用于接收命令返回值 FILE *fp;\t/*将要执行的命令写入buf*/ snprintf(command, sizeof(command), \u0026#34;ls ./ | wc -l\u0026#34;); /*执行预先设定的命令，并读出该命令的标准输出*/ fp = popen(command, \u0026#34;r\u0026#34;); if(NULL == fp) { perror(\u0026#34;popen执行失败！\u0026#34;); exit(1); } while(fgets(result_buf, sizeof(result_buf), fp) != NULL) { /*为了下面输出好看些，把命令返回的换行符去掉*/ if(\u0026#39;\\n\u0026#39; == result_buf[strlen(result_buf)-1]) { result_buf[strlen(result_buf)-1] = \u0026#39;\\0\u0026#39;; } printf(\u0026#34;命令【%s】 输出【%s】\\r\\n\u0026#34;, command, result_buf); } /*等待命令执行完毕并关闭管道及文件指针*/ rc = pclose(fp); if(-1 == rc) { perror(\u0026#34;关闭文件指针失败\u0026#34;); exit(1); } else { printf(\u0026#34;命令【%s】子进程结束状态【%d】命令返回值【%d】\\r\\n\u0026#34;, command, rc, WEXITSTATUS(rc)); } return 0; } 编译并执行：\n$ gcc popen.c\n$ ./a.out\n命令【ls ./ | wc -l】 输出【2】\n命令【ls ./ | wc -l】子进程结束状态【0】命令返回值【0】\n上面popen只捕获了command的标准输出，如果command执行失败，子进程会把错误信息打印到标准错误输出，父进程就无法获取。比如，command命令为“ls nofile.txt” ，事实上我们根本没有nofile.txt这个文件，这时shell会输出“ls: nofile.txt: No such file or directory”。这个输出是在标准错误输出上的。通过上面的程序并无法获取。\n注：如果你把上面程序中的command设成“ls nofile.txt”,编译执行程序你会看到如下结果：\n$ gcc popen.c\n$ ./a.out\nls: nofile.txt: No such file or directory\n命令【ls nofile.txt】子进程结束状态【256】命令返回值【1】\n需要注意的是第一行输出并不是父进程的输出，而是子进程的标准错误输出。\n有时子进程的错误信息是很有用的，那么父进程怎么才能获取子进程的错误信息呢？\n这里我们可以重定向子进程的错误输出，让错误输出重定向到标准输出（2\u0026gt;\u0026amp;1），这样父进程就可以捕获子进程的错误信息了。例如command为“ls nofile.txt 2\u0026gt;\u0026amp;1”,输出如下：\n命令【ls nofile.txt 2\u0026gt;\u0026amp;1】 输出【ls: nofile.txt: No such file or directory】\n命令【ls nofile.txt 2\u0026gt;\u0026amp;1】子进程结束状态【256】命令返回值【1】\n附：子进程的终止状态判断涉及到的宏，设进程终止状态为status.\nWIFEXITED(status)如果子进程正常结束则为非0值。\nWEXITSTATUS(status)取得子进程exit()返回的结束代码，一般会先用WIFEXITED 来判断是否正常结束才能使用此宏。\nWIFSIGNALED(status)如果子进程是因为信号而结束则此宏值为真。\nWTERMSIG(status)取得子进程因信号而中止的信号代码，一般会先用WIFSIGNALED 来判断后才使用此宏。\nWIFSTOPPED(status)如果子进程处于暂停执行情况则此宏值为真。一般只有使用WUNTRACED 时才会有此情况。\nWSTOPSIG(status)取得引发子进程暂停的信号代码，一般会先用WIFSTOPPED 来判断后才使用此宏。\n转自：https://www.cnblogs.com/lidabo/p/5464134.html\n第11讲 操作系统上的进程 主要内容：\n最小 Linux fork execve exit 本次课回答的问题\nQ1: 操作系统启动后到底做了什么？ Q2: 操作系统如何管理程序 (进程)？ 复习第九讲的内容\n操作系统内核的启动： CPU Reset-\u0026gt; BIOS/UEFI-\u0026gt;Boot loader-\u0026gt;Kernel_start()\n操作系统会加载第一个程序\n比如systemd/init\n好像现在systemd已经是越来越多发行版的首选了，wsl2好像不是在WSL2的Ubuntu里配置systemd\n最小的linux\nmakefile也十分简单\nmake run 直接进入这个 qemu\nqemu 甚至没有图形界面 ctrl+a c退出sh\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 bach@LAPTOP-U1E6STIA:~/jyy/linux-minimal$ cat Makefile .PHONY: initramfs run clean $(shell mkdir -p build) initramfs: @cd initramfs \u0026amp;\u0026amp; find . -print0 | cpio --null -ov --format=newc | gzip -9 \\ \u0026gt; ../build/initramfs.cpio.gz run: @qemu-system-x86_64 \\ -nographic \\ -serial mon:stdio \\ -m 128 \\ -kernel vmlinuz \\ -initrd build/initramfs.cpio.gz \\ -append \u0026#34;console=ttyS0 quiet acpi=off\u0026#34; clean: @rm -rf build 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 (qemu) info registers RAX=ffffffffb62d5260 RBX=0000000000000000 RCX=0000000000000001 RDX=0000000000000f92 RSI=0000000000000087 RDI=0000000000000087 RBP=ffffffffb6e03e38 RSP=ffffffffb6e03e18 R8 =ffff9a834781df80 R9 =0000000000000200 R10=0000000000000000 R11=0000000000000000 R12=0000000000000000 R13=ffffffffb6e13780 R14=0000000000000000 R15=0000000000000000 RIP=ffffffffb62d564e RFL=00000246 [---Z-P-] CPL=0 II=0 A20=1 SMM=0 HLT=1 ES =0000 0000000000000000 00000000 00000000 CS =0010 0000000000000000 ffffffff 00af9b00 DPL=0 CS64 [-RA] SS =0018 0000000000000000 ffffffff 00cf9300 DPL=0 DS [-WA] DS =0000 0000000000000000 00000000 00000000 FS =0000 0000000000000000 00000000 00000000 GS =0000 ffff9a8347800000 00000000 00000000 LDT=0000 0000000000000000 00000000 00008200 DPL=0 LDT TR =0040 fffffe0000003000 0000206f 00008900 DPL=0 TSS64-avl GDT= fffffe0000001000 0000007f IDT= fffffe0000000000 00000fff CR0=80050033 CR2=0000000000a95c28 CR3=0000000003ca2000 CR4=000006f0 DR0=0000000000000000 DR1=0000000000000000 DR2=0000000000000000 DR3=0000000000000000 DR6=00000000ffff0ff0 DR7=0000000000000400 EFER=0000000000000d01 FCW=037f FSW=0000 [ST=0] FTW=00 MXCSR=00001f80 busybox是一个工具集，这么多工具居然只有2M，我哭死，加载到内核里我们就能使用了\ninit是一个启动脚本，它只有一行命令/bin/busybox sh启动sh，如果不让它启动shell会发生什么？\n会kernel panic\n你以为这个最小linux什么都做不了？非也！非也！\ngcc -c minimal.S\u0026amp;\u0026amp;ld minimal.o\nlinux 内核启动后，把所有的权利都交给一个进程，这一个进程再创建成整个世界\nfork 创建状态机\n创建子进程，保留进程所有上下文（内存、寄存器现场）。\n新进程返回0，执行fork的进程返回子进程的进程号\n理解fork的两个例子\nfork-demo.c 1 2 3 4 5 6 7 8 9 #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; int main() { pid_t pid1 = fork(); pid_t pid2 = fork(); pid_t pid3 = fork(); printf(\u0026#34;Hello World from (%d, %d, %d)\\n\u0026#34;, pid1, pid2, pid3); } 1 2 3 4 5 6 7 8 9 10 bach@LAPTOP-U1E6STIA:~/jyy/11$ gcc fork-demo.c bach@LAPTOP-U1E6STIA:~/jyy/11$ ./a.out Hello World from (133, 134, 136) Hello World from (0, 135, 137) Hello World from (133, 134, 0) Hello World from (0, 135, 0) Hello World from (133, 0, 138) Hello World from (133, 0, 0) Hello World from (0, 0, 0) Hello World from (0, 0, 139) 居然和我想的一样，不行这一定得拍下来\nfork-printf.c 神奇的事情出现了\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 bach@LAPTOP-U1E6STIA:~/jyy/11$ ./a.out Hello Hello Hello Hello Hello Hello bach@LAPTOP-U1E6STIA:~/jyy/11$ ./a.out|cat Hello Hello Hello Hello Hello Hello Hello Hello 这是printf的缓冲区导致的，fork会把缓冲区复制一份，等于虽然调用了printf，但是此时还没有执行系统调用。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;sys/wait.h\u0026gt; int main(int argc, char *argv[]) { int n = 2; for (int i = 0; i \u0026lt; n; i++) { fork(); printf(\u0026#34;Hello\u0026#34;); } printf(\u0026#34;\\n\u0026#34;); for (int i = 0; i \u0026lt; n; i++) { wait(NULL); } } gcc fork-printf.c\u0026amp;\u0026amp;a.out HelloHello HelloHello HelloHello HelloHello 这是一个bug吗？不是，这是我们没有充分理解fork的语义，也不知道缓冲区行为，才导致6或8个hello\nstdout和pipe/file缓冲区是不一样的\nstdout line buffer pipe/file full buffer 写满一页才传管道 如果你想得到6个hello，即让fork不复制缓冲区\n设置成无缓冲区：setbuf(stdout,NULL);\n加上fflush(stdout)迅速刷新\n如果你想得到8个hello，就让fork复制缓冲区就行了\n机器不知道你像做什么，只是忠实执行指令\nexecve 重置一个状态机，丢失所有当前状态\nint execve(const char *pathname, char *const argv[], char *const envp[]);\nThe argv and envp arrays must each include a null pointer at the end of the array.\ngcc strace结果\ngcc会在PATH下寻找as汇编器，找不到就g，我们可以指定PATH让找不到as\n1 2 3 4 5 6 7 8 9 10 11 12 bach@LAPTOP-U1E6STIA:~/jyy/11$ PATH=bb:Dsds /bin/strace -f /bin/gcc execve-demo.c |\u0026amp; grep \u0026#34;exec\u0026#34; execve(\u0026#34;/bin/gcc\u0026#34;, [\u0026#34;/bin/gcc\u0026#34;, \u0026#34;execve-demo.c\u0026#34;], 0x7ffeb064f200 /* 27 vars */) = 0 access(\u0026#34;execve-demo.c\u0026#34;, F_OK) = 0 [pid 506] execve(\u0026#34;/usr/lib/gcc/x86_64-linux-gnu/9/cc1\u0026#34;, [\u0026#34;/usr/lib/gcc/x86_64-linux-gnu/9/\u0026#34;..., \u0026#34;-quiet\u0026#34;, \u0026#34;-imultiarch\u0026#34;, \u0026#34;x86_64-linux-gnu\u0026#34;, \u0026#34;execve-demo.c\u0026#34;, \u0026#34;-quiet\u0026#34;, \u0026#34;-dumpbase\u0026#34;, \u0026#34;execve-demo.c\u0026#34;, \u0026#34;-mtune=generic\u0026#34;, \u0026#34;-march=x86-64\u0026#34;, \u0026#34;-auxbase\u0026#34;, \u0026#34;execve-demo\u0026#34;, \u0026#34;-fasynchronous-unwind-tables\u0026#34;, \u0026#34;-fstack-protector-strong\u0026#34;, \u0026#34;-Wformat\u0026#34;, \u0026#34;-Wformat-security\u0026#34;, \u0026#34;-fstack-clash-protection\u0026#34;, \u0026#34;-fcf-protection\u0026#34;, \u0026#34;-o\u0026#34;, \u0026#34;/tmp/ccfJr8oo.s\u0026#34;], 0x149cf70 /* 32 vars */ \u0026lt;unfinished ...\u0026gt; [pid 506] \u0026lt;... execve resumed\u0026gt;) = 0 [pid 506] stat(\u0026#34;execve-demo.c.gch\u0026#34;, 0x7fff6bab32d0) = -1 ENOENT (No such file or directory) [pid 506] openat(AT_FDCWD, \u0026#34;execve-demo.c\u0026#34;, O_RDONLY|O_NOCTTY) = 3 [pid 506] lstat(\u0026#34;/home/bach/jyy/11/execve-demo.c\u0026#34;, {st_mode=S_IFREG|0644, st_size=230, ...}) = 0 [pid 506] write(3, \u0026#34;\\t.file\\t\\\u0026#34;execve-demo.c\\\u0026#34;\\n\\t.text\\n\\t.\u0026#34;..., 1237) = 1237 [pid 507] execve(\u0026#34;bb/as\u0026#34;, [\u0026#34;as\u0026#34;, \u0026#34;--64\u0026#34;, \u0026#34;-o\u0026#34;, \u0026#34;/tmp/ccH9mHSm.o\u0026#34;, \u0026#34;/tmp/ccfJr8oo.s\u0026#34;], 0x149cf70 /* 32 vars */) = -1 ENOENT (No such file or directory) [pid 507] execve(\u0026#34;Dsds/as\u0026#34;, [\u0026#34;as\u0026#34;, \u0026#34;--64\u0026#34;, \u0026#34;-o\u0026#34;, \u0026#34;/tmp/ccH9mHSm.o\u0026#34;, \u0026#34;/tmp/ccfJr8oo.s\u0026#34;], 0x149cf70 /* 32 vars */) = -1 ENOENT (No such file or directory) write(2, \u0026#34;gcc: fatal error: cannot execute\u0026#34;..., 77gcc: fatal error: cannot execute ‘as’: execvp: No such file or directory 正常是：\n1 2 3 4 [pid 465] execve(\u0026#34;/usr/local/sbin/as\u0026#34;, [\u0026#34;as\u0026#34;, \u0026#34;--64\u0026#34;, \u0026#34;-o\u0026#34;, \u0026#34;/tmp/ccZ9qp1b.o\u0026#34;, \u0026#34;/tmp/ccYUOsnc.s\u0026#34;], 0x1166f70 /* 32 vars */) = -1 ENOENT (No such file or directory) [pid 465] execve(\u0026#34;/usr/local/bin/as\u0026#34;, [\u0026#34;as\u0026#34;, \u0026#34;--64\u0026#34;, \u0026#34;-o\u0026#34;, \u0026#34;/tmp/ccZ9qp1b.o\u0026#34;, \u0026#34;/tmp/ccYUOsnc.s\u0026#34;], 0x1166f70 /* 32 vars */) = -1 ENOENT (No such file or directory) [pid 465] execve(\u0026#34;/usr/sbin/as\u0026#34;, [\u0026#34;as\u0026#34;, \u0026#34;--64\u0026#34;, \u0026#34;-o\u0026#34;, \u0026#34;/tmp/ccZ9qp1b.o\u0026#34;, \u0026#34;/tmp/ccYUOsnc.s\u0026#34;], 0x1166f70 /* 32 vars */) = -1 ENOENT (No such file or directory) [pid 465] execve(\u0026#34;/usr/bin/as\u0026#34;, [\u0026#34;as\u0026#34;, \u0026#34;--64\u0026#34;, \u0026#34;-o\u0026#34;, \u0026#34;/tmp/ccZ9qp1b.o\u0026#34;, \u0026#34;/tmp/ccYUOsnc.s\u0026#34;], 0x1166f70 /* 32 vars */ \u0026lt;unfinished ...\u0026gt; exit exit的几种不同的写法：\nexit(0) stdlib.h中libc函数，会调用atexit\nAll functions registered with atexit(3) and on_exit(3) are called, in the reverse order of their registration. thread safety 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 bach@LAPTOP-U1E6STIA:~/jyy/11$ strace ./a.out exit execve(\u0026#34;./a.out\u0026#34;, [\u0026#34;./a.out\u0026#34;, \u0026#34;exit\u0026#34;], 0x7ffeba56b798 /* 27 vars */) = 0 arch_prctl(0x3001 /* ARCH_??? */, 0x7fff21d63de0) = -1 EINVAL (Invalid argument) brk(NULL) = 0x2282000 brk(0x22831c0) = 0x22831c0 arch_prctl(ARCH_SET_FS, 0x2282880) = 0 uname({sysname=\u0026#34;Linux\u0026#34;, nodename=\u0026#34;LAPTOP-U1E6STIA\u0026#34;, ...}) = 0 readlink(\u0026#34;/proc/self/exe\u0026#34;, \u0026#34;/home/bach/jyy/11/a.out\u0026#34;, 4096) = 23 brk(0x22a41c0) = 0x22a41c0 brk(0x22a5000) = 0x22a5000 mprotect(0x4bd000, 12288, PROT_READ) = 0 fstat(1, {st_mode=S_IFCHR|0620, st_rdev=makedev(0x88, 0), ...}) = 0 write(1, \u0026#34;Goodbye, Cruel OS World!\\n\u0026#34;, 25Goodbye, Cruel OS World! ) = 25 exit_group(0) = ? +++ exited with 0 +++ _exit(0) glibc的syscall wrapper\n所有的线程都会被终止\n如果此时有一个还未fflush的buffer的话，将不会输出\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 $cat exit-demo.c #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;time.h\u0026gt; #include \u0026lt;sys/syscall.h\u0026gt; int main(int argc, char *argv[]) { // atexit(func); printf(\u0026#34;unfflush buffer\u0026#34;); if (argc \u0026lt; 2) return EXIT_FAILURE; if (strcmp(argv[1], \u0026#34;exit\u0026#34;) == 0) exit(0); if (strcmp(argv[1], \u0026#34;_exit\u0026#34;) == 0) _exit(0); if (strcmp(argv[1], \u0026#34;__exit\u0026#34;) == 0) syscall(SYS_exit, 0); } $ ./a.out _exit $ ./a.out exit unfflush buffer 1 2 3 4 5 6 7 8 9 10 11 12 13 bach@LAPTOP-U1E6STIA:~/jyy/11$ strace ./a.out _exit execve(\u0026#34;./a.out\u0026#34;, [\u0026#34;./a.out\u0026#34;, \u0026#34;_exit\u0026#34;], 0x7ffee2ba8958 /* 27 vars */) = 0 arch_prctl(0x3001 /* ARCH_??? */, 0x7fff5f104010) = -1 EINVAL (Invalid argument) brk(NULL) = 0x1407000 brk(0x14081c0) = 0x14081c0 arch_prctl(ARCH_SET_FS, 0x1407880) = 0 uname({sysname=\u0026#34;Linux\u0026#34;, nodename=\u0026#34;LAPTOP-U1E6STIA\u0026#34;, ...}) = 0 readlink(\u0026#34;/proc/self/exe\u0026#34;, \u0026#34;/home/bach/jyy/11/a.out\u0026#34;, 4096) = 23 brk(0x14291c0) = 0x14291c0 brk(0x142a000) = 0x142a000 mprotect(0x4bd000, 12288, PROT_READ) = 0 exit_group(0) = ? +++ exited with 0 +++ __syscall(SYS_exit,0) 1 2 3 4 5 6 7 8 9 10 11 12 13 bach@LAPTOP-U1E6STIA:~/jyy/11$ strace ./a.out _exit execve(\u0026#34;./a.out\u0026#34;, [\u0026#34;./a.out\u0026#34;, \u0026#34;_exit\u0026#34;], 0x7ffee2ba8958 /* 27 vars */) = 0 arch_prctl(0x3001 /* ARCH_??? */, 0x7fff5f104010) = -1 EINVAL (Invalid argument) brk(NULL) = 0x1407000 brk(0x14081c0) = 0x14081c0 arch_prctl(ARCH_SET_FS, 0x1407880) = 0 uname({sysname=\u0026#34;Linux\u0026#34;, nodename=\u0026#34;LAPTOP-U1E6STIA\u0026#34;, ...}) = 0 readlink(\u0026#34;/proc/self/exe\u0026#34;, \u0026#34;/home/bach/jyy/11/a.out\u0026#34;, 4096) = 23 brk(0x14291c0) = 0x14291c0 brk(0x142a000) = 0x142a000 mprotect(0x4bd000, 12288, PROT_READ) = 0 exit(0) = ? +++ exited with 0 +++ 唯一的区别是exit(0) /exit_group(0)\n","date":"2022-07-26T16:09:16+08:00","permalink":"https://junling.li/posts/os-jyy-11/","section":"posts","tags":null,"title":"操作系统-jyy-11"},{"categories":null,"contents":"同步：信号量与哲♂学家吃饭问题 (信号量的正确打开方式) 信号量：一种条件变量的特例 1 2 3 4 5 6 7 8 9 void P(sem_t *sem) { // wait wait_until(sem-\u0026gt;count \u0026gt; 0) { sem-\u0026gt;count--; } } void V(sem_t *sem) { // post (signal) sem-\u0026gt;count++; } 正是因为条件的特殊性，信号量不需要 broadcast\nP 失败时立即睡眠等待 执行 V 时，唤醒任意等待的线程 第10讲 状态机模型的应用 细胞自动机 使用状态机视角理解物理世界\n宏观物理世界近似于deterministic的状态机（经典力学\n微观世界可能是 non-deterministic 的 (量子力学)\n下面是一些畅想：\n如果宇宙真的是一个状态机，随着时间切换状态。那么时间旅行能否被允许？如果回到过去，这时候的状态是否是过去的那个状态，还是过去的状态的copy，如果回到过去杀死祖父，会发生什么？（或许你不能把未来的状态带回过去，你也回不到过去）\n说实话我也想过这个问题，上学期有一个cuda实验，是模拟nbody问题，当时一个很显然的结论是，不能跳着预测到未来，必须一步一步的模拟。也就是说，dp问题不能偷懒算，这是一个显然的事情，但是有没有一个世界，能支持这种运算呢？\nhttps://www.scottaaronson.com/papers/philos.pdf\ngdb 对现代编译器来说，要保证源代码和机器码可观测行为严格一致，但内部可以做大量的优化。允许在状态机上跳跃\n现在的处理器已经可以在一个周期执行超过一条指令。你会发现它超过了主频,Instruction per clock(IPC)\u0026gt;1\n1 2 3 4 5 endwsl@LAPTOP-U1E6STIA:~/jyy/10$ gcc -O2 ilp-demo.c endwsl@LAPTOP-U1E6STIA:~/jyy/10$ ./a.out 7.03G instructions/s endwsl@LAPTOP-U1E6STIA:~/jyy/10$ ./a.out 8.81G instructions/s 观测状态机的执行\nstrace -T系统调用需要的时间\ngdb调试\ngdb怎么回到上一个状态？\ngdb隐藏功能：\nrecord full\nreverse-step/reverse-stepi回到过去\n从这个小例子rdrand可以看出rsi的魔力\n1 2 3 4 5 6 7 8 9 10 11 12 13 (gdb)record full (gdb) si (gdb) p val $4 = 1919810 (gdb) si (gdb) p val $5 = 3129724904492477147 (gdb) p $rax $6 = 3129724904492477147 (gdb) rsi (gdb) p val $7 = 1919810 rr Record \u0026amp; Replay 只需记录non-deterministic的指令的效果\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 endwsl@LAPTOP-U1E6STIA:~/jyy/10$ rr record ./a.out [FATAL /build/rr-79viaC/rr-5.2.0/src/RecordSession.cc:1796:create()] rr needs /proc/sys/kernel/perf_event_paranoid \u0026lt;= 1, but it is 2. Change it to 1, or use \u0026#39;rr record -n\u0026#39; (slow). Consider putting \u0026#39;kernel.perf_event_paranoid = 1\u0026#39; in /etc/sysctl.conf === Start rr backtrace: rr(_ZN2rr13dump_rr_stackEv+0x41)[0x562d705f7561] rr(_ZN2rr15notifying_abortEv+0x49)[0x562d705f75f9] rr(_ZN2rr13RecordSession6createERKSt6vectorINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESaIS7_EESB_RKNS_20DisableCPUIDFeaturesENS0_16SyscallBufferingENS_7BindCPUE+0xd38)[0x562d7055d618] rr(_ZN2rr13RecordCommand3runERSt6vectorINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESaIS7_EE+0x6b2)[0x562d70552192] rr(main+0x282)[0x562d704e2972] /lib/x86_64-linux-gnu/libc.so.6(__libc_start_main+0xeb)[0x7f6b4406309b] rr(_start+0x2a)[0x562d704e2a8a] === End rr backtrace Aborted endwsl@LAPTOP-U1E6STIA:~/jyy/10$ 所以，我们可以记录下操作系统的所有的执行过程，只需记录所有的io和中断，这样就对这个状态机的所有状态了如指掌\n性能摘要，这好像是jyy实验室的方向\n事实上不需要记录全部，观察状态机的执行，只需观察中断\nperf 这里jyy介绍了perf工具\n然后我发现我的wsl也不支持，我们仍未知道那天运行这段代码花了多少周期\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 [root@iZwz92v9xcjopgz0rhkwh1Z c]# perf stat ./a.out 13.21G instructions/s Performance counter stats for \u0026#39;./a.out\u0026#39;: 762.52 msec task-clock # 0.999 CPUs utilized 6 context-switches # 0.008 K/sec 1 cpu-migrations # 0.001 K/sec 52 page-faults # 0.068 K/sec \u0026lt;not supported\u0026gt; cycles \u0026lt;not supported\u0026gt; instructions \u0026lt;not supported\u0026gt; branches \u0026lt;not supported\u0026gt; branch-misses 0.763456230 seconds time elapsed 0.757800000 seconds user 0.000941000 seconds sys 实际中，80%的时间消耗在非常集中的几处代码。比如上次b站slb挂了，就通过火焰图发现所有时间都集中在gcd函数上了\nmodel checker 一些真正的 model checkers\nTLA+ by Leslie Lamport;\nJava PathFinder (JFP)\n和SPIN\n它们都喜欢用 Peterson 算法做 tutorial 😁 ","date":"2022-07-26T16:09:12+08:00","permalink":"https://junling.li/posts/os-jyy-10/","section":"posts","tags":null,"title":"操作系统-jyy-10"},{"categories":null,"contents":"同步：生产者-消费者与条件变量 (算法并行化；万能同步方法) 生活中的同步\n并发程序的同步\n线程同步：在某个时间点共同达到互相已知的状态 什么是生产者-消费者问题？ 先来看看这个\n1 2 void Tproduce(){while(1) printf(\u0026#34;(\u0026#34;);} void Tconsume(){while(1) printf(\u0026#34;)\u0026#34;);} 在printf前后增加代码，使得打印的括号序列满足\n一定是某个合法的括号序列的前缀 括号嵌套的深度不超过n 如果你能解决上面这个问题，那么你就能解决生产者-消费者问题。 所以生产者-消费者问题可以这样理解： 打印左括号：生产资源(任务)、放入队列 打印右括号：从队列中取出资源（任务）执行\n计算图 寻找并行计算的机会\n计算任务构成有向无环图 生产者-消费者实现 使用互斥锁保证条件满足\n左括号：嵌套深度不足n时才能打印 右括号：嵌套深度大于0时才能打印 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 #include \u0026#34;thread.h\u0026#34; #include \u0026#34;thread-sync.h\u0026#34; int n, count = 0; mutex_t lk = MUTEX_INIT(); #define CAN_PRODUCE (count \u0026lt; n) #define CAN_CONSUME (count \u0026gt; 0) void Tproduce() { while (1) { retry: mutex_lock(\u0026amp;lk);//上锁，如果有其他线程抢这个锁，其他线程上锁失败，切换到有锁线程执行 if (!CAN_PRODUCE) { mutex_unlock(\u0026amp;lk);//判断条件不满足，循环，此时操作系统切换到其他等待锁的线程执行 goto retry; } count++; printf(\u0026#34;(\u0026#34;); // Push an element into buffer mutex_unlock(\u0026amp;lk); } } void Tconsume() { while (1) { retry: mutex_lock(\u0026amp;lk); if (!CAN_CONSUME) { mutex_unlock(\u0026amp;lk); goto retry; } count--; printf(\u0026#34;)\u0026#34;); // Pop an element from buffer mutex_unlock(\u0026amp;lk); } } int main(int argc, char *argv[]) { assert(argc == 2); n = atoi(argv[1]); setbuf(stdout, NULL); for (int i = 0; i \u0026lt; 8; i++) { create(Tproduce); create(Tconsume); } } 检测输出是否正确 pc-check.py\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 import sys BATCH_SIZE = 100000 limit = int(sys.argv[1]) count, checked = 0, 0 while True: for ch in sys.stdin.read(BATCH_SIZE): match ch: case \u0026#39;(\u0026#39;: count += 1 case \u0026#39;)\u0026#39;: count -= 1 case _: assert 0 assert 0 \u0026lt;= count \u0026lt;= limit checked += BATCH_SIZE print(f\u0026#39;{checked} Ok.\u0026#39;) 通过管道传值./a.out 2|python3 pc-check.py 2 未来：ai帮我们做这些事\n条件变量 一把互斥锁+一个条件变量+手工唤醒\nwait(cv,mutex) 调用时必须保证已经获得mutex wait释放mutex、进入睡眠状态、等待被唤醒 被唤醒后需要重新执行lock(mutex) signal/notity(cv) 唤醒一个等待在cv上的线程 如果没有线程在cv上等待，则不做任何事情 broadcast(notify_all)(cv) 唤醒所有等待在cv上的线程 如果没有线程在cv上等待，则不做任何事情 错误的条件变量实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 #include \u0026#34;thread.h\u0026#34; #include \u0026#34;thread-sync.h\u0026#34; int n, count = 0; mutex_t lk = MUTEX_INIT(); cond_t cv = COND_INIT(); #define CAN_PRODUCE (count \u0026lt; n) #define CAN_CONSUME (count \u0026gt; 0) void Tproduce() { while (1) { mutex_lock(\u0026amp;lk); if (!CAN_PRODUCE) { cond_wait(\u0026amp;cv, \u0026amp;lk); } printf(\u0026#34;(\u0026#34;); count++; cond_signal(\u0026amp;cv); mutex_unlock(\u0026amp;lk); } } void Tconsume() { while (1) { mutex_lock(\u0026amp;lk); if (!CAN_CONSUME) { cond_wait(\u0026amp;cv, \u0026amp;lk); } printf(\u0026#34;)\u0026#34;); count--; cond_signal(\u0026amp;cv); mutex_unlock(\u0026amp;lk); } } int main(int argc, char *argv[]) { assert(argc == 3); n = atoi(argv[1]); int T = atoi(argv[2]); // Number of threads,add by copilot setbuf(stdout, NULL); for (int i = 0; i \u0026lt; T; i++) { create(Tproduce); create(Tconsume); } } ./a.out 1 2 出现了错误的答案，两个线程失败了？ 假设有两个consume在等待，produce打印了\u0026quot;(\u0026ldquo;唤醒了一个consume,打印了\u0026rdquo;)\u0026quot;，consume随机唤醒一个条件变量，唤醒了consume,打印了\u0026quot;)\u0026quot;，错误的答案出现了\n还是没弄懂唤醒后继续执行吗？确实\n如何解决？\nif(!CAN_CONSUME)改成while(!CAN_CONSUME)就可以了，就相当于写了assert(CAN_CONSUME)\n初学者很难写出正确的并发程序\n有意思的条件变量问题和实现 有三种线程\nTa 若干: 死循环打印 \u0026lt;\nTb 若干: 死循环打印 \u0026gt;\nTc 若干: 死循环打印 _ 任务：\n对这些线程进行同步，使得屏幕打印出 \u0026lt;\u0026gt;\u0026lt;_ 和 \u0026gt;\u0026lt;\u0026gt;_ 的组合 使用条件变量，只要回答三个问题：\n打印 “\u0026lt;” 的条件？\n打印 “\u0026gt;” 的条件？\n打印 “_” 的条件？\n状态转移\n第9讲 操作系统的状态机模型 谁加载了操作系统？\n不能被小学生吓倒，小学生是用有限的资料探索，大学能将已有的经验的方法重新消化，建立知识体系。\n破除迷信，操作系统真的就是一个C程序，只是需要一些额外的东西。\n//需要的素质：\n//难调试的问题怎么办？\n回到之前最小的C程序的例子：minimal.S\n它不需要任何依赖库，直接用汇编\n如果没有操作系统，如何直接在硬件上运行minimal.S?\n硬件厂商会约定，只要按照约定来就没问题了\n根据CPU手册(https://cdrdv2.intel.com/v1/dl/getContent/671190)，对intel x86来说，reset后 Real mode =0 处在16位兼容模式，\nELPAGS=0X0000002 中断关闭\nCPU reset后，CPU这个状态机的初始状态是唯一确定，PC指针指向一段memory-mapped ROM,这虽然是内存地址，但是是ROM断电后仍能保存数据，PC=ffff0\n用qemu-x86_64模拟一下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 (gdb) info register rip 0xfff0 0xfff0 eflags 0x2 [ IOPL=0 ] cs 0xf000 61440 (gdb) x/16xb 0xffff0 0xffff0: 0xea 0x5b 0xe0 0x00 0xf0 0x30 0x36 0x2f 0xffff8: 0x32 0x33 0x2f 0x39 0x39 0x00 0xfc 0x00 (gdb) x/10i ($cs * 16 + $rip) 0xffff0: (bad) 0xffff1: pop %rbx 0xffff2: loopne 0xffff4 0xffff4: lock xor %dh,(%rsi) 0xffff7: (bad) 0xffff8: xor (%rbx),%dh 0xffffa: (bad) 0xffffb: cmp %edi,(%rcx) 0xffffd: add %bh,%ah 0xfffff: add %al,(%rax) 查看资料都说这一段是跳转到jmp f000:e05b,确实跳转到e05b（也就是BIOS区域中某个地址）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 (gdb) si 0x000000000000e05b in ?? () (gdb) x/10i ($cs * 16 + $rip) 0xfe05b: cmpw $0xffc8,%cs:(%rsi) 0xfe060: (bad) 0xfe061: add %cl,(%rdi) 0xfe063: test %ecx,-0x10(%rdx) 0xfe066: xor %edx,%edx 0xfe068: mov %edx,%ss 0xfe06a: mov $0x7000,%sp 0xfe06e: add %al,(%rax) 0xfe070: mov $0x7c4,%dx 0xfe074: verw %cx 以后，随后又是一段跳转，到了bios真正的地方，\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 (gdb) si 0x000000000000e062 in ?? () (gdb) x/10i ($cs * 16 + $rip) 0xfe062: jne 0xffffffffd241d0b2 0xfe068: mov %edx,%ss 0xfe06a: mov $0x7000,%sp 0xfe06e: add %al,(%rax) 0xfe070: mov $0x7c4,%dx 0xfe074: verw %cx 0xfe077: stos %eax,%es:(%rdi) 0xfe078: out %al,(%dx) 0xfe079: push %bp 0xfe07b: push %di (gdb) BIOS 把第一个可引导设备的第一个扇区加载到物理内存的 7c00 位置\nBIOS/UEFI\nBIOS Legacy BIOS把第一个可引导设备的第一个扇区512B（MBR主引导扇区，最后两个字节是aa55）加载到物理内存的 7c00的位置，此时处理器还处于16-bit模式，规定CS:IP =0x7c00\n同时寄存器BL里保存着当前启动的设备的设备号，这个设备号用于INT 13中断服务，如果这个扇区的最后两个字节是55AA，那么就跳转到7C00上，并转交控制权\n这是firemare和操作系统的第一次也是唯一的一次握手。\n翻译 https://www.usenix.org/legacy/publications/library/proceedings/usenix05/tech/freenix/full_papers/bellard/bellard.pdf\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 (gdb) x/16xb 0x7c00 0x7c00: 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x7c08: 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 (gdb) wa *0x7c00 Hardware watchpoint 1: *0x7c00 (gdb) c Continuing. Hardware watchpoint 1: *0x7c00 Old value = 0 New value = 12794 0x000000000000a4c0 in ?? () (gdb) x/i ($cs * 16 + $rip) 0xfa4c0: rep insl (%dx),%es:(%edi) (gdb) x/10i ($cs * 16 + $rip) 0xfa4c0: rep insl (%dx),%es:(%edi) 0xfa4c3: mov 0xc(%esp),%si 0xfa4c9: add %si,(%esp) 0xfa4ce: mov 0x12(%esp),%eax 0xfa4d3: lea 0x2(%eax),%dx 0xfa4d8: in (%dx),%al 0xfa4d9: mov 0x14(%esp),%ax 0xfa4df: callw 0xa3f7 0xfa4e3: (bad) 0xfa4e4: jmpq *-0x7b(%rsi) (gdb) si Hardware watchpoint 1: *0x7c00 Old value = 12794 New value = -1900006918 0x000000000000a4c0 in ?? () (gdb) x/16xb 0x7c00 0x7c00: 0xfa 0x31 0xc0 0x8e 0x00 0x00 0x00 0x00 0x7c08: 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 (gdb) si 0x000000000000a4c0 in ?? () (gdb) x/16xb 0x7c00 0x7c00: 0xfa 0x31 0xc0 0x8e 0x00 0x00 0x00 0x00 0x7c08: 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 (gdb) si 0x000000000000a4c0 in ?? () (gdb) x/16xb 0x7c00 0x7c00: 0xfa 0x31 0xc0 0x8e 0xd8 0x8e 0x00 0x00 0x7c08: 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 (gdb) 看到内存7c00有值了，其实就是512个字节\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 00000000: 31c0 8ed8 8ec0 8ed0 b801 4fb9 1201 bf00 1.........O..... 00000010: 40cd 10b8 024f bb12 41cd 100f 0116 5c7c @....O..A.....\\| 00000020: 0f20 c066 83c8 010f 22c0 ea30 7c08 0066 . .f....\u0026#34;..0|..f 00000030: b810 008e d88e c08e d0bc 00a0 0000 e8b6 ................ 00000040: 0000 0000 0000 0000 0000 00ff ff00 0000 ................ 00000050: 9acf 00ff ff00 0000 92cf 0017 0044 7c00 .............D|. 00000060: 0055 89e5 5756 be00 0200 0053 5389 c301 .U..WV.....SS... 00000070: d089 45f0 89c8 81e3 00fe ffff 99f7 febe ..E............. 00000080: f701 0000 89c1 83c1 033b 5df0 7365 89f2 .........;].se.. 00000090: ec83 e0c0 3c40 75f6 baf2 0100 00b0 01ee ....\u0026lt;@u......... 000000a0: baf3 0100 0089 c8ee 89c8 baf4 0100 00c1 ................ 000000b0: f808 ee89 c8ba f501 0000 c1f8 10ee 89c8 ................ 000000c0: baf6 0100 00c1 f818 83c8 e0ee b020 89f2 ............. .. 000000d0: ee89 f2ec 83e0 c03c 4075 f6ba f001 0000 .......\u0026lt;@u...... 000000e0: 8dbb 0002 0000 ed89 0383 c304 39fb 75f6 ............9.u. UEFI bootloader\n初始化全局变量和栈；分配堆区 heap\n为main函数传递参数\n谁给操作系统传递了参数 mini操作系统 thread-os.c\n可以创建并发执行的任务\n后面是makefile的小技巧\n如何理解make？让make跑一遍，看看到底执行了什么\nvim里%s/ /\\r /g把空格变成换行\n1 2 3 sudo apt-get install gcc-x.x-multilib $ sudo apt-get install g++-x.x-multilib ","date":"2022-07-26T16:09:07+08:00","permalink":"https://junling.li/posts/os-jyy-9/","section":"posts","tags":null,"title":"操作系统-jyy-9"},{"categories":null,"contents":"在尝试众多GitHub加速的免费cdn以后，指jsd和raw.githubcontents.com,发现都不够稳定，索性斥巨资阿里云对象存储。\n首先开通oss，创建桶bucket\n创建用户并为他添加权限\n参考picgo文档\n阿里云OSS 配置项及说明：\n1 2 3 4 5 6 7 8 { \u0026#34;accessKeyId\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;accessKeySecret\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;bucket\u0026#34;: \u0026#34;\u0026#34;, // 存储空间名 \u0026#34;area\u0026#34;: \u0026#34;\u0026#34;, // 存储区域代号 \u0026#34;path\u0026#34;: \u0026#34;\u0026#34;, // 自定义存储路径 \u0026#34;customUrl\u0026#34;: \u0026#34;\u0026#34; // 自定义域名，注意要加http://或者https:// } 首先先在阿里云OSS的控制台里找到你的accessKeyId和accessKeySecret：\n确认你的存储区域的代码：\n如上图，存储区域就是oss-cn-beijing\n存储路径比如img/的话，上传的图片会默认放在OSS的img文件夹下。注意存储路径一定要以/结尾！存储路径是可选的，如果不需要请留空。\n最后防止盗刷，最后一定还要添加流量报警，防止一晚上以后房子都是阿里云的了\n暂时的打算是新的图传阿里云，老图还在github仓库\n希望一次配置，以后永远不用再烦图床了。\n2022/9/6更新，由于最近看了几个例子，开了oss/cos被ddos了刷了好几万，阿里云开不了cdn（国内访问需备案域名），遂关了oss。这篇的保质期也只有两个月，阿里云也被我白嫖了两个月。\n这当然不是因为我懒得配cloudflare加速（减速），这是本blog的网络安全周的特别企划。\n","date":"2022-07-21T19:28:17+08:00","permalink":"https://junling.li/posts/%E5%9B%BE%E5%BA%8A/","section":"posts","tags":null,"title":"图床"},{"categories":null,"contents":"简单记住一下 tmux的基本使用，因为自己记性不行\n新建会话 tmux new -s \u0026quot;name\u0026quot;\n退出会话 ctrl+b d或tmux detach\n进入某会话tmux a -t \u0026quot;name\u0026quot;\n查看所有会话 tmux ls\n杀死tmux kill-session -t \u0026quot;name\u0026quot;|id\n切换会话 tmux switch -t \u0026quot;name\u0026quot;|id\n上下分窗口 ctrl+b d\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 Ctrl+b d：分离当前会话。 Ctrl+b s：列出所有会话。 Ctrl+b $：重命名当前会话。 Ctrl+b 再按上下左右键切换窗口 Ctrl+b %:左右分窗口 \u0026#34;：上下分窗口 Ctrl+b d:退出当前窗口 Ctrl+b [:进行上下翻页，q取消翻页 Ctrl+b {：当前窗格与上一个窗格交换位置。 Ctrl+b }：当前窗格与下一个窗格交换位置。 Ctrl+b Ctrl+o：所有窗格向前移动一个位置，第一个窗格变成最后一个窗格。 Ctrl+b Alt+o：所有窗格向后移动一个位置，最后一个窗格变成第一个窗格。 Ctrl+b x：关闭当前窗格。 # exit Ctrl+b !：将当前窗格拆分为一个独立窗口。 Ctrl+b z：当前窗格全屏显示，再使用一次会变回原来大小。 Ctrl+b Ctrl+\u0026lt;arrow key\u0026gt;：按箭头方向调整窗格大小。 Ctrl+b q：显示窗格编号。 ———————————————— 版权声明：本文为CSDN博主「仰望星空的小随」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。 原文链接：https://blog.csdn.net/sui_152/article/details/121650341 ","date":"2022-07-20T11:00:02+08:00","permalink":"https://junling.li/posts/tmux/","section":"posts","tags":null,"title":"Tmux"},{"categories":null,"contents":"在某一次commit以后，github pages突然挂了，出了什么问题呢？\n尝试一 重启\n尝试二 回退，既然我没有问题，那就是引入的脚本的问题\n我想到了之前只引入评论的的http://blog.junling.xyz/test.html\n这个怎么丝毫没有问题啊\n想到用浏览器的开发者工具\nUncaught (in promise) TypeError: Cannot read properties of null (reading ‘insertBefore‘)\n这时我找到waline的讨论区，有人遇到和我一样的问题\nhttps://github.com/walinejs/waline/discussions/735\n看看它是这么解决的\n好家伙，直接解决出现问题的人，换了个评论系统不就完了\n尝试三 看看别人是怎么在客户端引入waline的，先是找到了一个hugo的主题next:https://github.com/elkan1788/hugo-theme-next，抄一遍他的代码，怎么不管用？\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 {{ if and (.Site.Params.Comment.Enable) (eq .Site.Params.Comment.Module \u0026#34;Waline\u0026#34;) }} \u0026lt;!-- Waline --\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; const locale = { placeholder: \u0026#39;{{ i18n \u0026#34;CommentPh\u0026#34; | safeHTML }}\u0026#39; }; $(function(){ if (detectIE()\u0026gt;0) { $.getScript(document.location.protocol+\u0026#39;//unpkg.com/@waline/client@1.6.0/dist/Waline.min.js\u0026#39;, function(){ new Waline({ el: \u0026#39;#wcomments\u0026#39;, visitor: true, emoji: [], wordLimit: \u0026#39;200\u0026#39;, uploadImage: false, locale, requiredMeta: [\u0026#39;nick\u0026#39;, \u0026#39;mail\u0026#39;], serverURL: \u0026#34;{{ .Site.Params.Comment.WalineSerURL }}\u0026#34;, lang: \u0026#34;{{ .Page.Lang }}\u0026#34; }); }); } else { $(\u0026#39;#wcomments\u0026#39;).html(\u0026#39;{{ i18n \u0026#34;UnComment\u0026#34; }}\u0026#39;); } }); \u0026lt;/script\u0026gt; \u0026lt;!-- Waline --\u0026gt; {{end }} 我们只要简单修改一下\n原来是我的环境变量错了，他的配置是params.toml我的是config.toml问题不大，参考官方文档改写config.toml，和script.html怎么我的评论都没了，初步判定是找不到#waline这个div，因为这个div在别的html文件里，\n开发者工具告诉我 $(function{})不能这么写， ReferenceError: $ is not defined at 一看发现还要引入jq\nJQuery 的代码我们通常会包裹在一个$(function(){})函数中，jq 的$(function(){})也就是$(document).ready(function(){})的简写，与之对应的原生 js 的window.onload事件\nnew Waline()和Waline.init()的区别\n别的参考：\n同样是为hugo主题引入waline\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 {{- $waline := $comment.waline | default dict -}} {{- if $waline.enable -}} \u0026lt;div id=\u0026#34;waline\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script src=\u0026#39;{{ $waline.js }}\u0026#39;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; new Waline({ el: \u0026#39;#waline\u0026#39;, meta: {{ $waline.meta }}, requiredMeta: {{ $waline.requiredMeta }}, login: {{ $waline.login }}, placeholder: {{ $waline.placeholder }}, serverURL: {{ $waline.serverURL }}, avatarCDN: {{ $waline.avatarCDN }}, pageSize: {{ $waline.pageSize }}, avatar: {{ $waline.avatar }}, lang: {{ $waline.lang }}, visitor: {{ $waline.visitor }}, highlight: {{ $waline.highlight }}, uploadImage: {{ $waline.uploadImage }}\t}); \u0026lt;/script\u0026gt; {{- end -}} https://lewky.cn/posts/hugo-3.1.html/#%E4%BD%BF%E7%94%A8waline%E6%9B%BF%E4%BB%A3valine%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F\n尝试四 索性咱们再搭一个博客\n反思： 仍然迷惑不解的地方：为什么昨天突然挂了\n对js不够了解\n22/9/9 update\ncname waline.junling.xyz cname-china.vercel-dns.com\n","date":"2022-07-18T00:17:23+08:00","permalink":"https://junling.li/posts/fixbug_difficultly/","section":"posts","tags":null,"title":"一个艰难的找bug过程"},{"categories":null,"contents":"起因 最近想到我还有一个用于记录生活的 Hexo 博客需要更新\n由于代码在Windows上，而我有时候在manjaro上写作，同步就是一个问题。Git仓库上是hexo d直接deploy上去的（因为不想让你们看到md文件）\n当然这种问题一般再建一个分支代码，或者咱干脆再建一个 Private 仓库，用 Github Actions 帮助我们构建并提交到另一个仓库，这样本地甚至都不需要node环境（node_modules里面1万多个小文件真让人大头，随机读写爆炸，PMR杀手），这样我们甚至能把github当做hexo前端。\n说干就干\nGithub actions 我们先了解一下Actions\n相当于一个虚拟vps，你可以使用它的Windows，linux，macOS环境跑任意的程序，比如某校每天需要定时体温打卡，你有一段Python脚本需要定时执行，上一篇中推荐了cron，当然你可能不放心自己的机子会不会出故障，相比之下github服务器出故障的概率就小很多，就算Github遇到像哔哩哔哩的SLB挂了的情况，也丝毫不影响定时Actions的执行。又比如你需要构建Android应用没有环境，需要构建flutter应用没有flutter环境，需要构建Swift应用而又没有mac，都可以使用Actions。\nGithub以你的仓库的.github/workflow目录下的yml文件为指示，按照该yml文件指示的执行。\n一个workflow可以创建一个或多个job，job都是并发执行的并不是按照申明的先后顺序执行的， 如果多个job 之间存在依赖关系，那么你可能需要使用 needs 。\n一个job可以有一个或多个step，每个step可以执行多条命令。\n新建一个仓库，将本地的hexo文件夹内容push上去。再新建一个workflow，具体将在下面例子中解释。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 # workflow name name: Hexo Blog CI # master branch on push, auto run on: push: #触发条件push GitHub Actions 也支持外部事件触发，或者定时运行。 branches: - master jobs: build: runs-on: ubuntu-latest # 运行在最新版本Ubuntu steps: # check it to your workflow can access it # from: https://github.com/actions/checkout - name: Checkout Repository master branch uses: actions/checkout@master # 表示使用别人预先设置好的actions # from: https://github.com/actions/setup-node - name: Setup Node.js 12.x uses: actions/setup-node@master with: node-version: \u0026#34;12.x\u0026#34; # 这个是steps可能需要的参数，node版本12.x - name: Setup Hexo Dependencies # 装一波hexo-cli run: | npm install hexo-cli -g npm install --force - name: Setup Deploy Private Key # 设置私钥 600=11000000B env: HEXO_DEPLOY_PRIVATE_KEY: ${{ secrets.HEXO_DEPLOY_PRIVATE_KEY }} #env给step配置环境变量 run: | mkdir -p ~/.ssh/ echo \u0026#34;$HEXO_DEPLOY_PRIVATE_KEY\u0026#34; \u0026gt; ~/.ssh/id_rsa chmod 600 ~/.ssh/id_rsa ssh-keyscan github.com \u0026gt;\u0026gt; ~/.ssh/known_hosts - name: Setup Git Infomation run: | git config --global user.name \u0026#39;yourname\u0026#39; git config --global user.email \u0026#39;youremail\u0026#39; - name: Deploy Hexo run: | hexo clean hexo generate hexo deploy 这时需要我们把私钥写入HEXO_DEPLOY_PRIVATE_KEY这个环境变量。\n在仓库设置settings的secrets里新建actions变量，注意，这里的名称要填HEXO_DEPLOY_PRIVATE_KEY\n这样提交到仓库就不需要密码了，Windows、linux的私钥一般在~/.ssh/id_rsa里。\n到此就配置结束了，每次 push 都会触发actions，我们可以在actions里查看运行情况\n问题 问题1 action执行失败卡在deploy\n1 2 3 fatal: could not read Username for \u0026#39;https://github.com\u0026#39;: No such device or address FATAL { err: Error: Spawn failed 这个问题太奇怪；我一直以为是我用户名没打对，或者私钥错了，最后发现是仓库要用\ngit@github.com而不能用https://github.com\n1 2 3 4 deploy: type: git repo: git@github.com:username/repo.git #true repo: https://github.com/username/repo.git #false 问题2 hexo deploy是强制推送的，会覆盖我原来的提交，这样我似乎在Hexo pages仓库只有两个提交记录，一个是init，一个是最新的提交\n当执行 hexo deploy 时，Hexo 会将 public 目录中的文件和目录推送至 _config.yml 中指定的远端仓库和分支中，并且完全覆盖该分支下的已有内容。\n哦，但是我的CNAME去哪了，把ls pubilc加入jobs检查CNAME是在public里面啊。\n然后看到官方文档\n此外，如果您的 Github Pages 需要使用 CNAME 文件自定义域名，请将 CNAME 文件置于 source 目录下，只有这样 hexo deploy 才能将 CNAME 文件一并推送至部署分支。\n温馨提示：如非必要，别用\u0026ndash;force\n扩展 上一期提到了crontab这个工具，workflow也支持时间触发，使用的语法，就是上一期提到的POSIX cron语法\nYou can use on.schedule to define a time schedule for your workflows. You can schedule a workflow to run at specific UTC times using POSIX cron syntax. Scheduled workflows run on the latest commit on the default or base branch. The shortest interval you can run scheduled workflows is once every 5 minutes.\nThis example triggers the workflow every day at 5:30 and 17:30 UTC:\n1 2 3 4 on: schedule: # * is a special character in YAML so you have to quote this string - cron: \u0026#39;30 5,17 * * *\u0026#39; 甚至可以支持更复杂的情况：\nA single workflow can be triggered by multiple schedule events.\nYou can access the schedule event that triggered the workflow through the github.event.schedule context. This example triggers the workflow to run at 5:30 UTC every Monday-Thursday, but skips the Not on Monday or Wednesday step on Monday and Wednesday.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 on: schedule: - cron: \u0026#39;30 5 * * 1,3\u0026#39; - cron: \u0026#39;30 5 * * 2,4\u0026#39; jobs: test_schedule: runs-on: ubuntu-latest steps: - name: Not on Monday or Wednesday if: github.event.schedule != \u0026#39;30 5 * * 1,3\u0026#39; run: echo \u0026#34;This step will be skipped on Monday and Wednesday\u0026#34; - name: Every time run: echo \u0026#34;This step will always run\u0026#34; https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions\n","date":"2022-07-16T21:11:48+08:00","permalink":"https://junling.li/posts/github-actions/","section":"posts","tags":null,"title":"Github Actions"},{"categories":null,"contents":"第七讲 并发控制 互斥 自旋锁 互斥锁 把锁的实现放到操作系统里\nsyscall(SYSCALL_lock,\u0026amp;lk); 试图获得lk，如果失败，就切换到其他线程 syscall(SYSCALL_unlock,\u0026amp;lk);释放lk，如果有等待锁的线程，就唤醒它 ","date":"2022-07-16T18:01:22+08:00","permalink":"https://junling.li/posts/os-jyy-7/","section":"posts","tags":null,"title":"操作系统-jyy-7"},{"categories":null,"contents":"手把手教你如何利用 工具crontab执行定时脚本 介绍 Cron 是一个在 Unix 及类似操作系统上执行计划任务的程序。cron 使用户能够安排工作(命令或shell脚本)在特定时间、日期或间隔定期运行，通常用于系统的自动化维护或者管理。[摘自 Wikipedia]\nCron 是一个守护进程，它根据来自命令crontab的输入运行计划任务。它的工作方式为，每分钟向定时表输入并检查用户有 cron 清单，以及是否有应该执行的工作。\n注意 注意crontab既是计划工作清单的名字，也是编辑这一清单的命令。[摘自 wiki.gentoo.org]\n使用 crontab的使用文件做配置\n这意味着你任务的描述在文件中\n我们需要做的是写这个配置文件\n配置文件基本格式\n分 时 日 月 星期 命令\n分 的值为0到59\n时 的值为0到23\n日 的值为1到31\n月 的值为1到12\n星期 值从0到6 ，0代表星期日\n除了使用整数代表分、时、日、月，还可以设置范围\n符号 描述 ***** 通配符，表示所有支持的时间值 , 用逗号分隔多个时间 - 连接两个数值，给出一个范围 / 指定一个周期或频率 例如 ：\n1 */5 9-16 * 1-5,9-12 1-5 ~/bin/i_love_cron.sh 将会在周内从早上 9 点到下午 4 点 55 分，每隔 5 分钟执行一次脚本 i_love_cron.sh，夏季除外（6月、7月和8月）。\n除了以上定时，crontab在命令前还可以增加一些修饰词，以提供更细节的控制\n1 2 3 4 5 6 7 8 @reboot 启动时 @yearly 每年一次 @annually ( 同 @yearly) @monthly 每月一次 @weekly 每周一次 @daily 每天一次 @midnight (午夜，同 @daily) @hourly 每小时一次 例如：\n1 @reboot ~/bin/i_love_cron.sh 将在启动时执行脚本 i_love_cron.sh。\n写完文件以后，我们通过crontab filename即可添加此配置,此会覆盖之前添加的旧的配置文件，可以使用crontab -l查看已经存在的配置文件\n如果你想修改配置，使用crontab -e可以编辑此配置，默认情况下，将使用vi编辑器打开配置文件\n如果你想要移除crontabs可以使用crontab -r\n1 2 3 4 5 6 7 crontab [-u user] file crontab [ -u user ] [ -i ] { -e | -l | -r } (default operation is replace, per 1003.2) -e (edit user\u0026#39;s crontab) -l (list user\u0026#39;s crontab) -r (delete user\u0026#39;s crontab) -i (prompt before deleting user\u0026#39;s crontab) 例子 接下来就是手把手教学\n例子1 我需要每天一个6点半的闹钟,应该按此编辑配置文件\n1 6 30 echo\u0026#34;ring_ring_ring\u0026#34; 例子2 我需要每1分钟执行报时程序，将此时时间追加写入到/root/date_time\n1 * * * * * date\u0026gt;\u0026gt;/root/date_time 运行10分钟后查看/root/date_time\n1 2 3 4 5 6 7 8 9 $cat /root/date_time Thu Jul 14 17:41:01 CST 2022 Thu Jul 14 17:42:02 CST 2022 Thu Jul 14 17:43:01 CST 2022 Thu Jul 14 17:44:01 CST 2022 Thu Jul 14 17:45:01 CST 2022 Thu Jul 14 17:46:01 CST 2022 Thu Jul 14 17:47:01 CST 2022 Thu Jul 14 17:48:01 CST 2022 发现运行正常\n例子3 我需要每1分钟执行报时程序，这个报时程序是一段 Python 脚本,位置在/root/py_datetime，将此时时间追加写入到/root/date_time_py\n1 * * * * * python /root/py_datetime \u0026gt;\u0026gt;/root/date_time_py Python 脚本内容为\n1 2 from datetime import datetime print(datetime.now()) 运行10分钟后查看\n1 2 3 4 5 6 7 8 9 10 $cat /root/date_time_py 2022-07-14 18:12:01.871340 2022-07-14 18:13:02.029239 2022-07-14 18:14:01.179830 2022-07-14 18:15:01.333957 2022-07-14 18:16:01.463118 2022-07-14 18:17:01.591877 2022-07-14 18:18:01.735284 2022-07-14 18:19:01.863682 2022-07-14 18:20:02.010490 例子4 我需要每1分钟执行date报时程序，并每小时执行python报时程序，即有两个任务，配置文件可以写成这样\n1 2 * * * * * date\u0026gt;\u0026gt;/root/date_time 0 * * * * python /root/py_datetime \u0026gt;\u0026gt;/root/date_time_py 每小时也可以简写为\n1 @hourly python /root/py_datetime \u0026gt;\u0026gt;/root/date_time_py 例子5 我需要每天的午夜 0 点 20 分, 2 点 20 分, 4 点 20 分\u0026hellip;.执行 echo \u0026ldquo;haha\u0026rdquo;：\n1 20 0-23/2 * * * echo \u0026#34;haha\u0026#34; 更多例子\n1 2 3 4 5 6 7 8 9 10 11 12 13 30 4 echo \u0026#34;四点半了。\u0026#34; 0 22 echo \u0026#34;晚上十点了。\u0026#34; 30 15 25 12 echo \u0026#34;现在是圣诞节下午三点半。\u0026#34; 30 3 * * * echo \u0026#34;每天早上三点半提醒我。\u0026#34; 0 * * * * echo \u0026#34;新的一个小时到来了。\u0026#34; 0 6 1,15 * * echo \u0026#34;每月1号和15号的早上六点。\u0026#34; 0 6 * * 2,3,5 echo \u0026#34;周二三四的早上六点。\u0026#34; 59 23 * * 1-5 echo \u0026#34;周内每天的最后一分钟。\u0026#34; 0 */2 * * * echo \u0026#34;每两个小时。\u0026#34; 0 20 * * 4 echo \u0026#34;周四的晚上八点。\u0026#34; 0 20 * * Thu echo \u0026#34;周四的晚上八点。\u0026#34; */15 9-17 * * 2-5 echo \u0026#34;周内朝九晚五的每一刻钟。\u0026#34; @yearly echo \u0026#34;新年好！\u0026#34; 如果你还不会配置时间，可以访问\nhttps://crontab.guru/\n进阶 处理任务中的错误 cron 会记录 stdout 和 stderr 的输出并尝试通过 sendmail 命令发送邮件给用户。如果 Cronie 未找到 /usr/bin/sendmail，则会禁用邮件通知。要发送邮件到用户的 spool，需要在系统上运行一个 smtp 守护进程，例如 opensmtpd。也可以安装提供 sendmail 命令的软件包，然后配置成通过外部邮件服务器发送邮件。或者使用 -m 选项将错误记录到日志并通过定制的脚本进行处理。\n使用 ssmtp 的例子 ssmtp 是一个仅包含发送功能的 sendmail 模拟器，可以从本地计算机向 smtp 服务器发送邮件。尽管目前已经没有活跃维护者，这个程序依然是发送邮件的最简单方式。不需要运行守护进程，配置可以简单到只需在一个配置文件中编辑三行即可（如果你的主机是受信任的，可以通过你的邮件服务提供商转发未经认证的邮件）。ssmtp 无法收取邮件、展开别名或管理队列。\n安装 ssmtpAUR，安装时会创建链接 /usr/bin/sendmail 指向 /usr/bin/ssmtp。安装后编辑 /etc/ssmtp/ssmtp.conf 配置文件。详情请参考 ssmtp，到 /usr/bin/sendmail 的软链接可以确保 S-nail 等提供 /usr/bin/mail 的程序可以无需修改直接使用。\n安装配置完成后重启 cronie 以确保 cronie 能够检测到新配置的 /usr/bin/sendmail 命令。\n默认编辑器 要修改默认编辑器，请在 shell 初始化脚本中定义 EDITOR 环境变量，如环境变量所述。\n作为普通用户，需要使用 su 代替 sudo 来正确拉取环境变量：\n1 $ su -c \u0026#34;crontab -e\u0026#34; 如果希望给这个命令取别名，因为 su 会在一个新启动的子 shell 中启动，为了防止一些以外的发生，需要用 printf 加一个任意字符串，来提醒你仍然在 root 下运行：\n1 alias scron=\u0026#34;su -c $(printf \u0026#34;%q \u0026#34; \u0026#34;crontab -e\u0026#34;)\u0026#34; 确保排他性 如果您有可能运行很久的任务（比如说变化很多或者网速突然变慢，备份可能会偶尔运行很长时间），那么 flock（util-linux）可以确保 cron 任务在同一时间点只有一个运行。\n1 5,35 * * * * /usr/bin/flock -n /tmp/lock.backup /root/make-backup.sh 参考资料\nhttps://wiki.gentoo.org/wiki/Cron\nhttps://wiki.archlinux.org/title/Cron\n","date":"2022-07-14T17:15:13+08:00","permalink":"https://junling.li/posts/crontab/","section":"posts","tags":null,"title":"Crontab"},{"categories":null,"contents":"这里讲记录一些自己使用git时候的一些注意事项和小tips\ngit push到别人的分支如何回退 1.备份战场 建立新分支\ngit branch imsb\n2.掩耳盗铃 回退\ngit checkout yuanfenzhi\ngit log找到那一串 commit代码\ngit reset --hard 一长串commit回退\n1 2 3 4 5 6 7 8 9 10 11 --mixed 不删除工作空间改动代码，撤销commit，并且撤销git add . 操作 这个为默认参数,git reset --mixed HEAD^ 和 git reset HEAD^ 效果是一样的。 --soft 不删除工作空间改动代码，撤销commit，不撤销git add . --hard 删除工作空间改动代码，撤销commit，撤销git add . --hard HEAD commitid可以回到哪次提交 --hard HEAD^ 表示最近一次提交 3.暗度陈仓 git push --force\n要用force因为push的版本小于远程仓库的版本\n这样别人就察觉不到你push错了\n将最近的13次提交合并 git rebase -i HEAD~13\npick 保留该commit squash将该commit和前一个commit合并\n至少保留一个pick，不然把head给删了\n11.6 git 这是Unix 笔记的git部分\n虽然之前学了下git，但学得不够深入，最近重新看了一下git的相关知识\nGit 工作区、暂存区和版本库概念：\n**工作区：**就是你在电脑里能看到的目录。 **暂存区：**英文叫 stage 或 index。一般存放在 .git 目录下的 index 文件（.git/index）中，所以我们把暂存区有时也叫作索引（index）。 **版本库：**工作区有一个隐藏目录 .git，这个不算工作区，而是 Git 的版本库。 下面这个图展示了工作区、版本库中的暂存区和版本库之间的关系：\ngit clone、git push、git add 、git commit、git checkout、git pull\n以前只会git push后面不加东西，然后在推送blog时出现了一些问题\n命令格式如下：\n1 git push \u0026lt;远程主机名\u0026gt; \u0026lt;本地分支名\u0026gt;:\u0026lt;远程分支名\u0026gt; 如果本地分支名与远程分支名相同，则可以省略冒号：\n1 git push \u0026lt;远程主机名\u0026gt; \u0026lt;本地分支名\u0026gt; 实例\n以下命令将本地的 master 分支推送到 origin 主机的 master 分支。\n1 $ git push origin master 相等于：\n1 $ git push origin master:master 如果本地版本与远程版本有差异，但又要强制推送可以使用 \u0026ndash;force 参数：\n1 git push --force origin master 删除主机但分支可以使用 \u0026ndash;delete 参数，以下命令表示删除 origin 主机的 master 分支：\n1 git push origin --delete master 分支\n想push时不影响原来的远程分支，怎么办？回退很麻烦，那怎么办？\n创建分支命令：\n1 git branch (branchname) 切换分支命令:\n1 git checkout (branchname) 当你切换分支的时候，Git 会用该分支的最后提交的快照替换你的工作目录的内容， 所以多个分支不需要多个目录。\n合并分支命令:\n1 git merge 你可以多次合并到统一分支， 也可以选择在合并之后直接删除被并入的分支。\n开始前我们先创建一个测试目录：\n1 2 3 4 $ mkdir gitdemo$ cd git-demo/ $ git initInitialized empty Git repository... $ touch README$ git add README $ git commit -m \u0026#39;第一次版本提交\u0026#39;[master (root-commit) 3b58100] 第一次版本提交 1 file changed, 0 insertions(+), 0 deletions(-) create mode 100644 README Git 分支管理 列出分支 列出分支基本命令：\n1 git branch 没有参数时，git branch 会列出你在本地的分支。\n1 $ git branch* master 此例的意思就是，我们有一个叫做 master 的分支，并且该分支是当前分支。\n当你执行 git init 的时候，默认情况下 Git 就会为你创建 master 分支。\n如果我们要手动创建一个分支。执行 git branch (branchname) 即可。\n1 $ git branch testing$ git branch* master testing 现在我们可以看到，有了一个新分支 testing。\n当你以此方式在上次提交更新之后创建了新分支，如果后来又有更新提交， 然后又切换到了 testing 分支，Git 将还原你的工作目录到你创建分支时候的样子。\n接下来我们将演示如何切换分支，我们用 git checkout (branch) 切换到我们要修改的分支。\n1 2 3 4 5 6 7 $ lsREADME$ echo \u0026#39;runoob.com\u0026#39; \u0026gt; test.txt $ git add . $ git commit -m \u0026#39;add test.txt\u0026#39;[master 3e92c19] add test.txt 1 file changed, 1 insertion(+) create mode 100644 test.txt $ ls README test.txt $ git checkout testing Switched to branch \u0026#39;testing\u0026#39;$ lsREADME 当我们切换到 testing 分支的时候，我们添加的新文件 test.txt 被移除了。切换回 master 分支的时候，它们有重新出现了。\n1 2 3 $ git checkout masterSwitched to branch \u0026#39;master\u0026#39; $ ls README test.txt 我们也可以使用 git checkout -b (branchname) 命令来创建新分支并立即切换到该分支下，从而在该分支中操作。\n1 2 3 4 5 6 7 8 9 10 $ git checkout -b newtest Switched to a new branch \u0026#39;newtest\u0026#39; $ git rm test.txt rm \u0026#39;test.txt\u0026#39;$ lsREADME$ touch runoob.php $ git add . $ git commit -am \u0026#39;removed test.txt、add runoob.php\u0026#39;[newtest c1501a2] removed test.txt、add runoob.php 2 files changed, 1 deletion(-) create mode 100644 runoob.php delete mode 100644 test.txt $ ls README runoob.php $ git checkout masterSwitched to branch \u0026#39;master\u0026#39; $ ls README test.txt 如你所见，我们创建了一个分支，在该分支的上移除了一些文件 test.txt，并添加了 runoob.php 文件，然后切换回我们的主分支，删除的 test.txt 文件又回来了，且新增加的 runoob.php 不存在主分支中。\n使用分支将工作切分开来，从而让我们能够在不同开发环境中做事，并来回切换。\n删除分支 删除分支命令：\n1 git branch -d (branchname) 例如我们要删除 testing 分支：\n1 2 3 4 $ git branch* master testing $ git branch -d testing Deleted branch testing (was 85fc7e7). $ git branch* master 分支合并 一旦某分支有了独立内容，你终究会希望将它合并回到你的主分支。 你可以使用以下命令将任何分支合并到当前分支中去：\n1 2 3 4 5 6 git merge $ git branch* master newtest $ ls README test.txt $ git merge newtest Updating 3e92c19..c1501a2Fast-forward runoob.php | 0 test.txt | 1 - 2 files changed, 1 deletion(-) create mode 100644 runoob.php delete mode 100644 test.txt$ lsREADME runoob.php 以上实例中我们将 newtest 分支合并到主分支去，test.txt 文件被删除。\n合并完后就可以删除分支:\n1 2 $ git branch -d newtest Deleted branch newtest (was c1501a2). 删除后， 就只剩下 master 分支了：\n1 $ git branch* master 合并冲突 合并并不仅仅是简单的文件添加、移除的操作，Git 也会合并修改。\n1 2 $ git branch* master $ cat runoob.php 首先，我们创建一个叫做 change_site 的分支，切换过去，我们将 runoob.php 内容改为:\n1 \u0026lt;?phpecho \u0026#39;runoob\u0026#39;;?\u0026gt; 创建 change_site 分支：\n1 2 3 4 5 $ git checkout -b change_siteSwitched to a new branch \u0026#39;change_site\u0026#39; $ vim runoob.php $head -3 runoob.php\u0026lt;?phpecho \u0026#39;runoob\u0026#39;;?\u0026gt; $ git commit -am \u0026#39;changed the runoob.php\u0026#39; [change_site 7774248] changed the runoob.php 1 file changed, 3 insertions(+) 将修改的内容提交到 change_site 分支中。 现在，假如切换回 master 分支我们可以看内容恢复到我们修改前的(空文件，没有代码)，我们再次修改 runoob.php 文件。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 $ git checkout master Switched to branch \u0026#39;master\u0026#39; $ cat runoob.php $ vim runoob.php # 修改内容如下 $ cat runoob.php \u0026lt;?php echo 1; ?\u0026gt; $ git diff diff --git a/runoob.php b/runoob.php index e69de29..ac60739 100644 --- a/runoob.php +++ b/runoob.php @@ -0,0 +1,3 @@ +\u0026lt;?php +echo 1; +?\u0026gt; $ git commit -am \u0026#39;修改代码\u0026#39; [master c68142b] 修改代码 1 file changed, 3 insertions(+) 现在这些改变已经记录到我的 \u0026ldquo;master\u0026rdquo; 分支了。接下来我们将 \u0026ldquo;change_site\u0026rdquo; 分支合并过来。\n1 2 3 4 5 6 7 8 9 10 11 12 13 $ git merge change_site Auto-merging runoob.php CONFLICT (content): Merge conflict in runoob.php Automatic merge failed; fix conflicts and then commit the result. $ cat runoob.php # 代开文件，看到冲突内容 \u0026lt;?php \u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt; HEAD echo 1; ======= echo \u0026#39;runoob\u0026#39;; \u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt; change_site ?\u0026gt; 我们将前一个分支合并到 master 分支，一个合并冲突就出现了，接下来我们需要手动去修改它。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 $ vim runoob.php $ cat runoob.php \u0026lt;?php echo 1; echo \u0026#39;runoob\u0026#39;; ?\u0026gt; $ git diff diff --cc runoob.php index ac60739,b63d7d7..0000000 --- a/runoob.php +++ b/runoob.php @@@ -1,3 -1,3 +1,4 @@@ \u0026lt;?php +echo 1; + echo \u0026#39;runoob\u0026#39;; ?\u0026gt; 在 Git 中，我们可以用 git add 要告诉 Git 文件冲突已经解决\n1 2 3 $ git status -sUU runoob.php $ git add runoob.php$ git status -sM runoob.php $ git commit[master 88afe0e] Merge branch \u0026#39;change_site\u0026#39; 现在我们成功解决了合并中的冲突，并提交了结果。\n以上文字大多数摘自runoob.com，我感觉是写得非常有条理了，另外介绍一个学习gitbranch的神奇的网站，无聊的时候可以练练手。\nhttps://learngitbranching.js.org/\n","date":"2022-07-11T19:37:54+08:00","permalink":"https://junling.li/posts/git-guide/","section":"posts","tags":null,"title":"git 指南"},{"categories":null,"contents":"第六讲 并发控制基础 Peterson算法、模型检验和软件自动化工具\n主要内容：\n如何阅读理解教科书、互联网上的各种并发程序\n如何保证互斥：一个很简单的例子Peterson算法 以及如何画出并发程序状态机的状态\n如何保证一个全局变量某一刻只被一个线程写、读？\n\u0026lt;=\u0026gt;如何保证一个厕所某一刻只被一个人使用？\nPeterson算法\nA和B争抢厕所，但是他们都很谦让。\n上厕所前，需要事先举旗并贴字。具体来说\n如果A想要上厕所，会事先举起旗子，旗子上写了A，并且将厕所门口贴上B 如果B想要上厕所，会事先举起旗子，旗子上写了B，并且将厕所门口贴上A 准备工作做好以后，下一步将根据旗子和厕所门口的字来决定是否进入厕所。具体来说\n如果A想要进入厕所，会观察是否有人举起旗子，如果B举了旗子，且门上的贴了B，他将等待，否则A将进入厕所 如果B想要进入厕所，会观察是否有人举起旗子，如果A举了旗子，且门上的贴了A，他将等待，否则B将进入厕所 出厕所后，将放下自己的旗子。\n这种奇怪的算法将保证A或B进入厕所时，厕所没人。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 #include \u0026#34;thread.h\u0026#34; #define A 1 #define B 2 atomic_int nested; atomic_long count; void critical_section() { long cnt = atomic_fetch_add(\u0026amp;count, 1); assert(atomic_fetch_add(\u0026amp;nested, 1) == 0); atomic_fetch_add(\u0026amp;nested, -1); } int volatile x = 0, y = 0, turn = A; void TA() { while (1) { /* PC=1 */ x = 1; /* PC=2 */ turn = B; /* PC=3 */ while (y \u0026amp;\u0026amp; turn == B) ; critical_section(); /* PC=4 */ x = 0; } } void TB() { while (1) { /* PC=1 */ y = 1; /* PC=2 */ turn = A; /* PC=3 */ while (x \u0026amp;\u0026amp; turn == A) ; critical_section(); /* PC=4 */ y = 0; } } int main() { create(TA); create(TB); } 我们会不自觉地提出一些问题：\n如果结束后把门上的字条撕掉，算法还正确吗？ 在放下旗子之前撕 在放下旗子之后撕 如果先贴标签再举旗，算法还正确吗？ 我们有两个 “查看” 的操作 看对方的旗有没有举起来 看门上的贴纸是不是自己 这两个操作的顺序影响算法的正确性吗？ 是否存在 “两个人谁都无法进入临界区” (liveness)、“对某一方不公平” (fairness) 等行为？ 都转换成图 (状态空间) 上的遍历问题了！ 为了保证peterson的正确性，我们还需要什么？\n原子指令来保证读/写单个变量是“原子不可分割”的 编译器设置屏障 当然这种奇怪算法的正确性需要验证，接下来的所有内容都是围绕验证的。\n一种方法是通过人脑来枚举A和B抢着上厕所以及举旗过程的所有状态。模拟多线程执行代码的顺序。\n另一种方法是计算机验证，jyy的功底就体现出来了。\n使用Python这种动态语言模拟验证状态机正确性。 Model checker\n并利用某些库可视化状态机的所有状态。\njyy利用了Generator的一个特性来保存函数运行的上下文。这使得我们能够更方便地模拟状态机的执行过程。\n关于Model Checker的Python实现和可视化展示这里就暂且不说了。\n所以究竟是怎么做到的，还需要看看2022年的视频\n这节课告诉了我们工具的重要性，计算机辅助验证彳亍，人脑模拟计算机不彳亍！\n","date":"2022-07-05T22:52:40+08:00","permalink":"https://junling.li/posts/os-jyy-6/","section":"posts","tags":null,"title":"操作系统-jyy-6 并发控制基础"},{"categories":null,"contents":"第2讲 应用视角的操作系统 主要内容\n什么是软件（程序） 操作系统上的{最小/一般/图像}程序 什么是编译器？编译器把一段代码翻译成什么样的指令序列才算正确？ 最小的程序 HelloWorld gcc a.c --verbose可以查看所有编译选项\ngcc a.c -static -Wl,--verbose查看所有链接选项\n走一遍编译链接流程\n用gdb调试汇编代码\ngdb layout asm\nsyscall 系统调用\n改变进程状态，创建进程或销毁自己\n当年在写汇编的时候，发现只去做加减，做运算是远远不够的，你不可能无限循环下去，你写出的绝妙的汇编矩阵乘法，如果没有输入输出，有什么用？ 当时就有一个想法，能不能不用操作系统，直接在cpu上运行asm代码？当然可以，但有什么用？没有输入输出，你只能看到一个黑盒子里面不知道发生了什么。 所以必须要有操作系统，就比如用INT 21H 中断退出程序。\ngcc -c只编译不链接\n最小的c代码是可以运行的\n1 2 3 void main(){ } 链接警告,定义成_start避免警告\n哈哈居然可以不以main函数为开头，见到c语言代码必须有main函数是不是可以判错了\n1 2 3 4 5 6 $ vim os_litter.c $ gcc -c os_litter.c $ ls a.out os.c os_litter.c os_litter.o $ ld os_litter.o ld: warning: cannot find entry symbol _start; defaulting to 00000000004000b0 改成这个 ld os_litter.o -e main 指定入口\n可以链接，运行失败\n1 2 3 4 [root@iZwz92v9xcjopgz0rhkwh1Z c]# gcc -c os_litter.c [root@iZwz92v9xcjopgz0rhkwh1Z c]# ld os_litter.o [root@iZwz92v9xcjopgz0rhkwh1Z c]# ./a.out Segmentation fault (core dumped) 加一个while(1)就可以运行了\n1 2 3 4 5 6 7 8 9 10 11 12 13 [root@iZwz92v9xcjopgz0rhkwh1Z c]# gcc -c os_litter.c [root@iZwz92v9xcjopgz0rhkwh1Z c]# ld os_litter.o [root@iZwz92v9xcjopgz0rhkwh1Z c]# ./a.out ^C [root@iZwz92v9xcjopgz0rhkwh1Z c]# ll total 16 -rwxr-xr-x 1 root root 1104 Jun 23 21:12 a.out -rw-r--r-- 1 root root 483 Jun 23 20:01 os.c -rw-r--r-- 1 root root 32 Jun 23 21:12 os_litter.c -rw-r--r-- 1 root root 1232 Jun 23 21:12 os_litter.o [root@iZwz92v9xcjopgz0rhkwh1Z c]# size a.out text data bss dec hex filename 58 0 0 58 3a a.out 这是一个超级小的a.out\n观察此状态机的运行的工具：gdb\nstarti可以帮助我们从第一条指令开始执行程序\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 native process 1247611 In: _start L?? PC: 0x4000b0 ┌───────────────────────────────────────────────────────────┐ \u0026gt;│0x4000b0 \u0026lt;_start\u0026gt; push %rbp │ │0x4000b1 \u0026lt;_start+1\u0026gt; mov %rsp,%rbp │ │0x4000b4 \u0026lt;_start+4\u0026gt; jmp 0x4000b4 \u0026lt;_start+4\u0026gt; │ │0x4000b6 add %al,(%rax) │ │0x4000b8 adc $0x0,%al │ │0x4000ba add %al,(%rax) │ │0x4000bc add %al,(%rax) │ │0x4000be add %al,(%rax) │ │0x4000c0 add %edi,0x52(%rdx) │ │0x4000c3 add %al,(%rcx) │ │0x4000c5 js 0x4000d7 │ │0x4000c7 add %ebx,(%rbx) │ │0x4000c9 or $0x7,%al │ │0x4000cb or %dl,0x18000001(%rax) │ │0x4000d1 add %al,(%rax) │ │0x4000d3 add %bl,(%rax,%rax,1) │ │0x4000d6 add %al,(%rax) │ └───────────────────────────────────────────────────────────┘ native process 1247611 In: _start L?? PC: 0x4000b0 (gdb) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 ┌───────────────────────────────────────────────────────────┐ \u0026gt;│0x4000b0 \u0026lt;_start\u0026gt; push %rbp │ │0x4000b1 \u0026lt;_start+1\u0026gt; mov %rsp,%rbp │ │0x4000b4 \u0026lt;_start+4\u0026gt; nop │ │0x4000b5 \u0026lt;_start+5\u0026gt; pop %rbp │ │0x4000b6 \u0026lt;_start+6\u0026gt; retq │ │0x4000b7 add %dl,(%rax,%rax,1) │ │0x4000ba add %al,(%rax) │ │0x4000bc add %al,(%rax) │ │0x4000be add %al,(%rax) │ │0x4000c0 add %edi,0x52(%rdx) │ │0x4000c3 add %al,(%rcx) │ │0x4000c5 js 0x4000d7 │ │0x4000c7 add %ebx,(%rbx) │ │0x4000c9 or $0x7,%al │ │0x4000cb or %dl,0x1c000001(%rax) │ │0x4000d1 add %al,(%rax) │ │0x4000d3 add %bl,(%rax,%rax,1) │ └───────────────────────────────────────────────────────────┘ ┌───────────────────────────────────────────────────────────┐ │0x4000b0 \u0026lt;_start\u0026gt; push %rbp │ │0x4000b1 \u0026lt;_start+1\u0026gt; mov %rsp,%rbp │ │0x4000b4 \u0026lt;_start+4\u0026gt; nop │ │0x4000b5 \u0026lt;_start+5\u0026gt; pop %rbp │ \u0026gt;│0x4000b6 \u0026lt;_start+6\u0026gt; retq │ │0x4000b7 add %dl,(%rax,%rax,1) │ │0x4000ba add %al,(%rax) │ │0x4000bc add %al,(%rax) │ │0x4000be add %al,(%rax) │ │0x4000c0 add %edi,0x52(%rdx) │ │0x4000c3 add %al,(%rcx) │ │0x4000c5 js 0x4000d7 │ │0x4000c7 add %ebx,(%rbx) │ │0x4000c9 or $0x7,%al │ │0x4000cb or %dl,0x1c000001(%rax) │ │0x4000d1 add %al,(%rax) │ │0x4000d3 add %bl,(%rax,%rax,1) │ └───────────────────────────────────────────────────────────┘ native process 1247751 In: L?? PC: 0x1 (gdb) si 0x00000000004000b4 in _start () (gdb) si 0x00000000004000b5 in _start () (gdb) si 0x00000000004000b6 in _start () (gdb) si 0x0000000000000001 in ?? () Cannot access memory at address 0x1 没有while的void _start(){} 错位的地方在retq 原因 返回的地址是非法的0x1?\n解决异常退出 有什么办法让程序停下来？\n没有停机指令 解决方法：增加系统调用42 系统调用 在syscall发生的时候，把程序完全交给操作系统\n1 2 3 4 #include\u0026lt;sys/syscall.h\u0026gt; int main(){ syscall(SYS_exit,42); } 这就没有问题了，正常返回了\n1 2 3 4 5 6 7 8 $ gcc ex_sys.c ex_sys.c: In function ‘main’: ex_sys.c:3:5: warning: implicit declaration of function ‘syscall’ [-Wimplicit-function-declaration] syscall(SYS_exit,42); ^~~~~~~ $ ls a.out ex_sys.c os.c $ ./a.out syscall的实现在libc里，不方便直接链接\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 ┌───────────────────────────────────────────────────────────────────────────────────────────────┐ \u0026gt;│0x40059a \u0026lt;main+4\u0026gt; mov $0x2a,%esi │ │0x40059f \u0026lt;main+9\u0026gt; mov $0x3c,%edi │ │0x4005a4 \u0026lt;main+14\u0026gt; mov $0x0,%eax │ │0x4005a9 \u0026lt;main+19\u0026gt; callq 0x4004a0 \u0026lt;syscall@plt\u0026gt; │ │0x4005ae \u0026lt;main+24\u0026gt; mov $0x0,%eax │ │0x4005b3 \u0026lt;main+29\u0026gt; pop %rbp │ │0x4005b4 \u0026lt;main+30\u0026gt; retq │ │0x4005b5 nopw %cs:0x0(%rax,%rax,1) │ │0x4005bf nop │ │0x4005c0 \u0026lt;__libc_csu_init\u0026gt; endbr64 │ │0x4005c4 \u0026lt;__libc_csu_init+4\u0026gt; push %r15 │ │0x4005c6 \u0026lt;__libc_csu_init+6\u0026gt; mov %rdx,%r15 │ │0x4005c9 \u0026lt;__libc_csu_init+9\u0026gt; push %r14 │ │0x4005cb \u0026lt;__libc_csu_init+11\u0026gt; mov %rsi,%r14 │ │0x4005ce \u0026lt;__libc_csu_init+14\u0026gt; push %r13 │ │0x4005d0 \u0026lt;__libc_csu_init+16\u0026gt; mov %edi,%r13d │ │0x4005d3 \u0026lt;__libc_csu_init+19\u0026gt; push %r12 │ │0x4005d5 \u0026lt;__libc_csu_init+21\u0026gt; lea 0x200824(%rip),%r12 # 0x600e00 │ │0x4005dc \u0026lt;__libc_csu_init+28\u0026gt; push %rbp │ │0x4005dd \u0026lt;__libc_csu_init+29\u0026gt; lea 0x200824(%rip),%rbp # 0x600e08 │ │0x4005e4 \u0026lt;__libc_csu_init+36\u0026gt; push %rbx │ └───────────────────────────────────────────────────────────────────────────────────────────────┘ native process 1247963 In: main L?? PC: 0x40059a (gdb) 这里能看到callq\njyy为我们准备了最小的汇编代码，我哭死\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include \u0026lt;sys/syscall.h\u0026gt; .globl _start _start: movq $SYS_write, %rax # write( movq $1, %rdi # fd=1, movq $st, %rsi # buf=st, movq $(ed - st), %rdx # count=ed-st syscall # ); movq $SYS_exit, %rax # exit( movq $1, %rdi # status=1 syscall # ); st: .ascii \u0026#34;\\033[01;31mHello, OS World\\033[0m\\n\u0026#34; ed: 接下来见证奇迹\n1 2 3 [root@iZwz92v9xcjopgz0rhkwh1Z c]# gcc minimal.S -c \u0026amp;\u0026amp;ld minimal.o [root@iZwz92v9xcjopgz0rhkwh1Z c]# ./a.out Hello, OS World 甚至也可以用gdb看执行过程\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 │0x40008d \u0026lt;_start+21\u0026gt; mov $0x1c,%rdx │ \u0026gt;│0x400094 \u0026lt;_start+28\u0026gt; syscall │ │0x400094 \u0026lt;_start+28\u0026gt; syscall 0x3c,%rax │ │0x400096 \u0026lt;_start+30\u0026gt; mov $0x3c,%rax │ \u0026gt;│0x40009d \u0026lt;_start+37\u0026gt; mov $0x1,%rdi │ │0x4000a6 \u0026lt;st\u0026gt; sbb 0x30(%rbx),%ebx │ │0x4000a9 \u0026lt;st+3\u0026gt; xor %edi,(%rbx) │ │0x4000ab \u0026lt;st+5\u0026gt; xor (%rcx),%esi │ │0x4000ad \u0026lt;st+7\u0026gt; insl (%dx),%es:(%rdi) │ │0x4000ae \u0026lt;st+8\u0026gt; rex.W │ │0x4000af \u0026lt;st+9\u0026gt; gs insb (%dx),%es:(%rdi) │ │0x4000b1 \u0026lt;st+11\u0026gt; insb (%dx),%es:(%rdi) │ │0x4000b2 \u0026lt;st+12\u0026gt; outsl %ds:(%rsi),(%dx) │ │0x4000b3 \u0026lt;st+13\u0026gt; sub $0x20,%al │ │0x4000b5 \u0026lt;st+15\u0026gt; rex.WRXB push %r11 │ │0x4000b7 \u0026lt;st+17\u0026gt; and %dl,0x6f(%rdi) │ │0x4000ba \u0026lt;st+20\u0026gt; jb 0x400128 │ │0x4000bc \u0026lt;st+22\u0026gt; sbb %fs:0x30(%rbx),%ebx │ └───────────────────────────────────────────────────────────────────────────────────────────────┘ native process 1248099 In: _start L?? PC: 0x400094 (gdb) starti d Program stopped. 0x0000000000400078 in _start () (gdb) si 0x000000000040007f in _start () 0x0000000000400086 in _start () 0x000000000040008d in _start () 0x0000000000400094 in _start () Hello, OS World 0x0000000000400096 in _start () 0x000000000040009d in _start () (gdb) 操作系统中的程序 你理解程序吗？ 如果你能写一个c语言的解释器，那你就完全理解了高级语言\n尝试写一个非递归的hanio吧，用基础结构模拟函数调用和递归\n来看看chatgpt写的例子\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 void hanoi_non_recursive(int n, char from, char to, char via) { struct Element { int n; char from; char to; char via; }; std::stack\u0026lt;Element\u0026gt; elements; elements.push({n, from, to, via}); while (!elements.empty()) { auto e = elements.top(); elements.pop(); if (e.n == 1) { printf(\u0026#34;%c -\u0026gt; %c\\n\u0026#34;, e.from, e.to); } else { elements.push({e.n - 1, e.via, e.to, e.from}); elements.push({1, e.from, e.to, e.via}); elements.push({e.n - 1, e.from, e.via, e.to}); } } } jyy写的非递归的hanio\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 typedef struct { int pc, n; char from, to, via; } Frame; #define call(...) ({ *(++top) = (Frame) { .pc = 0, __VA_ARGS__ }; }) #define ret() ({ top--; }) #define goto(loc) ({ f-\u0026gt;pc = (loc) - 1; }) void hanoi(int n, char from, char to, char via) { Frame stk[64], *top = stk - 1; call(n, from, to, via); for (Frame *f; (f = top) \u0026gt;= stk; f-\u0026gt;pc++) { n = f-\u0026gt;n; from = f-\u0026gt;from; to = f-\u0026gt;to; via = f-\u0026gt;via; switch (f-\u0026gt;pc) { case 0: if (n == 1) { printf(\u0026#34;%c -\u0026gt; %c\\n\u0026#34;, from, to); goto(4); } break; case 1: call(n - 1, from, via, to); break; case 2: call( 1, from, to, via); break; case 3: call(n - 1, via, to, from); break; case 4: ret(); break; default: assert(0); } } } 理解是函数调用，返回。\n简单的c语言的状态机模型（语义）\nc语言程序是状态机\n状态栈帧的列表+全局变量\n初始状态=main(argc,argv)\n迁移=执行top stack frame PC++\n函数调用时是什么？\n栈帧oush stack frame\n创建新栈帧\n函数返回pop stack frame\n理解编译器\n什么是正确的编译 两种状态机的翻译\n外部观察需要完全一致\n除去不可优化的部分都给它优化了 inline assembly也可以参与优化\n未来的编译器\n根据语义优化，把冒泡优化成快排\nsemantic-based compilation\nAI-based rewriting\n扩展阅读：\nAn executable formal semantics of C with applications (POPL'12)\nComCert C verified compiler and a paper(POPL'06,Most Influential Paper Award)\nCopy-and-patch compilation (OOPSLA'21 Distinguished Paper)\nPL的领域有一种倾向：用数学化的语言定义和理解一切\n背后的直觉依然是System/software\n和minimal.S没有本质区别：程序=计算-\u0026gt;syscall\n操作系统收编（管理）了所有的硬件/软件资源\n只能用操作系统允许的方式访问操作系统的对象 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; void try_open(const char *fname) { int fd = open(fname, O_RDWR); printf(\u0026#34;open(\\\u0026#34;%s\\\u0026#34;) returns %d\\n\u0026#34;, fname, fd); if (fd \u0026lt; 0) { perror(\u0026#34; FAIL\u0026#34;); } else { printf(\u0026#34; SUCCESS!\\n\u0026#34;); close(fd); } } int main() { try_open(\u0026#34;/something/not/exist\u0026#34;); try_open(\u0026#34;/dev/sda\u0026#34;); // hard drive } 1 2 3 4 5 $ gcc tryopen.c \u0026amp;\u0026amp;./a.out open(\u0026#34;/something/not/exist\u0026#34;) returns -1 FAIL: No such file or directory open(\u0026#34;/dev/\u0026#34;) returns -1 FAIL: Is a directory 常见的应用程序 Core Utilities 系统/工具程序 bash,binutils,apt,ip,ssh,vim,tmux,python\nHello World输出的第一条指令是什么，第一条指令在libc里\nmain()之前发生了什么\nld-linux-x86-64.so 加载了libc\n之后libc完成了自己的初始化\nRTFM: libc startup on Hurd main() 的开始/结束并不是整个程序的开始/结束 1 2 3 4 5 6 7 8 9 10 11 12 13 14 [root@iZwz92v9xcjopgz0rhkwh1Z c]# cat hello-goodbye.c #include \u0026lt;stdio.h\u0026gt; __attribute__((constructor)) void hello() { printf(\u0026#34;Hello, World\\n\u0026#34;); } // See also: atexit(3) __attribute__((destructor)) void goodbye() { printf(\u0026#34;Goodbye, Cruel OS World!\\n\u0026#34;); } int main() { } 在main()执行前/后执行指令\n为什么是ld-linux-x86-64.so而不是其他的.so\nelf里写的是ld-linux-x86-64.so\nstrace能看到所有的系统调用\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 $ strace ./a.out execve(\u0026#34;./a.out\u0026#34;, [\u0026#34;./a.out\u0026#34;], 0x7ffcbb202a30 /* 37 vars */) = 0 brk(NULL) = 0x12ae000 arch_prctl(0x3001 /* ARCH_??? */, 0x7ffcb59f2750) = -1 EINVAL (Invalid argument) mmap(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f0035dbc000 access(\u0026#34;/etc/ld.so.preload\u0026#34;, R_OK) = -1 ENOENT (No such file or directory) openat(AT_FDCWD, \u0026#34;/etc/ld.so.cache\u0026#34;, O_RDONLY|O_CLOEXEC) = 3 fstat(3, {st_mode=S_IFREG|0644, st_size=24711, ...}) = 0 mmap(NULL, 24711, PROT_READ, MAP_PRIVATE, 3, 0) = 0x7f0035db5000 close(3) = 0 openat(AT_FDCWD, \u0026#34;/lib64/libc.so.6\u0026#34;, O_RDONLY|O_CLOEXEC) = 3 read(3, \u0026#34;\\177ELF\\2\\1\\1\\3\\0\\0\\0\\0\\0\\0\\0\\0\\3\\0\u0026gt;\\0\\1\\0\\0\\0\\2405\\2\\0\\0\\0\\0\\0\u0026#34;..., 832) = 832 fstat(3, {st_mode=S_IFREG|0755, st_size=3167872, ...}) = 0 lseek(3, 808, SEEK_SET) = 808 read(3, \u0026#34;\\4\\0\\0\\0\\20\\0\\0\\0\\5\\0\\0\\0GNU\\0\\2\\0\\0\\300\\4\\0\\0\\0\\3\\0\\0\\0\\0\\0\\0\\0\u0026#34;, 32) = 32 mmap(NULL, 3950400, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0x7f00357cd000 mprotect(0x7f0035989000, 2093056, PROT_NONE) = 0 mmap(0x7f0035b88000, 24576, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x1bb000) = 0x7f0035b88000 mmap(0x7f0035b8e000, 14144, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0x7f0035b8e000 close(3) = 0 mmap(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f0035db3000 arch_prctl(ARCH_SET_FS, 0x7f0035dbd600) = 0 mprotect(0x7f0035b88000, 16384, PROT_READ) = 0 mprotect(0x600000, 4096, PROT_READ) = 0 mprotect(0x7f0035dbe000, 4096, PROT_READ) = 0 munmap(0x7f0035db5000, 24711) = 0 openat(AT_FDCWD, \u0026#34;/something/not/exist\u0026#34;, O_RDWR) = -1 ENOENT (No such file or directory) fstat(1, {st_mode=S_IFCHR|0620, st_rdev=makedev(0x88, 0), ...}) = 0 brk(NULL) = 0x12ae000 brk(0x12cf000) = 0x12cf000 brk(NULL) = 0x12cf000 write(1, \u0026#34;open(\\\u0026#34;/something/not/exist\\\u0026#34;) ret\u0026#34;..., 40open(\u0026#34;/something/not/exist\u0026#34;) returns -1 ) = 40 dup(2) = 3 fcntl(3, F_GETFL) = 0x2 (flags O_RDWR) fstat(3, {st_mode=S_IFCHR|0620, st_rdev=makedev(0x88, 0), ...}) = 0 write(3, \u0026#34; FAIL: No such file or director\u0026#34;..., 34 FAIL: No such file or directory ) = 34 close(3) = 0 openat(AT_FDCWD, \u0026#34;/dev/\u0026#34;, O_RDWR) = -1 EISDIR (Is a directory) write(1, \u0026#34;open(\\\u0026#34;/dev/\\\u0026#34;) returns -1\\n\u0026#34;, 25open(\u0026#34;/dev/\u0026#34;) returns -1 ) = 25 dup(2) = 3 fcntl(3, F_GETFL) = 0x2 (flags O_RDWR) fstat(3, {st_mode=S_IFCHR|0620, st_rdev=makedev(0x88, 0), ...}) = 0 write(3, \u0026#34; FAIL: Is a directory\\n\u0026#34;, 23 FAIL: Is a directory ) = 23 close(3) = 0 exit_group(0) = ? +++ exited with 0 +++ 本质上所有的程序和 Hello World 类似\n程序 = 状态机 = 计算 → syscall → 计算 →\n被操作系统加载 通过另一个进程执行 execve 设置为初始状态\n状态机执行 进程管理：fork, execve, exit, \u0026hellip; 文件/设备管理：open, close, read, write, \u0026hellip; 存储管理：mmap, brk, \u0026hellip; 直到 _exit (exit_group) 退出 (初学者对这一点会感到有一点惊讶)\n说好的浏览器、游戏、杀毒软件、病毒呢？都是这些 API 吗？\n这些 API 就是操作系统的全部\n编译器 (gcc)，代表其他工具程序\n主要的系统调用：execve, read, write strace -f gcc a.c (gcc 会启动其他进程) 可以管道给编辑器 vim - 编辑器里还可以 %!grep (细节/技巧) strace -f gcc a.c |\u0026amp; vim -\n图形界面程序 (xedit)，代表其他图形界面程序 (例如 vscode)\n主要的系统调用：poll, recvmsg, writev strace xedit 图形界面程序和 X-Window 服务器按照 X11 协议通信 虚拟机中的 xedit 将 X11 命令通过 ssh (X11 forwarding) 转发到 Host jyy用一个数码管的例子，来把状态机的概念更清晰地表示了\n管道yyds！\n一些小tips\n分屏 Windows Terminal可以用alt shift =/- 来左右/上下分屏，jyy用的是tmux\nterminal可以在explorer地址栏直接输入wt打开，记得配置要选父进程\n扩展阅读：\n介绍一个define的用法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #define REGS_FOREACH(_) _(X) _(Y) #define RUN_LOGIC X1 = !X \u0026amp;\u0026amp; Y; \\ Y1 = !X \u0026amp;\u0026amp; !Y; #define DEFINE(X) static int X, X##1; #define UPDATE(X) X = X##1; #define PRINT(X) printf(#X \u0026#34; = %d; \u0026#34;, X); int main() { REGS_FOREACH(DEFINE); while (1) { // clock RUN_LOGIC; REGS_FOREACH(PRINT); REGS_FOREACH(UPDATE); putchar(\u0026#39;\\n\u0026#39;); sleep(1); } } 使用gcc -E展开\n1 2 3 4 5 6 7 8 9 int main() { static int X, X1; static int Y, Y1;; while (1) { X1 = !X \u0026amp;\u0026amp; Y; Y1 = !X \u0026amp;\u0026amp; !Y;; printf(\u0026#34;X\u0026#34; \u0026#34; = %d; \u0026#34;, X); printf(\u0026#34;Y\u0026#34; \u0026#34; = %d; \u0026#34;, Y);; X = X1; Y = Y1;; putchar(\u0026#39;\\n\u0026#39;); sleep(1); } } #define t(func) func(x) func(y)，遇到t(abs)展开以后变成 abs(x) abs(y)\n##是连接操作符\n什么意思呢\n1 2 3 #define Conn(x,y) x##y #define ToChar(x) #@x #define ToString(x) #x 表示x连接y\n1 2 3 4 int n = Conn(123,456); ==\u0026gt; int n=123456; char* str = Conn(\u0026#34;asdf\u0026#34;, \u0026#34;adf\u0026#34;); ==\u0026gt; char* str = \u0026#34;asdfadf\u0026#34;; ","date":"2022-06-20T22:32:41+08:00","permalink":"https://junling.li/posts/os-jyy-2/","section":"posts","tags":null,"title":"操作系统-jyy-2"},{"categories":null,"contents":"看了jyy的os录播，就觉得以前从来没有人这么上过cs的课，正常的课都是老师放这ppt在讲，从操作系统的概念讲到线程和进程管理，从分页讲到文件系统。\n但这个老师开着terminal狂敲，超6的vim操作，无敌的手速。\n最后慢慢告诉你，源码之下，了无秘密。一切行为都是确定的，可预测的状态机转换，你也可以按照你的想法打造你自己的os，这就很有意思了。\n学完你将懂得：\n如何创造出一个没有任何依赖的程序 如何看懂经典xv6的代码 如何查看文档 希望这一系列的笔记可以在内容充实的基础上，尽可能少的原封不动搬运Slides上的内容。\n今天在看13讲，又有一些感触。我们学好操作系统，另一个很重要的心态就是回到上世纪90年代，回到Linus写操作系统时。作为一个拓荒者，为仅有的系统调用添加东西。比如让多个任务执行起来，让两个进程能通信，在内存不够的时候操作系统能跑起来。\n想到这些的解决方案其实并不复杂，但最终只有好的idea活好最后，大家互相借鉴。\n在GUI前的世界有无数的宝藏。有无数经典的设计。他们奠定了现代计算机的基础。\n15讲，看得出jyy准备了很多小trick\n教育不仅仅是\u0026quot;filling of a pail\u0026quot;，更要\u0026quot;lighting of a fire\u0026quot;\n","date":"2022-06-15T22:32:41+08:00","permalink":"https://junling.li/posts/os-jyy-1/","section":"posts","tags":null,"title":"操作系统-jyy-1"},{"categories":null,"contents":" 语义分析semantic analyzer\n类型检查\n自动类型转换\n中间代码生成\n代码优化\n代码生成\n符号表管理\n将多个步骤合并成趟pass\n面向对象主要思想：\n数据抽象\n特性的继承\n针对计算机体系结构的优化\n并行 指令集的并行\n内存层次结构 x86体系虽具有CISC指令集，但这个处理器本身实现中使用了很多为RISC机器发展得到的思想，使用高性能x86机器的最有效的方法是仅使用它的简单指令\n程序翻译\n二进制翻译 将一个机器的二进制代码翻译成另一个机器的二进制代码\n比如Rosstta和Loongarch\n硬件合成 1.6 程序语言基础 静态和动态的区别 编译时刻决定：静态策略 static 运行时决定：动态策略\nJava中static的例子。\n变量是用于存放数据值的某个内存位置的名字。这里static指的并不是变量的作用域，而是编译器确定用于存放被声明变量的内存位置的能力。比如public static int x使得\n成为一个类变量，也就是说不管创建多少个这个类对象，只存在一个这个x的拷贝。如果没有这个static声明，那么这个类的每个对象都有自己存放x的位置，编译器无法在运行时预先确定所有这些位置。 即变量和值的关联是是随着位置改变的。\n1.6.3 静态作用域和块结构 c语言提供块结构来限制作用域\n1.6.4 显示访问控制 public private protected可以由子类访问\n1.6.5 动态作用域 这里给了一个宏的例子\n1.6.6 参数传递机制 本节将讨论实在参数（调用过程中使用的参数）和形式参数（在过程中使用的参数）关联起来的。\n值调用 相当于传一个拷贝 引用调用 传递一个引用（指针）使得可以改变对象的值。Java中可能一个对象很大，拷贝的代价是高昂额，Java在解决数组，字符串和其他对象的参数传递问题的方法仅仅是复制这些对象的引用 名调用 algol 60 1.6.7 别名 alias\n2 一个简单的语法制导翻译器 2.1引言 在2.2给出一个广泛使用的方法来描述语法：上下文无关文法或BNF(Backus-Naur)范式. 在2.3节中，将介绍一种面向文法的翻译技术，即语法制导翻译syntax-directed translation. 语法扫描将在2.4节中介绍 2.5节将给出从中缀翻译到后缀表达式，只考虑加减号分割的数位序列。 2.6节介绍词法单元（由多个字符组成的标识符） 2.8节将介绍一个构造语法树的方法 2.2 语法定义 一个例子：if(expr) statement else statement\n我们用stmt代表语句stmt -\u0026gt; if (expr) stmt else stmt 箭头可以读有如下形式，这样的规则成为产生式（production），向if被成为终结符 terminal\n像expr和stmt这样的变量表示终结符号序列，被称为非终结符nonterminal\n2.2.1文法定义 一个上下文无关文法由下面四个元素组成\n一个终结符号集合，有时又称“词法单元”，终结符号是该文法所定义的语言的基本符号的集合。 一个非终结符号集合，它们有时又称“语法变量”，每个非终结符号表示一个终结符号串的集合 一个产生式集合，其中每一个产生式包括一个称为产生式头部的非终结符号，一个箭头，和一个称为产生式体的由终结符号及非终结符号组成的序列。产生式主要用来表示某个构造的某种书写形式。 指定一个非终结符号为开始符号 数字，+，-，while都是终结符号。比如9-5+7这个例子，两个数位之间必须出现+或-，我们把这样的表达式称为“由+，-号分隔的数位序列” 此文法的产生式包括：\nlist-\u0026gt;list+digit list-\u0026gt;list-digit list-\u0026gt;digit digit-\u0026gt;0|1|2|3|4|5|6|7|8|9\n以非终结符号list为头部的三个产生式可以等价得组合为：\nlist-\u0026gt;list+digit|list-digit|digit 根据我们的习惯，该文法的终结符号包括以下符号： + - 1 2 3 4 5 6 7 8 9\n该文法的非终结符号是斜体名字list和digit。因为list的产生式首先被列出，所以我们知道list是该文法的开始符号。 如果某个nonterminal是某个productive的头部，我们就说该产生式是该nontermial的产生式。 一个终结符号串是由0个或多个\n第二章 数据类型 数据类型实质上是对存储器中所存储的数据进行的抽象，它包含了一组值的集合和一组操作。\n2.2 内部类型 一、特点\n内部类型反映了基本的硬件特性 内部类型标识共用某些操作的数据对象的抽象表示（整型表示能实现+- */ 等定点操作的数据对象的集合） 二、内部类型的优越性 基本表示的不可见性 基本位串如35+9=34的基本表示为00011001+00001001=00100010 优点： 导致不同的程序设计风格 可写性 可读性 可修改性 编译时能检查变量使用的正确性 进行静态编译检查，如非法运算，形实参类型匹配 编译时可以确定无二义性的操作 多态 精度控制 2.3 用户定义类型 1.笛卡尔积 N个集合相乘，每一个集合取1个 在COBOL和PASCAL 称为记录 ALGOL 称为结构\n2. 有限映射 在高级语言中通常体现为数组构造，值域由下标选择 编译时绑定 ：静态数组 对象建立时绑定：动态数组 对象处理时绑定\n3. 序列 串是众所周知的序列，其成分类型为字符，顺序文件的思路也来自序列的概念 串操作一般有4组 连接、首项选取、尾项选取、子串\n4. 递归 如果数据类型T包含属于同一类型T 的成分，那么类型T称为递归类型 指针是建议递归数据对象的重要手段 单链表、二叉树、树\n5. 判定或 discriminated union 是一种选择对象结构的机制，规定在两个不同选择对象之间作出适当的选择，每一选择对象结构称为变体Variant\nc和algol中的union联合\nunion不同于struct，union {int a;char b;} u1 表示变量u1是一个union，它的值是int类型的a或char类型的b，sizeof(u1)会得到int\npascal和ada中的变体\n6.幂集 类型T的元素的所有子集的集合，称为幂集 它们的操作是集合的操作，例如联合，与，以及测试某个元素是否在一个集合中\n可以通过以上六种机制定义复杂的数据对象（新的类型) 新的类型可以通过非显式的方式说明\n第三章 语句级控制结构 顺序 顺序运算符;或者begin ... end\n选择 if...else...或者 switch... case\n选择结构会引起二义性\n循环 计数器制导 for\n条件制导while\n单元级控制结构 规定程序单元之间控制流程的机制\n显示调用 调用方式 由调用语句使用被调用单元的名字来进行调用；调用语句将控制转向被调用单元，被调用单元执行完后，将控制返回调用单元； 参数传递：参数的两种绑定方式\n位置绑定 关键字绑定 副作用：对局部环境的修改 第四章 程序语言设计 语言的定义\n语法\n文法\n文法 定义语言语法的形式化规则\n文法分类\n0型文法 短结构文法\n1型文法\n2型文法\n3型文法\n语言的设计 介绍设计高级语言的一般知识和方法\n第五章 编译概述 基本概念：宿主语言\n编写编译器的语言：宿主语言；源语言、目标语言、宿主语言通常是不同的语言\n如果编译器是用源语言编写的，则称该编译程序是自编译的\n词法分析 介绍词法分析的过程\n讨论词法分析器的设计和实现\n介绍实现词法分析器的主要工具：状态转换图\n基本字(关键字)，\n标识符 identifier\n，常数，运算符+-=\u0026lt;\u0026gt;，界符;()\n输出：二元式 符号的种别 符号自身的\u0026lt;token-name,attribute-value\u0026gt;\n对于界符和运算符，一符一种，即每个符号对于一个编码\n基本字可分为一种，也可以一符一种\n标识符一类一种\n第七章 Syntax analysis 自上而下的语法分析\n递归下降分析法与预测分析法\n语法分析器的功能：对经过词法分析得到的符号串，按文法规则进行判断，看它能否构成准确的句子，如果是 不正确的句子，给出准确的错误信息，对正确的句子，给出其语法树syntax tree\n自顶向下，从分析树的顶部向底部构造分析树，可以看成是文法开始符号推导出词串w的过程\n最左推导，总是选择每个句型的最左非终结符进行替换。与之相反的逆过程叫做最右规约。\n最右推导。最左规约。自底向上的分析中，总是采用最左规约的方式，因此把最左规约称为规范规约，最右推导称为规范推导。\n最左推导和最右推导具有唯一性。\n自顶向下通用的分析形式：递归下降分析 但是不一定每次都正确识别（同一非终结符的多个候选式存在共同前缀），因此需要回溯，降低效率。为了避免这个问题，有了预测分析法。 预测分析是递归下降分析技术的一个特例，通过在输入中向前看固定个数（通常为1)符号来选择正确的A-产生式 可以对某些文法构造出向前看k个输入符号的预测分析器，该类文法有时也称为LL(k)文法类\n文法转换 如何改造文法使之适合自顶向下的文法分析 文法的问题：1.需要回溯 2.无限递归\n含有$$A-\u0026gt;A \\alpha$$ 形式产生式的文法是直接左递归的 消除直接左递归$A -\u0026gt; A \\alpha| \\beta$ 按照这种方法，我们可以对如下例子消除直接左递归\nE-\u0026gt;E+T|T 我们将+T看成$\\alpha$ ,T看成$\\beta$ 因此有 E-\u0026gt;TE\u0026rsquo; E\u0026rsquo;-\u0026gt;+TE\u0026rsquo;|$\\epsilon$ 消除左递归是要付出代价的\u0026ndash;引进了一些非终结符和空产生式\n消除间接左递归 这里应该给出一个例子的 E-\u0026gt;E+T|T T-\u0026gt;F|T*F F-\u0026gt;(E)|i\n其消除左递归以后是这样的：\n我们先改写T-\u0026gt;F|T*F T-\u0026gt;FT' T\u0026rsquo;=*FT\u0026rsquo;|$\\epsilon$ 再改写E-\u0026gt;E+T|T E-\u0026gt;TE' E\u0026rsquo;=+TE\u0026rsquo;|$\\epsilon$\n这个例子应该很经典 扩充BNF范式的表达会更加清晰\nE-\u0026gt;T{+T} T-\u0026gt;F{*F} F-\u0026gt;I|(E)\n预测分析的LL(1)文法\nS_ 文法 简单的确定性文法：\n每个产生式的右部都以终结符开始 同一非终结符的各个候选式的首终结符都不同。 比如上面一个ppt中的例子 S_ 文法不包含空产生式 如果文法中包含空产生式，会出现什么问题呢 这个例子没有说清楚，所以也不知道引入follow集解决了什么问题\nSELECT集：表达式的可选集是指 可以用该产生式进行推导时对应的输入符号的集合\nq_文法不允许右部以非终结符开始，所以我们还需要功能更加强大的文法\n串首终结符集，\n串首终结符:串首第一个符号，并且是终结符\nFIRST(\\alpha) FIRST集是针对表达式左边的， Follow集是针对一个非终结符或者终结符的右边可以紧跟着什么，特别地，可以跟着#\n根据FIRST FOLLOW集就可以得到select集\n所以我们要牢记SELECT集的定义： SELECT集：表达式的可选集是指 可以用该产生式进行推导时对应的输入符号的集合\nselect集是针对表达式的，一般说就是表达式左边的FIRST集不含空串；如果直接表达式右边推出空，那遇到什么时可以用这条推出空的表达式呢？则是该表达式左边的Follow集，当紧跟着follow后面的token时，需要空串，这条表达式意味着这直接推没了，这条表达式奉献了自己成就了左式的follow集。 预测分析法 表驱动 下推栈 预测分析表 控制程序\n非LL(1)文法：并非所有文法G都可以被改写成LL(1)文法，即使提取左公因子和消除左递归后，也不是LL(1)文法。 即预测分析表中的某个项有多重入口，此时只能改写文法或者不用预测分析法\n第八章 自下而上的语法分析 算符优先分析法 LR分析法\n核心概念： 短语： $$S^+ -\u0026gt; \\alpha A $$ （句型的）短语： 给定一个句型，其语法分析树中的每一棵子树的边缘称为该句型的一个短语\n直接短语： 如果子树只有父子两代结点，那么这棵子树的边缘成为该句型的一个直接短语\n直接短语一定是某个产生式的右部，产生式的右部不一定是给定句型的直接短语\n句柄：最左直接短语\n算符优先分析法：一种直观、简单、有效的方法，适合于表达式的分析；但不严格按照最左归约进行，不是规范归约。\n算符文法：如果一个文法的任何产生式都不含两个或两个以上的相连的非终结符，且不含$\\epsilon$产生式，则称该文法为算符文法。\n算法优先文法：如果算符文法G的任何两个终结符之间的关系至多只有\u0026lt;,=,\u0026gt;中的一个优先关系，则称该文法为算符优先文法。\n优先关系表：记录文法G中的所有终结符之间的优先关系\n素短语：文法G某句型的一个短语$\\alpha$是素短语，当且仅当它至少含有一个终结符，且除它自身之外不再含更小的素短语； 最左素短语：在具有多个素短语的句型中处于最左边的那个素短语；\nFIRSTVT LASTVT\nLR分析法 第一个难点 LR分析法是一种自下而上的分析方法，其功能强大，适用于一大类文法；它在自左向右扫描输入串的同时，能及时发现输入串的错误，并能准确指出错误的位置。LR的意思是指自左向右扫描，自下而上归约。\nLR分析器主要有两部分组成：一个总控程序和一张分析表；总控程序对所有文法都是一样的，且易于实现。不同文法的LR分析器的不同体现在不同的分析表上。\nLR分析法的种类\nLR(0)分析法 使用LR(0)分析表，基础 SLR分析法 简单，有效，实用 规范LR分析法 分析能力强大 LALR分析法 能力介于2-3之间 规范归约的特点： 归约符号串总是在栈顶； 句柄之后的待入栈符号串总是终结符； 规范句型（由规范推导推出的句型）在符号栈中的符号串是规范句型的前缀；\n必经节点，不需掌握\n优化 局部优化：\n基本块内的优化：\n合并已知量 删除公共子表达式 删除无用赋值 删除死代码 永远不会执行的代码 全局优化有很多种，本节只讨论循环优化 代码外提 强度削弱 删除归纳不变量 必经结点具有如下性质：\n自反性，a的必经结点是它本身 传递性， 反对称性 目标代码生成 三地址码的代码生成方法 x:=y op z mov y,R_i op R_i,z 寄存器分配\n循环中的寄存器分配\n","date":"2022-05-28T18:38:04+08:00","permalink":"https://junling.li/posts/compiler/","section":"posts","tags":null,"title":"Compiler"},{"categories":null,"contents":"第一章 量化设计与分析基础 1.1 引言 86年以前：性能增长主要依赖实现技术的进步\n03年以前，性能增长除了依赖技术的进步以外，还依赖系统结构的革新(RISC,指令级并行ILP与cache)\n04-10年，性能提升手段出现了以下趋势：\nILP=\u0026gt;TLP and DLP 线程级并行和数据级并行 更快的单核处理器=\u0026gt;单芯片多处理器（多核） 隐含在编译器和硬件的硬件级并行技术=\u0026gt;显示的程序级并行 60多年计算机性能提升的两个原因：\n构建计算机的实现技术的发展 集成电路IC、存储部件（包括RAM和DISK）、外部设备 计算机系统结构设计的改进 指令集、cache集成在芯片上、指令级并行技术 RISC特征：运算指令不访存，访存用LOAD/STORE指令 这是区别CISC的重要区别，指令长度不固定和有限的指令数目\n1.2 计算机的分类 1.Flynn\u0026rsquo;s 分类，基于指令和数据流 SISD Single Instruction Single Memory\nSIMD Single Instruction Multiple Data\n在任一时钟周期，所有处理单元执行相同指令，每个处理单元能对不同数据元素进行操作 GPU\nMISD 很少有，多重加密 算法对单个编码信息进行加密\nMIMD 线程级或任务级并行，多核处理器\nFlynn分类是抽象和粗略的\n2.市场分类 个人计算机 桌面计算机 服务器 集群\n嵌入式 低功耗，实时\n1.3 计算机系统结构定义与计算机的设计任务 计算机系统结构的原始概念 由程序员（以机器语言编程的程序员）看见的（计算机）系统属性，即概念性结构和功能行为，以区分数据流动和控制逻辑设计的组成及物理实现。\nThe attributes of a [computing] system as seen by the programmer, i.e., the conceptual structure and functional behavior, as distinct from the organization of the data flows and controls the logic design, and the physical implementation.\n① 主存容量与编址方式(按位、按字节、按字访问等)的确定属于 计算机系统结构。\n② 为达到所定性能价格比，主存速度应多快，在逻辑结构上需采用什么措施(如多体交叉存储等)属于计算机组成。\n③ 主存系统的物理实现，如存储器器件的选定、逻辑电路的设计、微组装技术的选定属于计算机实现。\nAMD Opteron 64与Intel Pentium 4的指令系统相同，即两者的系统结构相同；但内部组成不同，流水线和Cache结构是完全不同的，相同的程序在两个机器上的的运行时间可能不同。\n系列机：80x86到奔腾iii，保持了极好的二进制代码级的向后兼容性。缺点：为了保持软件向后兼容，要求体系结构基本不改变，妨碍了计算机体系结构的发展。\nISA指令集结构：硬件与软件之间的接口 用途：\n开发者与硬件之间的接口 这代芯片与下一代的合同 接口设计 一个好的接口：\n允许有多种实现 用在很多不同的方面 为跟高层提供方便的功能 允许更低层能有效实现 ISA的7个重要特征 ISA的类型：现代通用寄存器结构，早期累加器结构 存储器访问：如按字节访问 寻址方式 操作数类型和大小：8位字符，32位整型数 操作类型：数据传输，算数/逻辑 控制流指令：转移，子程序调用/返回 ISA编码：固定长度，可变长度 计算机系统结构的现代定义 在满足功能、性能和价格目标的条件下，设计、选择和互连硬件部件构成计算机\n系统结构覆盖：\n指令系统设计\n组成\n硬件：计算机的具体实现技术\n1.4 实现技术的趋势 摩尔定律Moore Law\n集成电路逻辑技术\n晶体管密度：增加35% per year Die size：10%-20% per year 每个芯片晶体管数量：40-55%per year 半导体DRAM\n容量：40% per year 访问速度：about 10% per year 磁盘技术\n网络带宽\n性能趋势：带宽改进优于时延\n带宽增加速度和时延平方改进速度成比例\n1.5 集成电路的功耗趋势 功耗对芯片的规模也提出了挑战\n技术挑战：分配功率，散热，避免过热点\n晶体管数量：pentium 4是386的200倍\n两个概念：动态功率：开关晶体管产生的功耗\n静态功率：晶体管在关闭时漏电产生的功耗\n对于多核，每瓦提供更高的性能\n1.6 成本的趋势 影响成本的主要因素：\n时间，随着时间推移产出率不断提高 产量，意味着制造效率提高 商品竞争 1.7 可靠性 可靠性广义上包括可靠性、安全性和可用性\nMTTF平均无故障时间\nMTTR平均修复时间\nMTBF平均失效间隔，两次故障间隔\n提高可靠性的方法：\n冗余：时间冗余和资源冗余\n1.8 测量、报告和总结计算机性能 性能和执行时间互为倒数\nMIPS\n墙钟时间 程序开始执行到结束看钟知道的时间，测量用户感觉到的系统速度\nCPU时间 not waiting for I/O，测量设计者感受到的CPU速度\nCPU时间进一步分为：\n用户CPU时间：花费在用户模式的时间\n系统CPU时间：花费在OS的时间\n吞吐量（服务器） 单位时间内完成的工作总量，测量管理员感觉到的系统性能\n常用吞吐量测量：每秒处理的事务数量，如每秒服务的网页数量\n通常改善了响应时间也会改善吞吐量：处理器用更快的型号替换\n只改善吞吐量而不改善响应时间：在一个系统中增加额外的处理器\nMIPS 用相同指令集比较两台机器，MIPS一般是公平的\n选择程序评估机器性能 benchmarks\n不同类型的基准测试程序\nSPEC性能评价 选择一个统一的参考计算机，给出各测试程序在参考机上的执行时间\nSPEC评价指标：SPEC率，Spec Mark采用SPEC率的几何平均值\n1.9 计算机设计的量化原则 利用并行性 并行层次：\n系统级：多线程，多处理器 指令级：流水线，超标量 操作级：并行加法器、组相联Cache、指令部件流水线 局部性原理 时间局部性和空间局部性\n注重经常性事件 简化常用事件\nAmdahl\u0026rsquo;s定律 采用更快的执行方式所获得的系统性能提高，与这种执行方式的使用频率或占总执行时间的比例有关。\n加速比=采用改进措施后计算机的性能/没有改进=没有改进措施时某任务的执行时间/采用改进措施\nCPU性能公式 性能的铁律：要直接测量使用新改进措施的改进时间是困难的\nCPUtime=Instruction count * CPI * Clock cycle time\n1.10 综合：性能和性价比 第二章 指令系统原理与实例 2.2 指令集系统结构的分类 不同指令集系统结构最根本的区别在于处理器内部数据的存储结构不同\n存储结构：堆栈、累加器或一组寄存器，操作数可以显式或隐含指定\n（1）堆栈系统结构中操作数隐含地位于栈顶\n（2）累加器系统结构中的一个隐含操作数就是累加器。\n**（3）通用寄存器结构系统中只能明确地指定操作数，不是寄存器就是存储器地址。\n按照通用寄存器访问方式划分，有两种通用寄存器系统结构的计算机\nregister-memory系统结构，一般指令可以访问存储器 register-register或load-store系统结构，只能通过load和store指令来访问内存 2.3 存储器寻址 我们讨论的所有指令系统都是字节寻址的，都提供了字节，半字，字（32位）寻址\n大端\n小端模式\n对齐\n寻址方式：立即数通常也被认为是一种存储器寻址方式、寄存器不属于存储器寻址，相对寻址\n位移量位13-16位，立即数为16位\n立即寻址常用于：运算类指令、置常数到寄存器指令\n2.4 操作数的类型 操作数的类型如何指定：\n操作数编码\n2.5 指令系统的操作 指令系统有一条共同的规律：使用最多的是一些简单指令。\n所有计算机都提供 算数和逻辑运算、load/store、控制 指令\n2.6 控制流指令 条件转移、跳转、过程调用、过程返回\n一般要指明转移的目标地址：\n过程返回是例外，因为编译器不知道返回的地址\nPC相对寻址 使用基于PC的位移量来指定目标地址\n优点：\n目标指令与当前指令离得不远，使用相对偏移地址可以缩减指令长度 可以载入主存任意位置，与位置无关，对于执行时才链接的程序可以减少工作量 寄存器间接跳转 编译时不知道目标位置，根据寄存器的值跳转\n过程调用 保存子程序使用的寄存器：调用者保存和被调用者保存\n如果两个不同的过程方法都要访问相同的全局变量，则必须使用调用者保存方法\n8086中断处理子程序：调用者保存\n2.7 指令系统的编码 需要在以下因素中找到一个最佳平衡点：\n尽可能多的寄存器和寻址方式 寄存器字段、寻址方式字段尽量少，以缩短指令长度 指令长度易于流水线处理 三种常见编码方式：\n变长 80x86 最少的位数表述程序，译码复杂，不适合流水线 定长 arm.mips,powerpc 译码简单，适合流水线，代码量大，执行性能高 混合编码 2.8 编译器的角色 编译器功能：将高级、抽象表示方式逐步转换成低级表示形式，最终达到机器目标指令代码\n第三章 流水线 3.1 流水线的基本概念 3.1.1 什么是流水线 利用指令之间的并行性，实现多条指令重叠执行的技术。流水线是实现更快的的CPU的基本和关键技术 不仅是实现cpu，12级流水线用于几何变换的GPU 术语：机器周期（流水线周期）每个流水线周期从指令流水线流出一条指令。一般是一个时钟周期（有时是两个时钟周期） 吞吐量：单位时间从流水线流出的指令\n我的理解：段数越多，加速越强\n流水线特点 段间有流水线寄存器 流水段之间采用同步时钟控制 流水线是开发串行指令流中并行性的一种实现技术\n为什么采用流水线 减少CPUtime 改进吞吐率 改进资源利用率 为什么不开发50段流水线 有些操作不能分为更细的逻辑实现\n流水线寄存器不是免费的，要占据面积，且有延迟 机器周期\u0026gt;锁存器延迟+时钟偏移\n流水线段数实例： 奔腾3：正在执行的指令超过20条 高ipc\n太多的段数： 非常复杂 处理正在执行指令之间的相关 控制逻辑很大 简单指令执行时间过长\n3.1.2 RISC 指令系统特点 参加运算的数据来自寄存器，结果也写入寄存器。寄存器为 32、64位 访存只有load和store指令 指令的类型较少，所有指令长度相同 不同指令执行的时钟周期数差别不大 这种结构可以有效简化流水线的实现 3.1.3 非流水线下RISC指令系统的实现 假定指令系统是MIPS的 一个定点子集 load、store指令：lw r1,10(r2) ALU指令: add r1,r2,r3 转移指令: beqz r1,lop\n5个周期\nIF Instruction fetch cycle ID Instruction decode 译码+读寄存器+符号扩展 EX Execution/effective address 计算地址/运算/branch做z=1 MEM 读取/写入数据寄存器 WB Wirte-Back 写结果到寄存器堆 注意：branch和store指令花费4个周期 如果我们将branch的条件判断提前到ID，则branch就只占2个周期，store和ALU指令占4周期，只有load指令占5周期\n改进硬件冗余：ALU可以共享，数据和指令寄存器可以合并，因为访问发生在不同的时钟周期\n3.1.3 经典5段流水线RISC处理器 CPI减少到1，因为平均每个时钟周期发射或完成一条指令，在任意时钟周期，在每个流水段正执行一条指令的部分 理想情况下，性能增加了5倍 流水线如何减少执行时间？ 对比不同串行实现的机器 （一个指令一个周期的机器）流水线减少周期的长度 （每条指令执行用多个时钟周期的机器)流水线减少CPI\n引入流水线后出现的问题 在同一时钟周期不同操作不能使用同一数据通路资源 ：结构冒险 有访问存储器冲突 设指令与数据使用同一存储器\n分离的数据存储器和指令存储器 使用分开的指令cache和数据cache 如果时钟周期不变 流水线存储系统的带宽必须是非流水线的5倍 重新设计寄存器堆资源 允许在一个时钟周期WB段先写，ID段后读\n每个时钟周期完成2个读和一个写 需要提供2个读端口和一个写端口 流水线寄存器必须要引入 保证处在不同段的指令不会相互干扰，任何后面段需要的值必须放在流水线寄存器中，而且复制到后的寄存器中直到不需要为止\n影响流水线性能的因素 延迟\n不平衡\n附加开销：流水线寄存器延迟和时钟偏移\n流水线冒险\n3.2 流水线的主要障碍：冒险 3.2.1 冒险分类与有停顿流水线性能 冒险出现时，避免流水线上有冒险指令执行下一个流水段\n串行执行不会产生冒险 阻碍流水线性能的因素：冒险\n冒险总是可以用停顿解决\n插入停顿 stall\n流水线CPI=理想CPI（一般是1）+平均每条指令停顿的周期数\n3.2.2 结构冒险 两条或多条指令想要使用同一个硬件资源\n多重访问寄存器堆 多重访问存储器 没有或没有充分流水功能部件 解决方法：\n简单插入一个停顿，将降低加速比 在一个时钟周期WB段先写，ID段后写 为什么允许结构冒险 减少成本，完全浮点部件需要很多逻辑门,如果结构冒险不经常发生，则消除冒险的成本就太高\n减少部件延迟\n3.2.3数据冒险 我们可以消除or r8,r1,r9这一行冒险\n方法：让寄存器堆WB段先写，ID段后读\n其他的冒险：停顿消除\n编译器插入nop指令\n增加硬件互锁\nForwarding\n有无Forwarding的比较\n3.2.4 控制冒险 在进入ID段时，转移条件和转移目标地址，不能按时提供给IF段取指令\n控制冒险引起MIPS流水线的性能损失，比数据冒险大得多\n处理控制冒险 4种简单解决方法\n冻结或冲刷流水线（停顿） 预测转移不发生 预测转移发生 转移延迟 注意\n以上任意一种方法都会使硬件固定 后3种方法，编译时会根据硬件机制和转移行为对代码进行调度，以获取最佳性能 冻结或冲刷流水线（停顿） 保持或废除转移指令之后进入流水线的指令，性能损失是固定的，不能跳过软件来减少\n预测转移不发生 未选中：没有任何停顿\n选中：需要重新取目标指令，引起3个stall\n预测转移选中 目标地址需要提前算出来 对于经典5段流水线，性能没有提升\n因此没有任何益处\n转移地址提前计算，目标地址提前到ID段计算，增加一个ALU\n综上，预测对了可以节省时钟周期，预测错了会开始执行错误指令，要修复错误指令到没有真正执行，保证错误指令没有改变机器状态\n转移延迟 将转移计算提前更早。\n撤销功能 如果预测转移是错误的,CPU能将转移延迟槽中的指令转换为一条空操作指令\n能够减少编译器选择有用指令进入转移延迟槽的复杂性\n控制冒险总结 控制冒险比数据冒险引起更大的性能损失\n通常，流水线越深，在时钟周期上转移损失越大\nCPI更高的处理器，会付出更高的转移代价\n预测机制的有效性取决于转移预测的准确性\n2.3 流水线处理机及其设计 2.3.1 流水线处理机的指令系统 ALU操作类型的指令：and,or,add,sub load,store 条件转移 bne,beq branch 一共9种\n指令长度32位，指令存储器和数据存储器的存储单元32位 按字寻址\nALU处理要把\n2.3.2 流水线处理机的数据路径 流水线级 IF ID EXE MEM WB 流水线寄存器\nPC IR ID/EXE EXE/MEM MEM/WB 2.3.3 流水线处理机的控制 有限状态机的硬布线方法 微程序控制方法 用软件解决冒险 运算类和Load、Store指令所需要的控制信号\n一、算术操作和存储器访问控制 例子：很重要\n二、流水线转移指令控制 bne disp , if z ==0 ,PC=PC+disp beq disp , if z==1 ,PC=PC+disp branch disp ,PC=PC+disp\nBTAKEN控制 1:转移发生 0：转移不发生 BTAKEN=branch+bne !z+beq z SST=store SIMM=andi+addi+ori+subi+load+store WZ=and+or+add+sub+andi+ori+addi+subi WMEM= store SLD= load WREG=and+or+add+sub+andi+ori+addi+subi+load ALUOP1=add+addi+sub+subi+load+store ALUOP0=or+ori_sub+subi 相对下一条指令地址转移 nop消除控制冒险\n两个nop\n2.3.4 结构相关及解决方法 2.3.5 数据冒险 由于流水线指令\n解决方法\n编译器插入nop 硬件停顿 互锁 Forwarding 通路 互锁：硬件检测出相关，暂停流水线 增加额外硬件检测出数据相关的情况：在流水线ID级观察指令的寄存器字段，检测是否有“先写后读”冲突，如果有就暂停，没有就继续流水线操作 I2进入ID级，比较ID_rs1 == EXE_rd？或 ID_rs2 == EXE_rd? I3进入ID级，与EXE级I2指令的rd比较同时与MEM级I1指令的rd比较\n上述分析表明，一条指令进入流水线ID级， 检测与前面指令可能有数据相关的基本条件是： （ID_rs1 == EXE_ rd ）+（ID_rs1 == MEM_ rd） + （ID_rs2 == EXE_rd ）+ （ID_rs2 == MEM_rd）\n其他条件 1.EXE级和MEM级指令的WREG信号需参与检测（以区分是写目的寄存器rd，还是store指令中的rd。store使用rd，但不写rd。） 2.ID级指令的源寄存器号rs2与立即数部分重叠，而立即数不会出现相关的。（用操作码区分） 3.ID级的指令不能是转移指令，转移指令不需要判数据相关（但要判断控制相关）。（用操作码区分）\n一条指令的两个源操作数都可能与前面指令的目的操作数相关，因此总的数据相关DEPEN： DEPEN=(ID_rs1= =EXE_rd)(EXE_WREG= =1)(ID_rs1IsReg)+ (ID_rs1= =MEM_rd)(MEM_WREG= =1)(ID_rs1IsReg)+ (ID_rs2= =EXE_rd)(EXE_WREG= =1)(ID_rs2IsReg)+ (ID_rd= =EXE_rd)(EXE_WREG= =1)(store) + (ID_rs2= =MEM_rd)(MEM_WREG= =1)(ID_rs2IsReg)+ (ID_rd= =MEM_rd)(MEM_WREG= =1)(store) 解释: ID_rs1IsReg=and+andi+or+ori+add+addi+sub+subi+load+store ID_rs2IsReg=and+or+add+sub （排除立即数运算指令、load和转移指令）\n(EXE_WREG= =1)表示EXE级指令的rd确实是目的寄存器，排除store指令。 （ID_rs1IsReg）条件是为了排除转移指令。\n为了缩写前面的式子，总的数据相关DEPEN由A_DEPEN 和 B_DEPEN两部分组成：\nDEPEN＝A_DEPEN + B_DEPEN\n内部前推\n5 5.5 第四种缺失代价减少技术 合并写缓冲 方法：用多个字代替一个字\n第五种缺失代价减少技术 牺牲缓存victim cache 牺牲缓存是一个小的全相联cache，它存放几个最近被替换出的块 在发生缺失要访问下一级存储器之前，先检查牺牲cache\n5.6 利用并行技术减少Cache代价缺失率 非阻塞cache减少cache缺失等待 ![[Pasted image 20220505103603.png]]\n编译器控制的预取 需要硬件实现 编译器插入预取指令请求数据 有两种预取方式：\n捆绑预取，请求预取的值直接装入寄存器 非捆绑预取，将数据预取到cache 5.7 命中时间减少技术 在cache索引时避免地址转换 传统物理地址cache存在的问题：地址转换 访问页表，访问内存\n变换旁路缓冲器TLBs 一种快速地址转换，存放最近的页表项\n踪迹cache 踪迹cache：块中是动态指令序列，而不是限制指令在一个静态cache块中。 cache块中包含了由cpu确定的要执行指令的动态踪迹，而不是仅由存储器确定的静态指令序列\n","date":"2022-05-28T18:27:57+08:00","permalink":"https://junling.li/posts/isa/","section":"posts","tags":null,"title":"计算机系统结构笔记"},{"categories":null,"contents":"今天送走了一台j1900主机，上面部署过黑群晖，也花了很久才调教成一个顺手的群晖。 我给群晖的定义是一个更智能的云盘，首要的任务是文件的保存同步和共享。\n而首先需要解决的问题是\n外网访问 在没有公网IP的情况下，我总结了4种方法。\n洗白 frp zerotier 公网ipv6+ddns 云盘 群晖提供了各种方式访问群晖的文件。\nSMB 局域网共享\nWEBDAV 挂载成网盘\nFTP/SFTP 最广泛的文件传输协议\n最近发现的一个很好用的支持多种存储的目录文件列表程序Alist，可以直接使用docker构建\n其他服务 笔记 NoteStation 笔记可以直接从印象笔记转移，是相当不错的功能。也有桌面和手机端的APP，手机端除了有些bug，功能挺全的。\n原本对于笔记的要求就是简单，查看方便，保存100年，加上私密性。Note Station足够了。\n下载 bt，电驴应有尽有。\n百度网盘 可以同步百度网盘，Google网盘啥的，很强大。\nDocker 方便管理各种docker应用，反正就是无限可能。\nChat 私密聊天，吊打微信，多用户，多频道。不过好像没有手机端app\nDrive 同步云盘，手机公测 的新APP可以同步微信聊天记录和文件夹。\nPhoto 手机APP挺稳定的，无论备份多少东西都不会被杀后台，将50G的照片放在群晖上，手机随时查看，属于是我的小米云平替了。\nMovie iPad客户端体验捉急，用了一次就不用了。\n其他的话由于群晖也是在bsd基础上开发的，也可以正常用很多linux-x86的应用，比如gcc,java,node,python,群晖套件也就相当于包管理工具了。\n群晖官方的应用服务的质量良莠不齐，不过可能是我还在dsm6，没有体验过dsm7，有些就一直是老版本。\n手机APP\n群晖助手，这是第三方写的，很好用，更新也很及时。可以直接打开视频，可以用android官方共享接口上传文件。\n官方叫群晖管家，也能凑合用。\n","date":"2022-05-13T19:55:45+08:00","permalink":"https://junling.li/posts/synology/","section":"posts","tags":null,"title":"Synology"},{"categories":null,"contents":"很久以前看过一遍链式前向星 的存图方法，一知半解。最近几天详细学习了一波，感觉非常有用。所以，那就开始吧。 链式前向星自然是链表的方法。它需要构建3个数组，next[],head[],to[] 所有的数据都在这3个数组里面。 每个边都有一个序号，假设我们存储的是有向图嘛，比如由结点1出发，分别指向4，3，2三个结点。我们先找到head[1],它告诉我们1这个结点怎么找寻它指出的第一个结点，head[1]=1给出了一个索引，告诉在to[]数组的第6个位置记录了1结点指向的4to[6]=4:， 然后，我们通过next[]数组找到1结点指向的第二个结点，next[6]=3，告诉我们要访问to数组的第3个，就能找到1结点指向的3 最后，我们通过next[]数组找到1结点指向的第二个结点，next[3]=0，告诉我们要访问to数组的第0个，就能找到1结点指向的2\n1 2 3 4 5 int u=1; for (int i = head[u]; i!=-1; i = nxt[i]) { int v = to[i]; System.out.println(v); } 可以看到head和to数组都记录的是索引，to才记录了指向的结果。 那么，这3个数组是怎么构造的呢？\n1 2 3 4 5 6 //head[]和cnt初始化为-1 void add(int u,int v){ next[++cnt]=head[u]; head[u]=cnt; to[cnt]=v; } cnt是索引，head和next是根据遍历的逆过程来构造的，head后于next更新，且head每次用cnt更新，cnt是next数组的索引值，那么我们知道head[u]，就知道next的第几个存储这上一个head[u]（它之后被cnt更新了，但它没有丢失，它被next存起来了），递归向上查找，最后一个是head是-1，由于他被next替代了，所以最后一个找到的结点next的值是-1\n为了方便，我们看一个例子\n1 2 3 4 5 6 7 add(1,2);// cnt=0 next[0]=-1 head[1]=0 to[0]=2 add(2,4);// cnt=1 next[1]=-1 head[2]=1 to[1]=4 add(3,4);// cnt=2 next[2]=-1 head[3]=2 to[2]=4 add(1,3);// cnt=3 next[3]=0 head[1]=3 to[3]=3 add(4,3);// cnt=4 next[4]=-1 head[4]=4 to[4]=3 add(3,2);// cnt=5 next[5]=2 head[3]=5 to[5]=2 add(1,4);// cnt=6 next[6]=3 head[1]=6 to[6]=4 可以看到，cnt不断增加，一直在前进，因为cnt记录了下标，而to和next每次都更新cnt下标对应的值，head的某个索引值被改写成了cnt。是不是head 的某个索引(也就是起始点)的值恰好是next的索引呢？next的索引到了上一个同样的起始点是那个位置。\n不懂？我们看最后一行，1-\u0026gt;4结点\nadd(1,4);// cnt=6 next[6]=3 head[1]=6 to[6]=4\nhead[1]=6告诉我们next[6]能找到1-\u0026gt;x这个结点，x是多少？next[6]=3，我们最想知道的x答案就隐藏在3这个数里，我们看这一行：\nadd(1,3);// cnt=3 next[3]=0 head[1]=3 to[3]=3，是不是表示1-\u0026gt;3啊，通过next[6]=3我们要跳转到第3行（从0数的第三行），因为第三行to[3]记录着x的答案。\n想知道以1出发还有没有指向其他结点？看next[3]是几嘛，因为next[3]会告诉我们索引值的。\n","date":"2022-04-07T14:06:12+08:00","permalink":"https://junling.li/posts/%E9%93%BE%E5%BC%8F%E5%89%8D%E5%90%91%E6%98%9F/","section":"posts","tags":null,"title":"链式前向星"},{"categories":null,"contents":"这是从去年底就想做的，2021年我的B站收藏夹推荐，一直拖到现在。\n根据某视频网站的数据，某人去年（指2021年）在该平台看过11112个视频，总时长474.3小时，这是一个惊人的数字，如果它每天看10小时，也得花48天才能完成这个任务。\n健康 如何防猝死？\n很多人可能忘记了，去年年初的时候，拼多多买菜员工凌晨一点半下班路上晕倒猝死。然后拼多多公关删帖，禁言封号。今年过年期间，B站审核部门主管工作强度过大，在家没了。\n最近是字节跳动，健身过程中突发不适，没救回来。\n当你陷入内卷却没有力量和勇气反内卷，也请保护好自己\n兔八哥的医学博士】死亡前的征兆是什么？I 猝死前如何正确自救或许能帮上你。\nhttps://www.bilibili.com/video/BV1ti4y1c7nu\n测评 楼斌贺岁档，他真的拆了一辆Model3\n【新春特辑】特斯拉 Model 3 拆解：离100%国产化还有多远 https://www.bilibili.com/video/BV1uK4y1Q78C\n你米的MIX4显然没有达到米粉的预期，但这是你米这一年能拿出最好的作品了。\n【历代小米】不是所有MIX，都叫MIXhttps://www.bilibili.com/video/BV1nf4y1L7tF\n十年前你又是什么样子呢？有没有成长呢？\n引用评论\n看到后面那段话真的蚌埠住了，真的雷布斯这个回馈粉丝我是不可能想到的，我也真的觉得雷布斯确实是个梦想家或者说至少不是个纯粹的资本家，不管小米现在怎么样不好，起码在雷军离开小米前，我会一直对小米保持信心。\n「吴阳」这10年 小米MIX4快速上手体验https://www.bilibili.com/video/BV1kg411L7WK\niPad的昨天今天明天，这也许是最详尽的报告。不知道明天的苹果发布会上有没有新iPad？\n「500小时巨制」未来的iPad是什么样子？答案也许就藏在「过去」 https://www.bilibili.com/video/BV1aL4y1z7GQ\niPhone13 pro 你留不住时间 但别留下遗憾https://www.bilibili.com/video/BV1tg411N79J\n18 款真无线耳机横评，哪个值得买？2021 TWS 耳机选购指南https://www.bilibili.com/video/BV1qp4y187qm\n测评往往有时效性，可能一款产品，过了几个月就不销售了，又有新的产品接替它，比如厉害做的2021年TWS耳机推荐，很详尽，很用心，可能现在就过时了，没有参考价值了。测评这一系列原本我是放在最前面的，后来想想这部分视频很垂直，可能我比较喜欢看，大家就没那么多兴趣看下去，所以就留下了几个有价值的，不那么过时的视频。\n创意 影视飓风 虚拟世界的现实存在，如果真有一座璃月港，你愿意住进去吗？\n虽然Meta投入了110亿到元宇宙的探索，米哈游也发布了元宇宙品牌，但元宇宙还处于Teenager sex的阶段，它究竟是什么，没有人知道。\n爆肝1000小时！我们在公司里建了一座原神璃月港https://www.bilibili.com/video/BV1MK4y1Q7d2\n光影是一种魔法，丙烯是神奇的颜料。\n光 学 隐 形，就是有点费手https://www.bilibili.com/video/BV1u64y1y7AE\n丙烯算什么，牛奶才是最牛逼的。\n**有手在什么墨水都能写？**https://www.bilibili.com/video/BV1v44y1Y7xP\n画得烂不是Pencil的问题，是你的问题。\n**Apple Pencil：那我走？**https://www.bilibili.com/video/BV1Pg411F7eR\n虽然我们人类在摇篮里，但也要看看摇篮外面有多大。\n建造一个真实比例太阳系https://www.bilibili.com/video/BV1gz4y1279o\n全栈工程师，对于稚晖君我只能说nb，B站DIY的天花板。\n**【自制】我造了一台 钢 铁 侠 的 机 械 臂 ！【硬核】**https://www.bilibili.com/video/BV12341117rG\n**【自制】我把自行车做成了 自 动 驾 驶 ！！【硬核】**https://www.bilibili.com/video/BV1fV411x72a\n有这么一群公交党，他们试图乘坐公交，走遍中国的土地。\n合肥到南京全程公交只要24块，详细换乘方案，比高铁便宜太多了https://www.bilibili.com/video/BV1qo4y1X7Pb\n同样有一群绿皮车党，他们愿意做耗时最久的车，花3天的时间从哈尔滨坐到昆明，看着车窗外的景色从白雪皑皑到绿意盎然\n【上集】哈尔滨直达昆明！66小时国内最久列车之一体验https://www.bilibili.com/video/BV1oA411A7rT\nB站数码区巅峰，采访到Tim Cook的何同学，永远是同学的何同学。希望有工作室的何同学能越走越远。\n**【何同学】整理自己的生活（P2附库克采访）**https://www.bilibili.com/video/BV13v411v7Zo\n**【何同学】我做了苹果放弃的产品\u0026hellip;**https://www.bilibili.com/video/BV19v411M7Rs\n【何同学】永远是同学https://www.bilibili.com/video/BV1764y167Lp\n【何同学】这视频能让你戒手机https://www.bilibili.com/video/BV1ev411x7en\n观点 \u0026amp;\u0026amp; 体验 只赚富人的钱，不愧是李楠。当然这一期的观点也很有意思，什么是好的产品，李楠很会讲故事。\n引用一个评论的总结：\n为什么现在开箱视频这么火，就像视频说的，一个产品的开箱过程，就是你购买这个产品到最后抛弃这个产品过程中快乐情绪的巅峰，随着使用时间越来越长那种快感就会逐渐消失。直到下一代产品发布，不停诱惑着你再来一次开箱。 为了不陷入这种陷阱，我们其实可以选择自己和产品一起慢慢变好。\n**一万块的键盘，还是反消费主义产品？**https://www.bilibili.com/video/BV1JL4y1E7B1\n罗老师带你探寻人生的意义。\n**【罗翔】既然每个人都要死去，那活着的意义是什么呢？**https://www.bilibili.com/video/BV1uR4y1n7hz\n吸收了risc-v想要发展loongarch架构，并兼容x86和arm，龙芯的道路注定是最艰辛，当然胡伟武的采访也足够鼓舞人心。龙芯对于中国来说，首要是解决国产自主可控的问题，可以看到龙芯目前投入尽力做的是指令集的兼容，并完成主要编译器的jvm，gcc的稳定运行，靠兼容win32应用完成生态构建，剩下的就靠漫长的工艺追赶上牙膏厂和amd了。\n对话胡伟武（上）龙芯能走到今天，核心是解决了为谁做芯片的问题https://www.bilibili.com/video/BV13i4y1o7nb\n**5天脱离智能手机，我的生活发生了什么改变？**https://www.bilibili.com/video/BV1tA41157df\n考试周圣经，冰红茶热带风味，泸溪河，一章没看，绿了吧唧的，比肩马大师的现象级精品\n考试周破防原作者已删除https://www.bilibili.com/video/BV1XM4y1c7Jp\n算法 10分钟彻底搞懂dp也许是标题党，但10分钟理解dp的理念还是够了，这个例子在力扣第300题，最长递增子序列。\n10分钟彻底搞懂“动态规划”算法https://www.bilibili.com/video/BV1AB4y1w7eT\n最浅显易懂的 PyTorch 深度学习入门https://www.bilibili.com/video/BV1oq4y1E7Vd\n当时看觉得很有意思，wtf也让这块代码成为经典，这几天加入xdu才发现，up主离我这么近\n【熟肉】Nemean - 《雷神之锤III》中使用的平方根倒数速算法https://www.bilibili.com/video/BV1v64y1i7KH\n这人类瑰宝一样的代码就被copilot拿走了\n用AI写代码是什么样的体验？亲测GitHub Copilothttps://www.bilibili.com/video/BV1dv411E7VL\n我记得今年年初四，我的copilot内测通过了，只需打出// fast inverse square root\ncopilot就会帮你自动补全这个经典算法，包括 那句wtf\n原本这里还有不少cs学习资料的，捡了几个10分钟以内，比较有趣的给大家推荐，人类智慧的精妙，\n短片 年度最棒的短片，播放量不高，希望我们都能珍惜当下，珍惜爱我们和我们深爱着的人。\n**2021江南大学毕设动画《壹天》**https://www.bilibili.com/video/BV1kf4y1h7QR\nReno5的广告片，地球上的人口有70亿 上天不偏不倚替我选中了你\n**认识你之前，我一直以为我是世界上的独一无二。认识你之后，我才发现原来好朋友一起，才拥有独一无二的世界。**https://www.bilibili.com/video/BV1by4y1a7Ep\n同样也是oppo广告片\n**她每一次笑，我都感觉世界好像比上一秒更可爱了一点，我想，这大概就是喜欢了吧。**https://www.bilibili.com/video/BV1Xh411e7Rd\n**人生初次表白｜vlog.夏天才刚刚开始！**https://www.bilibili.com/video/BV1ko4y1X7k1\n**这一年的夏，我们不说再见。**https://www.bilibili.com/video/BV1Th411Y7nM\n剩下是两个Testing-Mobile Director(简称TMD)的视频，专业团队玩的业余。这一期视频的故事原型我想大家都看过，但是拍出来的感觉又是不一样的。\n**你的一点善意，对我是活下去的希望和勇气（小米手机电影大赛入围影片）**https://www.bilibili.com/video/BV1zb4y1r7SP\n以及这篇视频的幕后\n【TMD-20】人类高质量 手机摄影——为什么你的手机拍得像坨屎，我拍得像ARRIhttps://www.bilibili.com/video/BV15M4y1L73A\n我发现这里的短片有一半都是手机拍的耶，\n记录 谭乔回应《谭谈交通》有剧本争议：我有时都怀疑这是不是安排的托https://www.bilibili.com/video/BV1ih411v7hT\n**谭sir首谈《谭谈交通》停播的真实原因。“我要是圆滑，我早就在天空自由翱翔了。”【破圈相对论Ep01】**https://www.bilibili.com/video/BV1av411P7yH\n卫生扣分写检讨的巅峰之作https://www.bilibili.com/video/BV1Df4y1g7x9\n娱乐至死\n长沙黄兴路午夜狠活一条街，叹为观止https://www.bilibili.com/video/BV1EQ4y197Ew\n号称永不打工的精神领袖，如今在打两份工https://www.bilibili.com/video/BV1QS4y1K7Dh\n韩国下岗女团成员在中国讨生活，讲诉韩国娱乐圈内幕，看完倍感辛酸https://www.bilibili.com/video/BV1sf4y1872K\n歌 2021收藏了好多歌，在B站先听这么多。\n别再吹拂我吧 我已垂老天涯 *【原创民谣】*https://www.bilibili.com/video/BV1jv411u73P\n**知觉 ** *【双怡原创】*https://www.bilibili.com/video/BV12f4y1b72v\n了解我的人都知道，我很喜欢ChiliChill这一首《让风告诉你》\n让风告诉你 *【原神拜年纪】*https://www.bilibili.com/video/BV18X4y1N7Yh\n总有人天赋顶的上别人一辈子的努力\n三十二段留言 15岁啦！用32个粉丝评论写了一首民谣歌曲https://www.bilibili.com/video/BV1NV411B7xj\n你曾是少年 DNA动了！又想起那个夏天和你一起冲浪的日子https://www.bilibili.com/video/BV1kM4y157rC\n明明就 *女声钢琴弹唱（cover 周杰伦）*https://www.bilibili.com/video/BV1S3411y7iJ\nasoul高雅二创，《枝江》，虽然不是特别喜欢asoul这个企划，也不看好asoul的未来，但是嘉心糖这个群体还是太有意思了。互联网喜欢低成本自传播的内容，希望大家能习惯嘉心糖这种发病宣告主权的方式。\n枝江 【A-SOUL】原创曲——“她们的故事慢慢讲”\n永不失联的爱 cover 这个女人还是这么爱在夜里唱歌https://www.bilibili.com/video/BV1Ei4y1P719\nCandy Cane Lane 宝藏圣诞歌曲！激情翻唱https://www.bilibili.com/video/BV1xF411B7re\n这世界那么多人 没想到！超甜萌妹也能深情翻唱Cover：莫文蔚https://www.bilibili.com/video/BV15b4y127vr\n教主的两首歌，为教主的才华落泪。\n石头歌 *【三无】【专辑曲】*https://www.bilibili.com/video/BV1nP4y1W7dr\n**我没有歌能给你听 ** 洛天依 乐正绫 原创https://www.bilibili.com/video/BV1WR4y147x4\n假如爱有天意 大提琴cover：李健丨当天边那颗星出现 你可知我又开始想念https://www.bilibili.com/video/BV1Gg41177Dg\n枫 大提琴 cover：周杰伦丨缓缓飘落的枫叶像思念https://www.bilibili.com/video/BV1Vq4y1Z7RU\n第二圆舞曲 肖斯塔科维奇 来跟我一起跳支舞吧https://www.bilibili.com/video/BV1iT4y1P7ba\n睡前消息 作为中文互联网仅存的键政栏目，睡前消息尽最大的努力让普通人了解社会是如何运转的。督公虽然有时候太过于理想化，但大多数时候所提出的观点都是很有意义的。睡前消息的存在，就是它存在的意义。\n【睡前消息235】春节求财：马前卒工作室的赚钱宣言https://www.bilibili.com/video/BV1J54y1Y7Xn\n高三可能多多少少沾点魔怔，但人在不同阶段相信的也会不同。当然魔怔的根本原因，还是教育资源分配的问题。\n【睡前消息285】高考过后，请放下“拱白菜”的心思 2021-06-08https://www.bilibili.com/video/BV1Qq4y1575V\n网络游戏是不是新时代的鸦片？谁能给出答案？\n【睡前消息314】 “精神鸦片”问题，影响全人类的未来 2021-08-15https://www.bilibili.com/video/BV15v411T7ym\n双减政策和高考下人民需要什么样的教育？或许值得每一个人思考。以下是我的答案：\n这一期，也算是开大的典范了，从贵阳家校矛盾，谈到两类人内卷和反内卷的教育方式。引出家委会权力过大，行为越界的问题。再到分析阶级分化，既得利益者和中产对教育的看法不同，谈到什么才是人民满意的教育，以及如何做到全社会满意的教育。最后大招社会化抚养，环环相扣，中途不忘抨击房价和中医。\n再过10年，我也会深刻面对这个问题，面对阶级滑落的风险，期望孩子不输在起跑线上，我会怎么做。想必会随大流，兴趣班，学前班，教他应试技巧，卷成绩，卷学历，卷排名。而我的孩子，也必将比我更早承受这种竞争压力，开始20年的学习长跑。最后，工作，成为社会的螺丝钉。或者考公，或者run。我们无时无刻不被这种rule束缚着，包括我们的孩子。也就是说，我们想要立足之地，不可避免接受规则。这么看，个人的观点和view是无关紧要的事情，社会需要什么人，我们就是什么人。你对事物的不同的看法，但你的地位和努力不足以改变这种不同。比如贵阳妞妞的父母不能改变其他家长要求的多布置作业，无论他们多有权势，都无法改变班级内卷的结果，这就是社会的力量，基于多数人的共识达成的民主，家委会不是因为有强势个体所以能驱逐妞妞，而是因为没有人和妞妞家长达成共识（没有人能承受素质教育阶级滑落的风险，所以没有人敢陪妞妞不写作业），所以被驱逐，这其中，班主任面对两方的冲突，作为抉择教育方式的人，必然会基于大多数人的共识，至于因材施教，很难很难。\n【睡前消息360】中产阶级管教育，家委会驱逐小学生 2021-11-30 https://www.bilibili.com/video/BV1644y1h7aA\n答案年终秀\n“不要让《睡前消息》这种这种简陋的节目在中国互联网上还能占这么大的市场”\n【睡前消息368】寻找初心，新青年的“6+1”攻略 2021-12-19https://www.bilibili.com/video/BV1Va411k7a5\n导演小策 过去一年，小策离开了朱一旦，做了很多尝试，梦游江湖，小短片，vlog，终于在《广场往事》中找到感觉，希望小策早日实现拍长篇的梦想。小策也是我期期必看的up\n**【广场往事】《飞驰余生》，66岁大爷玩命上演，速度与激情。**https://www.bilibili.com/video/BV1N44y1B7Se\n**【广场往事】《妇仇者联盟》：枪在手，跟鹅走！**https://www.bilibili.com/video/BV1Rq4y1n7CR\n**【广场往事】谁 还 没 个 明 星 朋 友 ！**https://www.bilibili.com/video/BV1WZ4y1D79s\n**【广场往事】我不想成为，这样的广场舞人！**https://www.bilibili.com/video/BV1E64y1177C\n**【广场往事】欲 戴 皇 冠 ，必 承 其 重 ！**https://www.bilibili.com/video/BV1yL4y1B7JF\n**【广场往事】凤 凰 ，涅 槃 吧 ！**https://www.bilibili.com/video/BV1cL411V7Zr\n**这个男孩，60年前，错过了我姥姥！**https://www.bilibili.com/video/BV1qr4y1U7s4\n跨界区up主LKS，在不垂直的路上越走越远。如果你想破圈看看不一样类型的视频，LKS的这一期推荐蛮有意思。\n**这也有人做？你可能没看过的小众视频类型大赏！**https://www.bilibili.com/video/BV1W34y1o7BQ\n尬聊，咱也是专业的\n**找两个互不认识的UP主，让他们强行聊天会有多尬？【尬聊01】**https://www.bilibili.com/video/BV1uL411H7jA\n有人出生在罗马，有人出生就是牛马，欢迎来到大猛子劝学小课堂。\n**《猛子劝学》**https://www.bilibili.com/video/av634028658\n3千元肯定招不来一名农民工但肯定能招来一名大学实习生https://www.bilibili.com/video/BV1UQ4y1q7nb\n**该提桶跑路吗？一个视频讲透土木类所有专业/行业！**https://www.bilibili.com/video/BV1f34y167Uo\n全职up主逐渐成为主流，靠着一个自媒体频道足够养活一个公司，我们见证了B站这个UCG平台的成长\n无论你是何同学还是大猛子，只要你能创造出有价值的内容，就能获得流量。B站的内容生态还是很活跃的，从另一个角度说，也是很卷的。收益的大头还是被头部up主拿去了，专业团队才能活的下来。\n其实还有一个类别我很喜欢，就是up回忆自己的成长经历，这种就非常真诚，几乎每个up的起步都是艰辛的，能坚持到最后并取得成功的，凤毛麟角。可能哪天和合伙人分家了，塌房了，被冲了。爱玩客，TESTV，爱否，很多我曾经喜欢的频道都没了。如何体面的活下去，如何让公司靠着视频收益顺利运转下去，是这个行业的难题。还记得当时王自如和老罗的骂战，会不会是那个时候，王自如就开始放弃自媒体这条路了呢，以至于卖掉了zealer。\n我看不到视频背后的艰难抉择，看不到up主熬着夜剪视频的艰辛，\n我只能满怀虔诚的希望，我投出的每一个硬币，都代表了我选择什么样的视频留下来让更多人看到，而不是湮灭在时间长河中。\n从另一个方面来说，\nGreat stories can change the world. Great stories can move us and inspire us. They can surprise us and challenge our assumptions. We feel we could contribute something important to our culture and to society through great storytelling.\n很多年前的一个苹果特别活动，上\n如果，如果我们每个人都有力量发声，相比文字的力量，视频的力量会更能打动人\n最后，我还想多说几句，我有时候翻别人的关注列表，发现他关注的几百个人和我没有一个相同的，那他每天看什么视频呢？他关注的up都是怎么样的人呢？互联网给创作者们极大的方便，知识分享，唱歌，宅舞，整活，生产者们企图用视频填满观众的空闲时间。同样，人们越来越发现一个话筒的重要性，越来越多的人成为创作者。我们无力去关注它们所有的内容，我甚至连关注者的视频都看不完。\n我们已经生活在一个资源极度冗余的年代，如果自己不能做出筛选，必然会被巨量的信息淹没。\n随着推荐算法的应用，很多时候我们都看着平台推荐的视频，或者只看喜欢的up主的视频。结果陷入了信息茧房\n我希望能给大家推荐我在2021年最喜欢的100个视频，这是我精心筛选过的，希望它们能对你有意义。\n前后写了几个星期，也增添了十几个视频，去除了一些不便于展示的视频。受限于时间，在写这篇推荐的时候没有每一个视频都详细复审一遍，可能有些内容就看了个标题就开始写推荐了。一定错过了不少细节，忽略了不少创作者留下的小心思，没能在推荐里说，\n","date":"2022-03-08T01:03:42+08:00","permalink":"https://junling.li/life/2021%E7%99%BE%E5%A4%A7bilibili/","section":"life","tags":[],"title":"Best Bilibili Video of 2021"},{"categories":null,"contents":"使用zerotier建立局域网 最近不知道怎么了，某米ac2100的ipv6防火墙开不了，导致只能用frps去连接群晖，太慢了。详情点击这里\n于是又想尝试zerotie\n群晖上的操作比较简单，官网上说的很详细\nhttps://docs.zerotier.com/devices/synology/\n1.首先添加虚拟网卡 Write script to /usr/local/etc/rc.d/tun.sh that will setup /dev/net/tun on startup\necho -e '#!/bin/sh -e \\ninsmod /lib/modules/tun.ko' \u0026gt; /usr/local/etc/rc.d/tun.sh\nSet executable permissions on script\nchmod a+x /usr/local/etc/rc.d/tun.sh\nRun script once to create a TUN\n1 /usr/local/etc/rc.d/tun.sh Check for the TUN\n1 2 3 ls /dev/net/tun /dev/net/tun If you experience trouble getting the TUN to work check out\n扩展阅读：tun是什么？https://segmentfault.com/a/1190000009249039\n2.去群晖官方套件中心添加docker 3.启动容器 Make directory to store ZeroTier\u0026rsquo;s identity and config\n1 mkdir /var/lib/zerotier-one Make Docker container called zt (Repo: zerotier/zerotier-synology)\n1 2 3 4 5 6 7 8 docker run -d \\ --name zt \\ --restart=always \\ --device=/dev/net/tun \\ --net=host \\ --cap-add=NET_ADMIN \\ --cap-add=SYS_ADMIN \\ -v /var/lib/zerotier-one:/var/lib/zerotier-one zerotier/zerotier-synology:latest 4.添加网络 Previous versions of our package contained a GUI, however this is no longer the case and it is for the better. The CLI can be used as follows:\nView node status\ndocker exec -it zt zerotier-cli status Join your network\ndocker exec -it zt zerotier-cli join 你的网络id Authorize the NAS on your network. Then view the network status:\ndocker exec -it zt zerotier-cli listnetworks Show running container (optional)\ndocker ps Enter the container (optional)\ndocker exec -it zt bash\nj接下来就是让win本加入这个网络，官网下载安装包，点join network就行了\n在官网就能看到两个设备的ip了，\n速度也不是很快，300KBps吧\n","date":"2022-02-23T15:50:21+08:00","permalink":"https://junling.li/posts/zerotier/","section":"posts","tags":null,"title":"Zerotier"},{"categories":null,"contents":"《节奏把控对于创业的重要性》 李想\nhttps://weibo.com/1243861097/Lb1uEq20b?type=comment\n这个节奏当然不是带节奏，而是不同阶段的规律和把控。我们大致可以把创业分成三个大的阶段：\n一、从0-1的验证期；\n二、从1-10的成长期；\n三、从10-100的成熟期。\n这三个阶段对于能力和资源的要求都是完全不同的，能力、资源与阶段错配，往往是企业失败的根源，节奏把控好是对于创业者和一号位最核心的一个能力要求。\n【从0-1的验证期】 验证期标志性的特征是，从零开始到你能够吃到你所在的细分领域3%以上的市场分额，你具备一个显著的特长，能够成为行业的天花板。\n在这个阶段，企业是没有真正的竞争对手的，主要是和自身的成长速度在竞争，因为领先者根本不会把你放在视野里。比如我们三家2021年都做到9万多辆，其实在中国乘用车行业领先者那里这个量完全可以忽略不计。\n这个阶段，对于企业而言，最重要的是充分发挥自己的特长，这个特长容易被原有的领先者忽视，但是对于用户是有价值的。比如特斯拉早期的三电系统能力，比如蔚来汽车的用户服务能力，比如小鹏汽车的智能驾驶能力，比如理想汽车面对家庭用户群体的产品能力，比如汽车之家早期的汽车产品库能力。虽然很小，但是有巨大的用户价值，而且可以做到在这个特长下的行业天花板。\n这个阶段，对于管理者而言，最重要的同样是发挥自己的特长，尤其是专家型的能力特长，每一个管理者必须深入到业务的每一个细节中去，抓大不放小。这个阶段，企业的综合管理者越少越好，每一个管理者最好都是自己领域的技术专家或业务专家。\n无论是企业还是管理者，特长并不是打开什么任督二脉，而是扎扎实实的投入，集中一个火力点，十倍于他人的人才和资源的投入，没有任何捷径可走。如果你的兜里有一分钱，你的招聘里能多一个人，就把这些钱和人投入到企业的特长和对应的专家上去。你的钱、你的人、你的特长必须是诚实一致的，脑子里想的，嘴巴里说的，实际在干的，金钱投入的，都是一致的。千万不要搞什么试一试，要么全力以赴做成，要么早点去死。\n我个人认为我们造车三傻是2021年完成了从0-1的验证期，大家各自在自己细分市场吃到了3%左右的市场份额，比如理想汽车在25-50万的乘用车里吃到了3%，也成为了家庭用户特点最鲜明的中大型SUV销量的第一名，验证了面向这个用户群的产品力。特斯拉是通过Model S和Model X验证了从0-1阶段（Roadster是0.1的三电验证阶段），并用Model 3和Model Y迈向从1-10的阶段。特斯拉的从0-1阶段创立了三电系统的行业天花板，并把电动车和特斯拉几乎画上了等号。从1-10阶段才开始搞自动驾驶的，Elon作为连续创业者，节奏把控能力几乎无敌。\n中国过去的六七年，智能电动车的创业者很多，300多家剩下不到10家，三个互联网的外行成为了新势力里销量跑在前面的，而不是那些汽车行业的高管创业者，最核心的原因是李斌、何小鹏、李想作为连续创业者，对于节奏的把控和心力。这一轮失败的最惨的创业者往往是跨国汽车企业的高管，他们大多上来就想做从10-100的阶段，我们经常说的一句话就是：没有苹果的命（人和资源），得了苹果的病（胡乱招人和花钱）。\n很多行业领先者在行业转型和技术转型的时候之所以不成功，也是因为不愿意再干从0-1的阶段，这是大企业转型失败的根源所在，也是后来者和新势力们的机会所在，任何企业面向一个全新的生产力和生产关系，都不可能跳过从0-1的阶段。\n总结一下：从0-1这个阶段企业的特长是最重要的，管理者的专业特长是最重要的，并以3%细分市场的获取为目标去快速成长和验证。\n从0-1也是最难的一个阶段，据统计96%以上的创业企业都会在从0-1的阶段就结束了，最近几年这个失败比率我认为会更高。\n对于创业一号位而言，如何抵挡住各种诱惑，如何不被竞争、舆论、股东等外部因素带偏节奏，包括面对巨大压力和企业生死的时刻，仍然能够坚持和不放弃，心力强大是很关键的。哪个完成了从0-1的企业不是多次从ICU里爬出来的？这就是对于创业者最核心的考验，更是千金难买的成长。\n内容有点长了，晚上再写从1-10的阶段。提前说一下，我们并不是到了今年才开始构建从1-10的能力，而是从2019年就开始，用三年的持续学习和投入构建从1-10的基础能力。\n【从1-10的成长期】 完成了从0-1的验证，从1-10也很容易让很多活下来的企业仍然走向失败。我很幸运，在创办汽车之家的时候，我带领团队完成了从0-1的阶段，2007年秦致加入后，用两年时间构建了从1-10的各种基础条件，带领汽车之家成功的完成了从1-10的成长期，到2016年用户和收入规模都增长了上百倍。这样一个亲身经历的过程，也让我大致看懂了从1-10的各种关键要素。2007-2008年的时候，我们真的是在只有小几千万收入的时候，就坚定的相信汽车之家可以做到100倍以上的增长，实现几十亿的收入规模，并最终做到了。\n成长期标志性的特质是，这个阶段你的规模会增长10-100倍（根据行业而定），你会面对各种竞争，因为你开始侵入领先者和既得利益者们的领土。\n有两点基本上决定了生死：\n你必须继续保持你从0-1验证期所建立的优势，这一点的疏忽是大多数企业从1-10快速死亡的根本原因。从1-10的最核心的业务动作是把之前建立的优势持续放大，而不是从零开始构建新的优势，放弃原有的优势。汽车之家最初的产品库和网站产品优势绝对不可能放弃，特斯拉的三电系统优势绝对不能放弃，理想汽车面向家庭用户的产品优势也绝不能放弃，而是要持续放大这个优势，可做的东西还很多很多。\n在坚持放大优势的前提下，必须考虑竞争的要素，也就是必须面对竞争做更多必要性的工作，记住，是必要性，而不是选择题。比如管理和系统，技术的研发，供应链的培养，商业化的能力等等。从1-10的竞争，是保持特色前提下的综合竞赛，持续保持特色和补足综合能力，缺一不可。\n在从1-10阶段失败的企业，可以确凿地说就是这两个问题：\n没有延续自己的特长；\n没有补上竞争的短板。只要有一个没做到就结束了。\n这个阶段，对于管理者而言也是一样的。首先你要继续发挥自己的专业特长，其次，你还必须快速提升自己的职业性，我说的职业性是一种更高级别的心智，是一种可以理解别人，并给出自己解决方案帮助对方的心智模式。就和我2008年最大的改变类似，也就是理解别人和坚持自己是同样的重要。记住，要想带领更大规模的团队，理解别人是第一重要的训练。去观察和理解身边的人的优势和问题，以及背后的驱动力和原理，理解他们的驱动力和历史原因，让对方有安全感和信任（被理解），我们才能给出更好的解决方案，帮助团队获得成长，和不同的团队高效的协作。\n作为管理者，从0-1比拼的是对自己的理解，从1-10则是提升对于别人的理解。\n我认为理想汽车是从2022年进入从1-10的阶段，但是由于之前和秦致一起经营汽车之家的经历，理想汽车从2019年就开始为从1-10的阶段构建基础建设，学习那些万亿收入规模的企业是怎么走过来的，以及背后的为什么，在战略、组织、系统层面构建基础能力。理想汽车从0-1做了一款产品，从1-10如何管理十款产品，如何确保每款产品的产品价值是持续领先的？产品和研发管理体系肯定要做巨大的升级，而且最好提前准备。在技术研发上，能不能把应用、技术、系统垂直打透，能不能拿到进入决赛圈的门票？在商业模式上，能不能支撑万亿收入规模，且经营效率和用户体验还持续提升？在供应链和制造产能上，能不能跟上销量的爆发式增长，能不能让每亩地产生更多的JPH？在组织上，能不能规模做大但是公司不复杂，人才不油腻，不内卷，能不能持续让人才效益健康提升？在财务上，能不能持续保持健康的现金流和造血能力，不再单纯依赖融资推动研发投入和规模增长？\n这都是过去三年时间，我们每天都在问自己的问题，并耐心的去寻找答案。\n这是我对从1-10成长期的个人认知，汽车之家从1-10的成功经验对理想汽车具备参考性，但是问题和解题方式也都是不同的。理想汽车去年只有不到300亿的收入，我认为超过1万亿的收入规模，对于一个智能电动车企业而言是一个完成从1-10交作业的时间点。\n总结一下：从1-10的成长期，企业最重要的是坚持和放大你从0-1的特长，并补上竞争和快速增长会出现的致命短板。对于参与者个人而言，仍然是持续增强自己专业的特长，但是必须补上自己的职业素养，即理解别人并给出解决方的心智模式。\n纵观整个创业，能够完成从1-10的企业，应该是千分之一的比率。总之，能做到的就活下去，做不到的就自然淘汰。\n牢记两点：\n持续扩大企业和自己的长板； 补足短板，这是必要性，而不是选择题。 ","date":"2022-02-14T22:31:29+08:00","permalink":"https://junling.li/life/lixiang/","section":"life","tags":null,"title":"李想《节奏把控对于创业的重要性》"},{"categories":null,"contents":"今天Godaddy告诉我uest.xyz还有一个月就到期了，让我付100新加坡元续费一年。这钱对学生党岂不是天价。遵循打一枪换一炮的理念，回撤去wawei云注册了junling.xyz 总得能通过新域名访问到github pages吧，我一个滑铲，用waweicloud解析添加一个cname记录，然后error！\n原来我当年使用A记录解析到GitHub的服务器 185.199.108.153 185.199.109.153 185.199.110.153 185.199.111.153 不能再添加cname了，只能通过隐性链接的方式\n然后wawei云告诉我\n1 2 3 4 # 是否支持显性/隐性URL转发功能？ 更新时间：2021/02/09 GMT+08:00 云解析服务暂不支持显性URL以及隐性URL转发功能。 哭泣，还是得dnspods，这时候，腾讯就像是我的救星。\n我又仔细一搜，发现GitHub page也可以添加cname记录解析到bachwv.github.io 我一个滑铲，发现wawei云会显示cname记录和mx记录冲突，关键是他还不告诉你和谁冲突了\nhttps://support.huaweicloud.com/dns_faq/dns_faq_016.html\n华为云修改dns在域名信息里面，改ns记录没效的，太隐蔽了。\n等了两个小时才生效。\n然后dnspods就可以同时设置mx和cname记录了\n接下来为uest.xyz设置隐性显性url能访问了捏，但是我还没没备案，所以还不行，只能等下个月域名失效了\nhttps://github.community/t/redirect-multiple-domains-to-one-github-pages-site/10903/4\n","date":"2022-02-13T23:55:00+08:00","permalink":"https://junling.li/posts/domains/","section":"posts","tags":null,"title":"Junling.xyz"},{"categories":null,"contents":"来自https://www.w3cschool.cn/cpp/cpp-i6da2pq0.html\nC++ vector使用方法 在 c++ 中，vector 是一个十分有用的容器。它能够像容器一样存放各种类型的对象，简单地说，vector是一个能够存放任意类型的动态数组，能够增加和压缩数据。 C++ 中数组很坑，有没有类似 Python 中 list 的数据类型呢？类似的就是 vector！vector 是同一种类型的对象的集合，每个对象都有一个对应的整数索引值。和 string 对象一样，标准库将负责管理与存储元素相关的内存。我们把 vector 称为容器，是因为它可以包含其他对象。一个容器中的所有对象都必须是同一种类型的。\n一、什么是vector？ 向量（Vector）是一个封装了动态大小数组的顺序容器（Sequence Container）。跟任意其它类型容器一样，它能够存放各种类型的对象。可以简单的认为，向量是一个能够存放任意类型的动态数组。\n二、容器特性 1.顺序序列 顺序容器中的元素按照严格的线性顺序排序。可以通过元素在序列中的位置访问对应的元素。\n下标访问\n2.动态数组 支持对序列中的任意元素进行快速直接访问，甚至可以通过指针算述进行该操作。操供了在序列末尾相对快速地添加/删除元素的操作。\n3.能够感知内存分配器的（Allocator-aware） 容器使用一个内存分配器对象来动态地处理它的存储需求。\n三、基本函数实现 1.构造函数 vector():创建一个空vector vector(int nSize):创建一个vector,元素个数为nSize vector(int nSize,const t\u0026amp; t):创建一个vector，元素个数为nSize,且值均为t vector(const vector\u0026amp;):复制构造函数 vector(begin,end):复制[begin,end)区间内另一个数组的元素到vector中 2.增加函数 void push_back(const T\u0026amp; x):向量尾部增加一个元素X iterator insert(iterator it,const T\u0026amp; x):向量中迭代器指向元素前增加一个元素x iterator insert(iterator it,int n,const T\u0026amp; x):向量中迭代器指向元素前增加n个相同的元素x iterator insert(iterator it,const_iterator first,const_iterator last):向量中迭代器指向元素前插入另一个相同类型向量的[first,last)间的数据 3.删除函数 iterator erase(iterator it):删除向量中迭代器指向元素 iterator erase(iterator first,iterator last):删除向量中[first,last)中元素 void pop_back():删除向量中最后一个元素 void clear():清空向量中所有元素 4.遍历函数 reference at(int pos):返回pos位置元素的引用 reference front():返回首元素的引用 reference back():返回尾元素的引用 iterator begin():返回向量头指针，指向第一个元素 iterator end():返回向量尾指针，指向向量最后一个元素的下一个位置 reverse_iterator rbegin():反向迭代器，指向最后一个元素 reverse_iterator rend():反向迭代器，指向第一个元素之前的位置 5.判断函数 bool empty() const:判断向量是否为空，若为空，则向量中无元素 6.大小函数 int size() const:返回向量中元素的个数 int capacity() const:返回当前向量所能容纳的最大元素值 int max_size() const:返回最大可允许的 vector 元素数量值 7.其他函数 void swap(vector\u0026amp;):交换两个同类型向量的数据 void assign(int n,const T\u0026amp; x):设置向量中前n个元素的值为x void assign(const_iterator first,const_iterator last):向量中[first,last)中元素设置成当前向量元素 8.看着清楚 4.begin 得到数组头的指针 5.end 得到数组的最后一个单元+1的指针 6．front 得到数组头的引用 8.max_size 得到vector最大可以是多大 9.capacity 当前vector分配的大小 11.resize 改变当前使用数据的大小，如果它比当前使用的大，者填充默认值 12.reserve 改变当前vecotr所分配空间的大小 13.erase 删除指针指向的数据项 14.clear 清空当前的vector 15.rbegin 将vector反转后的开始指针返回(其实就是原来的end-1) 16.rend 将vector反转构的结束指针返回(其实就是原来的begin-1) 17.empty 判断vector是否为空18.swap 与另一个vector交换数据\nvector\u0026lt; vector\u0026lt; int\u0026gt; \u0026gt;v; 二维向量//这里最外的\u0026lt;\u0026gt;要有空格。否则在比较旧的编译器下无法通过\nvector使用实例 排序sort(v.begin(),v.end())默认升序\n反转reverse(v.begin().v.end()) 使用vector注意事项：\n1、如果你要表示的向量长度较长（需要为向量内部保存很多数），容易导致内存泄漏，而且效率会很低；\n2、Vector 作为函数的参数或者返回值时，需要注意它的写法：\n1 double Distance(vector\u0026lt;int\u0026gt;\u0026amp;a, vector\u0026lt;int\u0026gt;\u0026amp;b) 其中的“\u0026amp;”绝对不能少！！！\n同样的，使用前，导入头文件 #include 可以使用using声明：using std::vector;vector 是一个类模板（class template）。使用模板可以编写一个类定义或函数定义，而用于多个不同的数据类型。因此，我们可以定义保存 string 对象的 vector，或保存 int 值的 vector，又或是保存自定义的类类型对象（如 Sales_items 对象）的 vector。 声明从类模板产生的某种类型的对象，需要提供附加信息，信息的种类取决于模板。以 vector 为例，必须说明 vector 保存何种对象的类型，通过将类型放在类型放在类模板名称后面的尖括号中来指定类型：\nvector v1; 保存类型为 T 对象。默认构造函数 v1 为空。 vector v2(v1); v2 是 v1 的一个副本。 vector v3(n, i); v3 包含 n 个值为 i 的元素。 vector v4(n); v4 含有值初始化的元素的 n 个副本。 【注意：1、若要创建非空的 vector 对象，必须给出初始化元素的值；2、当把一个 vector 对象复制到另一个 vector 对象时，新复制的 vector 中每一个元素都初始化为原 vectors 中相应元素的副本。但这两个 vector 对象必须保存同一种元素类型；3、可以用元素个数和元素值对 vector 对象进行初始化。构造函数用元素个数来决定 vector 对象保存元素的 个数，元素值指定每个元素的初始值】\nvector对象动态增长： vector 对象（以及其他标准库容器对象）的重要属性就在于可以在运行时高效地添加元素。\n注意：因为 vector 增长的效率高，在元素值已知的情况下，最好是动态地添加元素。\n实例：\nvectortest;//建立一个vector，int为数组元素的数据类型，test为动态数组名\n简单的使用方法如下：\n1 2 3 vector\u0026lt;int\u0026gt;test;//建立一个vector test.push_back(1); test.push_back(2);//把1和2压入vector，这样test[0]就是1,test[1]就是2 实例：\n1 2 vector\u0026lt;vector\u0026lt;Point2f\u0026gt; \u0026gt; points; //定义一个二维数组 points[0].size(); //指第一行的列数 使用迭代器访问元素.\n1 2 3 vector\u0026lt;int\u0026gt;::iterator it; for(it=vec.begin();it!=vec.end();it++) cout\u0026lt;\u0026lt;*it\u0026lt;\u0026lt;endl; (6)插入元素：vec.insert(vec.begin()+i,a); 在第i+1个元素前面插入a;\n(7)删除元素：vec.erase(vec.begin()+2) ; 删除第3个元素\nvec.erase(vec.begin()+i,vec.end()+j); 删除区间[ i,j-1] 区间从0开始\n(9)清空: vec.clear();\n特别提示：这里有 begin() 与 end() 函数、front() 与 back() 的差别\n2、重要说明\nvector 的元素不仅仅可以是 int,double,string 还可以是结构体，但是要注意：结构体要定义为全局的，否则会出错。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 #include\u0026lt;stdio.h\u0026gt; #include\u0026lt;algorithm\u0026gt; #include\u0026lt;vector\u0026gt; #include\u0026lt;iostream\u0026gt; using namespace std; typedef struct rect { int id; int length; int width; //对于向量元素是结构体的，可在结构体内部定义比较函数，下面按照id,length,width升序排序。 bool operator\u0026lt; (const rect \u0026amp;a) const { if(id!=a.id) return id\u0026lt;a.id; else { if(length!=a.length) return length\u0026lt;a.length; else return width\u0026lt;a.width; } } }Rect; int main() { vector\u0026lt;Rect\u0026gt; vec; Rect rect; rect.id=1; rect.length=2; rect.width=3; vec.push_back(rect); vector\u0026lt;Rect\u0026gt;::iterator it=vec.begin(); cout\u0026lt;\u0026lt;(*it).id\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;(*it).length\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;(*it).width\u0026lt;\u0026lt;endl; return 0; } 3、算法\n(1) 使用reverse将元素翻转：需要头文件 #include\nreverse(vec.begin(),vec.end());将元素翻转，即逆序排列！\n(在vecto r中，如果一个函数中需要两个迭代器，一般后一个都不包含)\n(2)使用 sort 排序：需要头文件 #include，\nsort(vec.begin(),vec.end());(默认是按升序排列,即从小到大).\n可以通过重写排序比较函数按照降序比较，如下：\n定义排序比较函数：\n1 2 3 4 bool Comp(const int \u0026amp;a,const int \u0026amp;b) { return a\u0026gt;b; } 调用时: sort(vec.begin(),vec.end(),Comp)，这样就降序排序。\n输出Vector的中的元素\nvector vecClass;\nint nSize = vecClass.size();\n//打印 vecClass,方法一：\n1 2 3 4 5 for(int i=0;i\u0026lt;nSize;i++) { cout\u0026lt;\u0026lt;vecClass[i]\u0026lt;\u0026lt;\u0026#34; \u0026#34;; } cout\u0026lt;\u0026lt;endl; 需要注意的是：以方法一进行输出时，数组的下表必须保证是整数。\n//打印 vecClass,方法二：\n1 2 3 4 5 for(int i=0;i\u0026lt;nSize;i++) { cout\u0026lt;\u0026lt;vecClass.at(i)\u0026lt;\u0026lt;\u0026#34; \u0026#34;; } cout\u0026lt;\u0026lt;endl; //打印 vecClass,方法三：输出某一指定的数值时不方便\n1 2 3 4 5 for(vector\u0026lt;float\u0026gt;::iterator it = vecClass.begin();it!=vecClass.end();it++) { cout\u0026lt;\u0026lt;*it\u0026lt;\u0026lt;\u0026#34; \u0026#34;; } cout\u0026lt;\u0026lt;endl; 二维数组的使用：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include \u0026#34;stdafx.h\u0026#34; #include \u0026lt;cv.h\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;iostream\u0026gt; using namespace std; int main() { using namespace std; int out[3][2] = { 1, 2, 3, 4, 5, 6 }; vector \u0026lt;int*\u0026gt; v1; v1.push_back(out[0]); v1.push_back(out[1]); v1.push_back(out[2]); cout \u0026lt;\u0026lt; v1[0][0] \u0026lt;\u0026lt; endl;//1 cout \u0026lt;\u0026lt; v1[0][1] \u0026lt;\u0026lt; endl;//2 cout \u0026lt;\u0026lt; v1[1][0] \u0026lt;\u0026lt; endl;//3 cout \u0026lt;\u0026lt; v1[1][1] \u0026lt;\u0026lt; endl;//4 cout \u0026lt;\u0026lt; v1[2][0] \u0026lt;\u0026lt; endl;//5 cout \u0026lt;\u0026lt; v1[2][1] \u0026lt;\u0026lt; endl;//6 return 0; } ","date":"2022-02-03T23:15:57+08:00","permalink":"https://junling.li/posts/vector/","section":"posts","tags":null,"title":"C++ vector使用方法"},{"categories":null,"contents":" 你正在参加一个多角色游戏，每个角色都有两个主要属性：攻击 和 防御 。给你一个二维整数数组 properties ，其中 properties[i] = [attacki, defensei] 表示游戏中第 i 个角色的属性。\n如果存在一个其他角色的攻击和防御等级 都严格高于 该角色的攻击和防御等级，则认为该角色为 弱角色 。更正式地，如果认为角色 i 弱于 存在的另一个角色 j ，那么 attackj \u0026gt; attacki 且 defensej \u0026gt; defensei 。\n返回 弱角色 的数量。\n示例 1：\n输入：properties = [[5,5],[6,3],[3,6]] 输出：0 解释：不存在攻击和防御都严格高于其他角色的角色。 示例 2：\n输入：properties = [[2,2],[3,3]] 输出：1 解释：第一个角色是弱角色，因为第二个角色的攻击和防御严格大于该角色。 示例 3：\n输入：properties = [[1,5],[10,4],[4,3]] 输出：1 解释：第三个角色是弱角色，因为第二个角色的攻击和防御严格大于该角色。\n提示：\n2 \u0026lt;= properties.length \u0026lt;= 105 properties[i].length == 2 1 \u0026lt;= attacki, defensei \u0026lt;= 105\n来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/the-number-of-weak-characters-in-the-game 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public int numberOfWeakCharacters(int[][] properties) { Arrays.sort(properties,(o1,o2)-\u0026gt;{ return (o1[0]!=o2[0])?(o2[0]-o1[0]):(o1[1]-o2[1]); }); int maxdef=0,cnt=0; for(int []pok:properties){ // System.out.println(pok[0]+\u0026#34; \u0026#34;+pok[1]); if(pok[1]\u0026gt;=maxdef){ maxdef=pok[1]; }else{ cnt++; } } return cnt; } } 想了很久，发现官方题解的排序思路是最容易理解的，\n1 2 3 4 5 6 10 4 10 7 7 5 7 9 7 10 6 9 排序以后就很清晰，从上到下遍历，记录最大的防御值，随后每次访问的角色中，攻击值是小于前面的，只需要判断防御值是否小于前面记录的最大防御值，由于相同攻击值时，防御值是递增的，所以不会出现更新完maxdef以后遇到同攻击值但防御值小于maxdef的问题。\n然后由看到https://leetcode-cn.com/problems/the-number-of-weak-characters-in-the-game/solution/1996you-xi-zhong-de-ruo-jiao-se-zui-da-z-so68/这个题解，用O(n+C)的时间完成了等价排序的操作，我觉得很妙。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { int tables[]=new int[100002]; public int numberOfWeakCharacters(int[][] properties) { int maxack=0,cnt=0,a,b; for(int []pok:properties){ // System.out.println(pok[0]+\u0026#34; \u0026#34;+pok[1]); a=pok[0]; b=pok[1]; maxack=Math.max(a,maxack); if(b\u0026gt;tables[a]) tables[a]=b; } for(int i=maxack;i\u0026gt;0;i--){ if(tables[i]\u0026gt;tables[i-1]) tables[i-1]=tables[i]; } for(int []pok:properties){ if(pok[1]\u0026lt;tables[pok[0]+1]) cnt++; } return cnt; } } 总体思路是维护一张记录每个不同攻击值对应的最大防御值的表table\n比如\n1 [[7,9],[10,7],[6,9],[10,4],[7,5],[7,10]] 0 1 2 3 4 5 6 9 7 9-\u0026gt;10 8 9 10 7 知道每个攻击值对应的最大值的话，对于每个角色比如[7,1]，搜索比他攻击值大的，比如10.然后判断角色[7,1]的防御值（1）是否小于10对应 的最大防御值（7），满足弱角色的定义。\n那么如何简化这个搜索的过程呢？可以想到类似前缀和的思路，在table中每个攻击值对应比他大或他的最大防御值\n0 9 1 9 2 9 3 9 4 9 5 9 6 9 7 10 8 7 9 7 10 7 然后对每一个角色按照这张表做判断\n1 [[7,9],[10,7],[6,9],[10,4],[7,5],[7,10]] 比如[7,9]判断攻击值为7+1对应的防御值（7）和他的防御值（9），该角色不满足\n[10,7]判断攻击值为10+1对应的防御值（0）和他的防御值（7），该角色不满足\n[6,9]判断攻击值为6+1对应的防御值（10）和他的防御值（9），该角色满足\n[10,4]不满足\n[7,5]判断攻击值为7+1对应的防御值（7）和他的防御值（5），该角色满足 [7,10]判断攻击值为7+1对应的防御值（7）和他的防御值（10），该角色不满足\n所以有了这张表，对于任意一个角色，我们可以查询，比该角色攻击值大1对应的防御值，和该角色的防御值做比较，即可得出是否满足弱角色的定义。\n","date":"2022-01-28T11:49:37+08:00","permalink":"https://junling.li/leetcode/1996.%E6%B8%B8%E6%88%8F%E4%B8%AD%E5%BC%B1%E8%A7%92%E8%89%B2%E7%9A%84%E6%95%B0%E9%87%8F/","section":"LeetCode","tags":null,"title":"1996.游戏中弱角色的数量"},{"categories":null,"contents":"《开端》 最近最火的剧当属《开端》了，我也很喜欢。情节不错，新颖不俗套。白敬亭和赵今麦的演技在线，特别李诗情对肖鹤云说的那句：“你也进循环了？”，微表情和那种惊喜和激动很戳我，到最后表白都是意料之中了。刘奕君成熟稳重，在倒数第二次循环毅然决然拿起炸弹，真的给人很大的信心，还有耐心听李诗情叙述循环，都符合我心中对老刑警的定位，比扫黑风暴更像一个正面角色了。那次被领盒饭就感觉没有依靠了，单靠江枫我都不知道能不能完成任务，相比之下女警的形象就不那么鲜明了，就像个念台词的。\n情节逻辑都很流畅，除了有些地方拖沓了，有几次循环完全可以不再有，或者可以合并。两人组加一个第三人也未尝不可，给老焦多一点戏份也行，汽车上的男孩也可以去掉。\n赵今麦的演技比流浪地球成长了不少，也期待以后能带来更加惊艳的作品。\n综合来说，《开端》是近两年看的最令人印象深刻的剧，明知道结局还是像继续看下去，比《隐秘的角落》、《摩天大楼》、《沉默的真相》更好。\n赵今麦太好看了噜！！！\n《寻枪》 姜文的作品，意识流的手法说实话我不是很懂，也没有惊艳点。寻枪意在寻枪，实际上在寻什么？我的理解是寻亲情？但看情节不是这样，有人说是马山监守自盗，自己偷枪杀人。还有结巴的情节安排，超出我 的理解范围了。\n《穿格子衬衫的男孩》 在孩子的视角看反战，为什么有爱的父亲却掌管一个集中营。不表现集中营，直到结尾才表现集中营的残酷。\n结尾属于在意料之外，是惊艳我的一点。\n低成本好片。故事有点单薄。\n《寻梦环游记》 1.28 这部是想看了很多年一直没看的电影了，皮克斯的电影都很有感染力，在我看来，这部比《心灵奇旅》还要棒。寻梦环游记的译名也比Coco好。遗忘才是真正的死亡，男孩追寻自己的梦想，也是找回Coco对爸爸的记忆，冥界也有真情在，有欢笑，有音乐，也有为了生活不得不放弃的勇气。\n最终全家人都得到了救赎，皆大欢喜。\n适合全家人过年一起看。\n《控方证人》 2.2 始于剧情，忠于演技。结尾多次翻转。在证据缺乏的条件下，当有证据指向一个无辜的人时，lawyer如何为其辩护，全员演技在线，威尔弗里德爵士的形象十分生动，足够理智也足够机灵，也是一位正义尽职的刑辩律师，观察力敏锐，能准确挖掘控方的漏洞。女主克里斯汀演技爆棚，端庄优雅，也足够聪明。当然最后翻转也相当精彩，将全剧推向最高潮。 原来法庭上大家都在演戏，骗的只是陪审团。尘埃落定之后才揭开真相。\n超级喜欢看老片。玛琳•黛德丽好有气质！\n","date":"2022-01-27T21:36:31+08:00","permalink":"https://junling.li/life/%E4%B8%80%E4%BA%9B%E5%BD%B1%E8%AF%84/","section":"life","tags":null,"title":"一些影评"},{"categories":null,"contents":"Manjaro 的一些安装经验吧\n首先进bios，解除security，然后进boot menu，把首选启动项改成uefi 进入u盘安装 然后是分区，我先在windows压缩D盘空了60G空间，在manjaro里面把这个空间给它\n软件方面是飞书，用pacman下载yay，然后yay feishu安装5.2版本的飞书 debtop实在是没有成功解包，debtop还是从github上clone了原仓库，yay也是clone原仓库下来的\n第二个是输入法\n三步走\n1 2 3 4 sudo pacman -S fcitx-configtool sudo pacman -S fcitx-gtk2 fcitx-gtk3 sudo pacman -S fcitx-qt4 fcitx-qt5 sudo pacman -S fcitx-sogoupinyin 这样是不行的，因为fcitx-sogoupinyin在pacman上找不到，还得用yay fcitx-spigoupinyin 最后 sudo echo -e \u0026quot;export GTK_IM_MODULE=fcitx\\n export QT_IM_MODULE=fcitx\\n export XMODIFIERS=@im=fcitx\u0026quot; \u0026gt;\u0026gt;~/.xprofile 就完事，因为需要~/.xprofile配置文件，然后重启就好了\n第三个是tim，这个只能通过wine来达到最好的体验，注意要调分辨率， env WINEPREFIX=\u0026quot;$HOME/.deepinwine/Spark-TIM\u0026quot; deepin-wine5 winecfg 在弹出的窗口中改dpi，我觉得2k屏改成200dpi左右比较合适\nMatlab R2016b安装 参考https://www.cnblogs.com/lvchaoshun/p/9746155.html安装 和https://blog.csdn.net/weixin_42598278/article/details/113562238更换中文字体\nwps:\n1 yay wps-office-cn 注意，安装以后可能会出现字体发虚的问题\nKDE下dpi不对称导致的字体模糊 wps office默认设置dpi为96。但是当kde DPI非96时，会强制修改wps的dpi导致字体模糊\n此时只需要在wps（包括wps,wps文字，wps表格，wps演示，wpsPDF）的desktop文件中第四行的Exec添加QT_SCREEN_SCALE_FACTORS=1 即可。如：\n1 2 Exec= env QT_SCREEN_SCALE_FACTORS=1 /usr/bin/wps %U Exec= env QT_SCREEN_SCALE_FACTORS=1 /usr/bin/wpp %F https://wiki.archlinux.org/title/WPS_Office_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)\n最近22/5/15看到一篇挺不错的安装配置教程，分享一下。话说我自己已经回到Windows了\nhttps://www.freesion.com/article/71911164761/\n","date":"2022-01-13T22:57:54+08:00","permalink":"https://junling.li/posts/manjaro_setup/","section":"posts","tags":null,"title":"Manjaro Setup"},{"categories":null,"contents":"蔡勒(zeller)公式\n给出日期，计算星期几\n$$ {\\displaystyle w=\\left(y+\\left[{\\frac {y}{4}}\\right]+\\left[{\\frac {c}{4}}\\right]-2c+\\left[{\\frac {26(month+1)}{10}}\\right]+day-1\\right){\\bmod {7}}}$$\n$${\\displaystyle c={\\frac {year}{100}}}$$ $${\\displaystyle y= year \\bmod {100}}$$\n所得的w即为星期几，w=0为星期日，w=1为星期一，以此类推\n注意：month的取值范围为3至14，如果月份数是1、2月要看作上一年的13、14月来计算，比如2000年2月29日要看作1999年的14月29日来计算\n1185. 一周中的第几天 给你一个日期，请你设计一个算法来判断它是对应一周中的哪一天。\n输入为三个整数：day、month 和 year，分别表示日、月、年。\n您返回的结果必须是这几个值中的一个 {\u0026quot;Sunday\u0026quot;, \u0026quot;Monday\u0026quot;, \u0026quot;Tuesday\u0026quot;, \u0026quot;Wednesday\u0026quot;, \u0026quot;Thursday\u0026quot;, \u0026quot;Friday\u0026quot;, \u0026quot;Saturday\u0026quot;}。\n示例 1：\n1 2 输入：day = 31, month = 8, year = 2019 输出：\u0026#34;Saturday\u0026#34; 示例 2：\n1 2 输入：day = 18, month = 7, year = 1999 输出：\u0026#34;Sunday\u0026#34; 示例 3：\n1 2 输入：day = 15, month = 8, year = 1993 输出：\u0026#34;Sunday\u0026#34; 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public String dayOfTheWeek(int day, int month, int year) { String []ans={\u0026#34;Sunday\u0026#34;,\u0026#34;Monday\u0026#34;, \u0026#34;Tuesday\u0026#34;, \u0026#34;Wednesday\u0026#34;, \u0026#34;Thursday\u0026#34;, \u0026#34;Friday\u0026#34;, \u0026#34;Saturday\u0026#34;}; if(month\u0026lt;=2){ month+=12; year--; } int y=year%100,c=year/100; int week=y+y/4+c/4-2*c+26*(month+1)/10+day-1+70; //+70是因为可能出现负数 return ans[week%7]; } } ","date":"2022-01-03T00:57:54+08:00","permalink":"https://junling.li/posts/zeller/","section":"posts","tags":["Leetcode","Easy"],"title":"Zeller"},{"categories":null,"contents":" 1705. 吃苹果的最大数目 难度中等\n有一棵特殊的苹果树，一连 n 天，每天都可以长出若干个苹果。在第 i 天，树上会长出 apples[i] 个苹果，这些苹果将会在 days[i] 天后（也就是说，第 i + days[i] 天时）腐烂，变得无法食用。也可能有那么几天，树上不会长出新的苹果，此时用 apples[i] == 0 且 days[i] == 0 表示。\n你打算每天 最多 吃一个苹果来保证营养均衡。注意，你可以在这 n 天之后继续吃苹果。\n给你两个长度为 n 的整数数组 days 和 apples ，返回你可以吃掉的苹果的最大数目*。*\n示例 1：\n1 2 3 4 5 6 7 输入：apples = [1,2,3,5,2], days = [3,2,1,4,2] 输出：7 解释：你可以吃掉 7 个苹果： - 第一天，你吃掉第一天长出来的苹果。 - 第二天，你吃掉一个第二天长出来的苹果。 - 第三天，你吃掉一个第二天长出来的苹果。过了这一天，第三天长出来的苹果就已经腐烂了。 - 第四天到第七天，你吃的都是第四天长出来的苹果。 示例 2：\n1 2 3 4 5 6 输入：apples = [3,0,0,0,0,2], days = [3,0,0,0,0,2] 输出：5 解释：你可以吃掉 5 个苹果： - 第一天到第三天，你吃的都是第一天长出来的苹果。 - 第四天和第五天不吃苹果。 - 第六天和第七天，你吃的都是第六天长出来的苹果。 提示：\napples.length == n days.length == n 1 \u0026lt;= n \u0026lt;= 2 * 104 0 \u0026lt;= apples[i], days[i] \u0026lt;= 2 * 104 只有在 apples[i] = 0 时，days[i] = 0 才成立 4个月之前尝试过这一题，然后失败了，趁着圣诞节，再吃一颗苹果吧。\n本题给了两个数组，一个是每天生成的苹果数量apples[i]，另一个是那天生成苹果的腐烂日期days[i]。\n很自然地，如果某一天想吃苹果，那么苹果必定没有腐烂，如果有一个表或者其他的什么东东能告诉我苹果有没有腐烂就好了。\n这时想到键值对，对于每天生成的苹果，记录一个腐烂截止日期，再记录苹果数。再将这个键值对排序，每次取最近腐烂但是还没腐烂的苹果吃。\n这就需要小根堆了，Java中是优先队列。\n具体实现上，分为两个阶段，在小于n（n是apples数组的长度）的日子里，每天产生苹果，将其入队，并且看看有没有腐烂的苹果，将其出队，再看看有没有能吃到的苹果，把它吃掉；大于n的日子，由于不产生苹果，就只有清理腐烂的苹果和吃苹果这两件事要做了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 public static int eatenApples(int[] apples, int[] days) { PriorityQueue\u0026lt;int[]\u0026gt; q = new PriorityQueue\u0026lt;\u0026gt;(new Comparator\u0026lt;int []\u0026gt;() { @Override public int compare(int[] o1, int[] o2) { return o1[0] - o2[0]; } }); int len=apples.length; int eat=0; int []nn; for(int i=0;i\u0026lt;len;i++){ if(apples[i]!=0) { q.add(new int[]{i+days[i]-1,apples[i]}); // System.out.println(\u0026#34;add\u0026#34;+q.peek()[0]+\u0026#34; \u0026#34;+q.peek()[1]); } while(!q.isEmpty()\u0026amp;\u0026amp;(q.peek()[0]\u0026lt;i||q.peek()[1]\u0026lt;=0)){ System.out.println(\u0026#34;poll \u0026#34;+q.peek()[0]+\u0026#34; \u0026#34;+q.peek()[1]); q.poll();//清理过期苹果and小于0的苹果数 } //eat if(!q.isEmpty()){ nn=q.poll(); nn[1]--; eat++; q.add(nn); //System.out.println(\u0026#34;i=\u0026#34;+i+\u0026#34; eat=\u0026#34;+eat+\u0026#34; nn[0]=\u0026#34;+nn[0]+\u0026#34; nn[1]=\u0026#34;+nn[1]+\u0026#34; \u0026#34;+q); } } for(int i=len;!q.isEmpty();i++) { while(!q.isEmpty()\u0026amp;\u0026amp;(q.peek()[0]\u0026lt;i||q.peek()[1]\u0026lt;=0)){ // System.out.println(\u0026#34;poll \u0026#34;+q.peek()[0]+\u0026#34; \u0026#34;+q.peek()[1]); q.poll();//清理过期苹果and小于0的苹果数 } //eat if(!q.isEmpty()){ nn = q.poll(); nn[1]--; eat++; q.add(nn); } } return eat; } | 遥远遥远的以后 会不会有人知道我\n| 在这个寂寞的星球 曾这样的活过\n| 遥远遥远的以后 天长和地久的尽头\n| 应该没有人能抢走 我永远的感动\n| 活着不多不少 幸福刚好够用\n| 活着其实很好 再吃一颗苹果\n","date":"2021-12-24T19:55:00+08:00","permalink":"https://junling.li/leetcode/eatenapples/","section":"LeetCode","tags":null,"title":"Merry Christmas"},{"categories":null,"contents":"priorityQuene 优先队列，意思是呢，它能对add进去的元素排列\n可以给它一个Comparator指定排列顺序\n默认是最小堆\n常用的有peek();poll();\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 PriorityQueue\u0026lt;Integer\u0026gt; q = new PriorityQueue\u0026lt;\u0026gt;(new Comparator\u0026lt;Integer\u0026gt;() { @Override public int compare(Integer o1, Integer o2) { return o1 - o2; } }); q.add(4); q.add(33); q.add(14); q.add(100); System.out.println(q.toString());//[4, 33, 14, 100] System.out.println(q.peek());//4 Comparator\u0026lt;? super Integer\u0026gt; cp = q.comparator(); Object[] list=q.toArray(); System.out.println(Arrays.toString(list));//[4, 33, 14, 100] 这是最简单的情况\n当然最让我们头疼的是这个⽐较器，拿这个例⼦来说为什么传⼊o1-o2它就是最⼩堆了？ 在添加元素时，会使⽤offer(E e)函数加⼊e到堆⾥\n1 2 3 4 5 6 7 8 9 10 11 public boolean offer(E e) { if (e == null) throw new NullPointerException(); modCount++; int i = size; if (i \u0026gt;= queue.length) grow(i + 1); siftUp(i, e); size = i + 1; return true; } 可以看到有⼀个siftUp(),它⼜是什么呢？\n1 2 3 4 5 6 private void siftUp(int k, E x) { if (comparator != null) siftUpUsingComparator(k, x, queue, comparator); else siftUpComparable(k, x, queue); } 哦，原来是是⽤Comparator的siftUp()\n1 2 3 4 5 6 7 8 9 10 11 12 private static \u0026lt;T\u0026gt; void siftUpUsingComparator( int k, T x, Object[] es, Comparator\u0026lt;? super T\u0026gt; cmp) { while (k \u0026gt; 0) { int parent = (k - 1) \u0026gt;\u0026gt;\u0026gt; 1; Object e = es[parent]; if (cmp.compare(x, (T) e) \u0026gt;= 0) break; es[k] = e; k = parent; } es[k] = x; } x是被添加的元素，es是这个queue， 如果cmp.compare(x, (T) e) \u0026lt;0,这⾥假设我们传⼊⼀个很⼩的数（按理说要添加到最⼩堆堆顶），每次x ⼩于e,⽐较器返回⼩于0，这⾥两⾏代码(es[k] = e;k = parent;)相当于元素向堆顶⾛，直到到达堆顶 break退出while。我们成功把这个元素放到堆顶。如果我们让⽐较器返回⼤于0呢，那么，那么不会向 堆顶⾛，这就是最⼤堆了，怎么让⽐较器返回⼤于0呢？(o1,o2)-\u0026gt;o2-o1就⾏了，插⼊的x很⼩， cmp.compare(x,e)每次都返回正数(e-x\u0026gt;0),⾃然这个x不会向堆顶移动。\n优先队列里也可以放其他的对象，比如int[]\n指定按照int[]的第一个从小到大排序\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 PriorityQueue\u0026lt;int[]\u0026gt; q = new PriorityQueue\u0026lt;\u0026gt;(new Comparator\u0026lt;int []\u0026gt;() { @Override public int compare(int[] o1, int[] o2) { return o1[0] - o2[0]; } }); //也可以用lambda表达式：(o1,o2) o1[0]-o2[0]; q.add(new int[]{4,19}); q.add(new int[]{33,20}); q.add(new int[]{14,22}); q.add(new int[]{100,23}); int []nn=q.poll(); System.out.println(Arrays.toString(nn));//[4, 19] nn=q.poll(); System.out.println(Arrays.toString(nn));//[14, 22] nn=q.poll(); System.out.println(Arrays.toString(nn));//[33, 20] nn=q.poll(); System.out.println(Arrays.toString(nn));//[100, 23] ref:\nPriorityQueue的API文档说明：\n构造方法摘要 **PriorityQueue**() 使用默认的初始容量（11）创建一个 PriorityQueue，并根据其自然顺序对元素进行排序。 **PriorityQueue**(Collection\u0026lt;? extends E\u0026gt; c) 创建包含指定 collection 中元素的 PriorityQueue。 **PriorityQueue**(int initialCapacity) 使用指定的初始容量创建一个 PriorityQueue，并根据其自然顺序对元素进行排序。 **PriorityQueue**(int initialCapacity, Comparator\u0026lt;? super E\u0026gt; comparator) 使用指定的初始容量创建一个 PriorityQueue，并根据指定的比较器对元素进行排序。 **PriorityQueue**(PriorityQueue\u0026lt;? extends E\u0026gt; c) 创建包含指定优先级队列元素的 PriorityQueue。 **PriorityQueue**(SortedSet\u0026lt;? extends E\u0026gt; c) 创建包含指定有序 set 元素的 PriorityQueue。 方法摘要 boolean **add**(E e) 将指定的元素插入此优先级队列。 void **clear**() 从此优先级队列中移除所有元素。 Comparator\u0026lt;? super E\u0026gt; **comparator**() 返回用来对此队列中的元素进行排序的比较器；如果此队列根据其元素的自然顺序进行排序，则返回 null。 boolean **contains**(Object o) 如果此队列包含指定的元素，则返回 true。 Iterator\u0026lt;E\u0026gt; **iterator**() 返回在此队列中的元素上进行迭代的迭代器。 boolean **offer**(E e) 将指定的元素插入此优先级队列。 E **peek**() 获取但不移除此队列的头；如果此队列为空，则返回 null。 E **poll**() 获取并移除此队列的头，如果此队列为空，则返回 null。 boolean **remove**(Object o) 从此队列中移除指定元素的单个实例（如果存在）。 int **size**() 返回此 collection 中的元素数。 Object[] **toArray**() 返回一个包含此队列所有元素的数组。 \u0026lt;T\u0026gt; T[] **toArray**(T[] a) 返回一个包含此队列所有元素的数组；返回数组的运行时类型是指定数组的类型。 从类 java.util.AbstractQueue 继承的方法 addAll, element, remove 从类 java.util.AbstractCollection 继承的方法 containsAll, isEmpty, removeAll, retainAll, toString 从类 java.lang.Object 继承的方法 clone, equals, finalize, getClass, hashCode, notify, notifyAll, wait, wait, wait 从接口 java.util.Collection 继承的方法 containsAll, equals, hashCode, isEmpty, removeAll, retainAll ","date":"2021-12-24T19:45:00+08:00","permalink":"https://junling.li/posts/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/","section":"posts","tags":null,"title":"Java 优先队列"},{"categories":null,"contents":"汇编考完了，总的来说，有点迷糊。当然上课的体验很好，还算行。\n乘着记忆力的顶峰，回忆下汇编学了啥。\n核心就是成就嘤特尔的8086系列CPU，和围绕CPU的存储器，外设。严格遵照冯诺依曼架构，采用存取程序的方式设计。构架了x86体系，尽管牙膏厂裹足不前，但直到今天，x86系列的老大还是嘤特尔。众多外设厂还得围绕牙膏厂和农厂转，比如今天被拉出来批判的联想，不是不想造cpu，而是壁垒太高了，差了几十年的发展，已经无法再构建一套新体系了\n而古董8086，现在只存在于模拟器中了，当然还有8259a，8255，8253这些东西。\n汇编是一门语言，是在机器码和高级语言的一个桥梁，串成一起，才是完整的计算机系统。\n其中的核心，我觉得是数据的移动过程。\n通过汇编语言操作硬件，完成数据在寄存器，总线，存储器中的移动。核心就是一个词，规则。\n纷乱的数据流动有着严格的规则。由此就引申出一些问题：\n流动过程中被打断了怎么办？我放一个数据，怎么找到它？要不要放一个全局的索引(GDT/LDT)?总线上两个数据会不会冲突？要不要有时钟周期同步?\n围绕这一系列问题，解决这些问题才是这门课的本质。\n学到最后才发现，这门课的名字，应该叫计算机的组成结构。或者说深入了解计算机系统。\n前几天看到一个回答，《超级马里奥3》使用了什么样的技术可以在128KB中写进这么多东西？\n128KB兄弟们，1MB是8086的寻址空间，除去接口，中断向量的地址，128KB能不能放得下还说不定呢。\n声音部分: FC有两路方波生成器，一路三角波生成器，一路随机噪声，一路PCM。PCM采样可以实现很好的效果，但数据量巨大，所以大多数游戏没用。用方波/三角波来发声就类似最简单的MIDI音乐，数据量很小。\n一看到方波生成器就来劲了，这不就可以通过8253的方式3来生成方波。\n图形部分: 这是主要占卡带容量的部分，下面简单说一下\nFC的图形处理单元以sprite的方式组织图像，程序能控制的最小显示单位不是一个点，而是8x8的sprite。 “那整个画面卷动的时候不是应该一块一块（8像素）的跳动吗？”——PPU另外有卷轴寄存器，可以按像素级指定卷动的量。也就是说sprite虽然是8x8的，但在屏幕上不见得总是对齐到8x8的格子里。 sprite里具体每个点的颜色也不像现在是豪华的16位或32位RGB直接指定，而是一个2bit的索引，从一个16色的调色板里选。 既然是2bit的索引值，最多就只能指定4色。而且因为00固定代表透明，所以实际上最多只有3色。 那为啥要用到16色的调色板？实际上是4个4色的调色板。每4个相邻的sprite（16x16）可以从这4个调色板里指定一个。所以你去数，FC的一个16x16 sprite里最多只能显示4种颜色，因此会有那种经典的单调感。 16色的调色板有两个，一个背景层用，一个角色层用。调色板从FC PPU固定死的64种颜色中选取颜色。因为这64个颜色里黑色/透明重复了多次，所以实际不同的颜色只有54种。 不管你看没看晕，上面的重点是，FC游戏里面一个像素只占用2bit的卡带空间。 并且因为所有显示内容都按sprite组织，大大方便重复使用。要显示形状一模一样的两朵云，或者几十个砖块，只需要在显存里重复写下这些sprite的编号，而不是重复sprite的数据（8x8x2/8=16byte) 因为调色板的存在，形状一样而颜色不同的图案也不需要占额外的空间，只要设置一下调色板就行了，包括变色的效果也是这样做的。红色的Mario和绿色的Luigi就是同一套Sprite。 透明、滚动、前后景叠加、碰撞检测都是PPU完成，不需要另外写程序。 sprite的数据也不存在由CPU从卡带读入到RAM的过程（除了后期的磁碟机），而是直接由卡带映射到FC的64KB地址空间进行访问。不同的卡带硬件（所谓的mapper）支持由程序控制将卡带上的不同地址映射到FC的同一地址空间，所以尽管8位的FC只有64KB寻址能力，但卡带容量可以做到256KB甚至更大。 1 微型计算机基础概论\n2.微处理器8086和8088\n","date":"2021-12-14T20:05:28+08:00","permalink":"https://junling.li/posts/%E6%B1%87%E7%BC%96%E5%A4%8D%E4%B9%A0/","section":"posts","tags":null,"title":"汇编不会编"},{"categories":null,"contents":"部署pdd\n拼夕夕是一个对标拼多多的网络商城,构建的源码在:\nhttps://github.com/SoftwareEngineeringStormtrooper/PingTaoduo/\n这是软件工程的课程项目。\n1.CentOS安装jdk\n1 yum install java-1.8.0-openjdk.x86_64 会自动配置环境变量\n2.安装tomcat\n安装目录/usr/local/tomcat\n和win下配置一模一样，i了i了\n3.安装mysql 有点复杂 https://www.cnblogs.com/zhulei2/p/13912167.html 关于密码要改一下策略\n1 2 3 4 5 SHOW VARIABLES LIKE \u0026#39;validate_password%\u0026#39;; set global validate_password.length=1; grant all privileges on *.* to \u0026#39;user02\u0026#39;@\u0026#39;%\u0026#39; with grant option; create user user02@\u0026#39;%\u0026#39; identified by \u0026#39;2077\u0026#39;; 远程连接： GRANT ALL PRIVILEGES ON *.*TO 'root'@'%';\n4.打war包 idea中build-\u0026gt;build artifacts https://blog.csdn.net/money_yao/article/details/91435188 移到webapp试了可以 注意\\conf\\Catalina\\localhost中加入命名为shopimage.xml完成虚拟文件夹创建\n1 \u0026lt;Context docBase=\u0026#34;C:\\Program Files\\Apache Software Foundation\\Tomcat 9.0\\webapps\\shopimage\u0026#34;/\u0026gt; 注意在tomcat运行过程中，webapps下面的war文件是热部署的，不需要重启tomcat，并且.war文件不能删除，否则项目无法打开。\n目前已知问题：用户登录以后的订单list的sql语句有问题，目测是CentOS下Mysql8.0的锅 查询用户表很慢，不知道什么原因\n","date":"2021-12-12T23:56:31+08:00","permalink":"https://junling.li/posts/pdd_on_centos/","section":"posts","tags":null,"title":"部署PDD项目"},{"categories":null,"contents":"ASCII 打印字符：**数字 32–126 分配给了能在键盘上找到的字符，当您查看或打印文档时就会出现。注：十进制32代表空格 ，十进制数字 127 代表 DELETE 命令。下面是ASCII码和相应数字的对照表\nASCII 码 字符 ASCII 码 字符 ASCII 码 字符 ASCII 码 字符 十进位 十六进位 十进位 十六进位 十进位 十六进位 十进位 十六进位 032 20 056 38 8 080 50 P 104 68 h 033 21 ! 057 39 9 081 51 Q 105 69 i 034 22 \u0026quot; 058 3A : 082 52 R 106 6A j 035 23 # 059 3B ; 083 53 S 107 6B k 036 24 $ 060 3C \u0026lt; 084 54 T 108 6C l 037 25 % 061 3D = 085 55 U 109 6D m 038 26 \u0026amp; 062 3E \u0026gt; 086 56 V 110 6E n 039 27 ' 063 3F ? 087 57 W 111 6F o 040 28 ( 064 40 @ 088 58 X 112 70 p 041 29 ) 065 41 A 089 59 Y 113 71 q 042 2A * 066 42 B 090 5A Z 114 72 r 043 2B + 067 43 C 091 5B [ 115 73 s 044 2C , 068 44 D 092 5C \\ 116 74 t 045 2D - 069 45 E 093 5D ] 117 75 u 046 2E . 070 46 F 094 5E ^ 118 76 v 047 2F / 071 47 G 095 5F _ 119 77 w 048 30 0 072 48 H 096 60 ` 120 78 x 049 31 1 073 49 I 097 61 a 121 79 y 050 32 2 074 4A J 098 62 b 122 7A z 051 33 3 075 4B K 099 63 c 123 7B { 052 34 4 076 4C L 100 64 d 124 7C | 053 35 5 077 4D M 101 65 e 125 7D } 054 36 6 078 4E N 102 66 f 126 7E ~ 055 37 7 079 4F O 103 67 g 127 7F DEL ","date":"2021-12-10T23:23:40+08:00","permalink":"https://junling.li/posts/ascii/","section":"posts","tags":null,"title":"Ascii"},{"categories":null,"contents":" 383. 赎金信 难度简单202\n为了不在赎金信中暴露字迹，从杂志上搜索各个需要的字母，组成单词来表达意思。\n给你一个赎金信 (ransomNote) 字符串和一个杂志(magazine)字符串，判断 ransomNote 能不能由 magazines 里面的字符构成。\n如果可以构成，返回 true ；否则返回 false 。\nmagazine 中的每个字符只能在 ransomNote 中使用一次。\n示例 1：\n1 2 输入：ransomNote = \u0026#34;a\u0026#34;, magazine = \u0026#34;b\u0026#34; 输出：false 示例 2：\n1 2 输入：ransomNote = \u0026#34;aa\u0026#34;, magazine = \u0026#34;ab\u0026#34; 输出：false 示例 3：\n1 2 输入：ransomNote = \u0026#34;aa\u0026#34;, magazine = \u0026#34;aab\u0026#34; 输出：true 提示：\n1 \u0026lt;= ransomNote.length, magazine.length \u0026lt;= 105 ransomNote 和 magazine 由小写英文字母组成 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public boolean canConstruct(String ransomNote, String magazine) { char a[]=new char[26]; for(int i=0;i\u0026lt;magazine.length();i++){ a[magazine.charAt(i)-\u0026#39;a\u0026#39;]++; } for(int i=0;i\u0026lt;ransomNote.length();i++){ if(a[ransomNote.charAt(i)-\u0026#39;a\u0026#39;]\u0026gt;0) a[ransomNote.charAt(i)-\u0026#39;a\u0026#39;]--; else return false; } return true; } } ","date":"2021-12-04T00:28:37+08:00","permalink":"https://junling.li/leetcode/383.%E8%B5%8E%E9%87%91%E4%BF%A1/","section":"LeetCode","tags":null,"title":"383.赎金信"},{"categories":null,"contents":"11月的力扣打卡有点懈怠了，今天看到某些人全站排名7000，竞赛排名2400，表示再\n400. 第 N 位数字 难度中等277\n给你一个整数 n ，请你在无限的整数序列 [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, ...] 中找出并返回第 n 位上的数字。\n示例 1：\n1 2 输入：n = 3 输出：3 示例 2：\n1 2 3 输入：n = 11 输出：0 解释：第 11 位数字在序列 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, ... 里是 0 ，它是 10 的一部分。 提示：\n1 \u0026lt;= n \u0026lt;= 231 - 1 第 n 位上的数字是按计数单位（digit）从前往后数的第 n 个数，参见 示例 2 。 通过次数41,651\n提交次数91,695\n这一题的思路不难，对于N=1-9来说\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public int findNthDigit(int n) { if(n\u0026lt;10) return n; int i=2; long maxnum=9; long temp=0; int mod=0; while(true){ if(n\u0026lt;maxnum+9*(long)Math.pow(10,i-1)*i){ long before=0; for(int j=0;j\u0026lt;i;j++)before+=(long)9*Math.pow(10,j-1); temp=(n-maxnum+1)/i+before;//这里的加1是因为往数轴正方向再数一个值 mod=(int)(n-maxnum-1)%i;//这里的减1是为了让mod=0对准最高位 // 346 347 348 349 350 351 //152：1 5 2 1 5 3 // System.out.println(\u0026#34;temp=\u0026#34;+temp+\u0026#34; mod=\u0026#34;+mod+\u0026#34; i=\u0026#34;+i); //System.out.println(\u0026#34;maxnum=\u0026#34;+maxnum); String s=String.valueOf(temp); return s.charAt(mod)-48; }else{ maxnum=maxnum+9*(long)Math.pow(10,i-1)*i; i++; } } } } ","date":"2021-12-04T00:19:37+08:00","permalink":"https://junling.li/leetcode/400.%E7%AC%ACn%E4%BD%8D%E6%95%B0%E5%AD%97/","section":"LeetCode","tags":null,"title":"400.第N位数字"},{"categories":null,"contents":" 1. 两数之和 难度简单\n给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那 两个 整数，并返回它们的数组下标。\n你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。\n你可以按任意顺序返回答案。\n示例 1：\n1 2 3 输入：nums = [2,7,11,15], target = 9 输出：[0,1] 解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。 示例 2：\n1 2 输入：nums = [3,2,4], target = 6 输出：[1,2] 示例 3：\n1 2 输入：nums = [3,3], target = 6 输出：[0,1] 提示：\n2 \u0026lt;= nums.length \u0026lt;= 104 -109 \u0026lt;= nums[i] \u0026lt;= 109 -109 \u0026lt;= target \u0026lt;= 109 只会存在一个有效答案 **进阶：**你可以想出一个时间复杂度小于 O(n2) 的算法吗？\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public static int[] twoSum(int[] nums, int target) { int []solution=new int[2]; HashMap\u0026lt;Integer,Integer\u0026gt; hashMap=new HashMap\u0026lt;Integer, Integer\u0026gt;(); for (int j0=0;j0\u0026lt;nums.length;j0++) { if(hashMap.containsKey(target-nums[j0])){ solution[0]=hashMap.get(target-nums[j0]); solution[1]=j0; return solution; }else { hashMap.put(nums[j0],j0); } } return solution; } } ","date":"2021-12-03T16:49:37+08:00","permalink":"https://junling.li/leetcode/1.%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/","section":"LeetCode","tags":null,"title":"1.两数之和"},{"categories":null,"contents":"1.两数之和\n链式前向星\n383.赎金信\n400.第N位数字\n1 2 3 4 5 6 7 # 建议使用绝对路径（根目录为content目录），而非相对路径，否则容易出错 ref绝对路径： [链式前向星](https://junling.li/posts/%E9%93%BE%E5%BC%8F%E5%89%8D%E5%90%91%E6%98%9F/) relref相对路径： [链式前向星](/posts/%E9%93%BE%E5%BC%8F%E5%89%8D%E5%90%91%E6%98%9F/) # 只有所引用的文件与当前文件在同一文件夹下时可以使用 相对路径的方式（只写文件名） 为了实现左侧有LeetCode的效果，对Hugo来说，配置十分简单，\n在taxonomies中添加leetcode标签，这是为了根据leetcode文件夹生成 http://localhost:1313/leetcode/，里面是leetcode文件夹中的文章\nTaxonomies are classifications of logical relationships between content.\n而方框中[[menu.main]，决定了leetcode标签是否显示在左侧侧边栏\nhttps://gohugo.io/content-management/taxonomies/\nHugo代码增加显示行号功能 今天看Hugo文档的时候，发现hugo已经有显示行号的功能了\nhugo的版本需要v0.60.0以上\n实现的方式很简单，只要修改配置文件即可\n修改配置文件 修改主配置文件config.toml,在配置文件中增加\n1 2 3 4 5 6 7 8 9 10 11 12 pygmentsUseClasses = true [markup] [markup.highlight] codeFences = true guessSyntax = true hl_Lines = \u0026#34;\u0026#34; lineNoStart = 1 lineNos = true lineNumbersInTable = false #true的话是line单独一行，这才是我想要的效果 2022-1-25才发现 noClasses = true tabWidth = 4 添加阅读次数 在themes/hugo-theme-tokiwa/layouts/patrials/page-asids.html中添加\n1 2 \u0026lt;!-- 不蒜子 21/12/4 ljl引入站长统计--\u0026gt; \u0026lt;script async src=\u0026#34;//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; 以上是必须引用的脚本\n下面在Built with Hugo and theme后面加入\n1 2 3 \u0026lt;span id=\u0026#34;busuanzi_container_page_pv\u0026#34;\u0026gt; 本文总阅读量\u0026lt;span id=\u0026#34;busuanzi_value_page_pv\u0026#34;\u0026gt;\u0026lt;/span\u0026gt;次 \u0026lt;/span\u0026gt; ","date":"2021-12-03T16:35:57+08:00","permalink":"https://junling.li/posts/%E8%B7%B3%E8%BD%AC%E6%B5%8B%E8%AF%95/","section":"posts","tags":null,"title":"跳转测试"},{"categories":["tech"],"contents":"前几天被群晖官方从阿尔及利亚区强制迁回中国，导致需要手机号验证，验证完了以后会显示序列号冲突，得拍视频提交工单才能解除冲突，才能使用easyconnect，这令我十分不爽。一怒之下注销了群晖的号，打算自己弄。\n由于我没有公网ip，又不想弄花生壳，teamviewer，所以我得想办法解决公网访问的问题。\n下面介绍借助frp实现内网穿透。\nfrp分为客户端和服务端两个部分，服务器上使用的是frps，群晖上使用的是frpc。\n在客户端开端口，然后群晖的frpc连接上服务器上的frps就可以了。\n下面是手把手教学：\n服务器端 如果你有一台闲置的Linux服务器，而且有公网ip，在打开防火墙以后，按照一下方法操作 如果你没有，也可以使用免费的一些frp服务器https://frp.wlphp.com/，这样你就可以跳过服务器配置的过程了。直接 跳转到群晖上操作\n下载 在https://github.com/fatedier/frp/releases中找到需要下载的文件,比如我想下载0.37.0的linux的x86平台的frp，就可以这么写：\n1 # wget -O frp https://github.com/fatedier/frp/releases/download/v0.37.0/frp_0.37.0_linux_amd64.tar.gz 解压：\n1 # tar -xvzf frp 可以看到这些文件：\n1 2 3 # ls frpc frpc.ini frps frps.ini systemd frpc_full.ini frpc.log frps_full.ini LICENSE 接下来就是配置服务器端文件frps.ini\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 [common] bind_port = 7000 #通讯端口，用于和客户端内网穿透传输数据的端口，可自定义 bind_udp_port = 7001 #UDP通讯端口，用于点对点内网穿透 kcp_bind_port = 7000 #用于KCP协议UDP通讯端口，在弱网环境下传输效率提升明显，但是会有一些额外的流量消耗。设置后frpc客户端须设置protocol = kcp vhost_http_port = 80 #http监听端口，注意可能和服务器上其他服务用的80冲突，比如centos有些默认有Apache，可自定义 vhost_https_port = 443 #https监听端口，可自定义 dashboard_port = 7500 #通过浏览器查看 frp 的状态以及代理统计信息展示端口，可自定义 dashboard_user = admin #信息展示面板用户名 dashboard_pwd = admin #信息展示面板密码 log_max_days = 7 #最多保存多少天日志 token = xxxxxx #这就是与客户端连接的token啦 privilege_allow_ports = 1-65535 #端口白名单，为了防止端口被滥用，可以手动指定允许哪些端口被使用 max_pool_count = 100 #每个内网穿透服务限制最大连接池上限，避免大量资源占用，可自定义 authentication_timeout = 0 #frpc 所在机器和 frps 所在机器的时间相差不能超过 15 分钟，因为时间戳会被用于加密验证中，防止报文被劫持后被其他人利用,单位为秒，默认值为 900，即 15 分钟。如果修改为 0，则 frps 将不对身份验证报文的时间戳进行超时校验。国外服务器由于时区的不同，时间会相差非常大，这里需要注意同步时间或者设置此值为0 log_file = frps.log log_level = info 实际上没有必要配置这么多，bind_port = 7000和token就够了。 下一步运行就可以了，这里用后台运行的指令\n1 # nohup ./frps -c frps.ini \u0026amp; 可以在服务器ip:7500端口看到frps的运行状态，至此，服务器端的配置就完成了。\n客户端 首先，得用ssh登录群晖。如果你没有用过ssh登录过，可以进入群晖控制面板，找到终端机和SNMP，点击启动SSH功能，设定你的端口（默认22） 点击应用。\n接下来使用你顺手的ssh登录就可以了。利用admin账号和密码登录（注意admin账号登录进去以后还要用sudo -i，不然没有权限） 找到一个顺手的 目录，比如home，利用同样的命令 下载\n这时，我们关注的是frpc.ini这个配置文件\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 [common] server_addr = xxx.xxx.xxx.xxx #frps服务端地址 server_port = 7000 #frps服务端通讯端口，客户端连接到服务端内网穿透传输数据的端口 token = xxxxxxx #特权模式密钥，客户端连接到FRPS服务端的验证密钥 log_file = frpc.log #日志存放路径 log_level = info #日志记录类别,可选：trace, debug, info, warn, error log_max_days = 7 #日志保存天数 login_fail_exit = false #设置为false，frpc连接frps失败后重连，默认为true不重连 protocol = kcp #KCP协议在弱网环境下传输效率提升明显，但是对frps会有一些额外的流量消耗。服务端须先设置kcp_bind_port = 7000，www.yourdomain.com服务端已设置支持 [nas] #穿透服务名称,可以随便起,不能和其他已建立的相同 type = tcp #穿透协议类型，可选：tcp，udp，http，https，stcp，xtcp，这个设置之前必须自行搞清楚应该是什么 local_ip = 127.0.0.1 #本地监听IP，可以是本机IP，也可以是本地的局域网内某IP，例如你的局域网是互通的，你可以在路由器上安装frpc，然后local_ip填的内网其他机器ip，这样也可以把内网其他机器穿透出去 local_port = 5000 #本地监听端口，通常有ssh端口22，远程桌面3389等等,就是把本机的多少端口转发出去 use_compression = true #对传输内容进行压缩，可以有效减小 frpc 与 frps 之间的网络流量，加快流量转发速度，但是会额外消耗一些 cpu 资源 use_encryption = true #将 frpc 与 frps 之间的通信内容加密传输 remote_port = 5009 #即远程对应你客户端的端口，不能和别的重合 下一步在frp目录下新建一个启动脚本start.sh，让群晖每次开机时运行这一个脚本\n1 nohup /home/frp/frpc -c /home/frp/frpc.ini \u0026gt;/dev/null 2\u0026gt;\u0026amp;1 \u0026amp; 解释一下为什么要这么写：\n/dev/null 这条命令的作用是将标准输出1重定向到/dev/null中。 /dev/null代表linux的空设备文件，所有往这个文件里面写入的内容都会丢失，俗称“黑洞”。那么执行了\u0026gt;/dev/null之后，标准输出就会不再存在，没有任何地方能够找到输出的内容。\n2\u0026gt;\u0026amp;1 这条命令用到了重定向绑定，采用\u0026amp;可以将两个输出绑定在一起。这条命令的作用是错误输出将和标准输出同用一个文件描述符，说人话就是错误输出将会和标准输出输出到同一个地方。\nlinux在执行shell命令之前，就会确定好所有的输入输出位置，并且从左到右依次执行重定向的命令，所以\u0026gt;/dev/null 2\u0026gt;\u0026amp;1的作用就是让标准输出重定向到/dev/null中（丢弃标准输出），然后错误输出由于重用了标准输出的描述符，所以错误输出也被定向到了/dev/null中，错误输出同样也被丢弃了。执行了这条命令之后，该条shell命令将不会输出任何信息到控制台，也不会有任何信息输出到文件中。\n接下来，回到群晖的控制台，在控制面板的计划任务中 新建任务,事件为开机 在任务设置中填写： bash /home/frp/start.sh 重启群晖 就可以在服务器的7500看到刚刚登录进来的群晖。\n输入服务器ip:端口（在frpc.ini中设置的remote端口），即可看到你的设备啦。 如果你不嫌烦+不怕死，你也可以把群晖的22端口映射出去。\n当然，如果你有远程桌面，tomcat，nginx的需求都可以用这种方法，对我来说frp取代teamviewer和花生壳是完全可以的。\n","date":"2021-11-10T16:58:12+08:00","permalink":"https://junling.li/posts/%E7%BE%A4%E6%99%96frp/","section":"posts","tags":null,"title":"frp内网穿透"},{"categories":null,"contents":"深夜emo\nemoemoemoemoemoemoemoemoemoemoemoemoemoemoemoemoemoemoemoemoemoemoemoemoemoemoemoemoemoemoemoemo\n无意间翻到大佬的博客，发现自己真的错失了许多机会，做错了不少选择。\n以上是在为自己的失败找理由，失败的结局无法避免，从高中就如此，早已看到结局，却又不接受结局，只能编造理由掩盖失败。\n可是时间不能再重来，希望以后能够把握住机会，真心投入做好一些事吧。\n至少不像现在一样一事无成吧。\n一定会的\nSeize the day\n","date":"2021-11-05T00:01:16+08:00","permalink":"https://junling.li/life/%E4%B8%A7/","section":"life","tags":null,"title":"丧"},{"categories":null,"contents":" 869. 重新排序得到 2 的幂 难度中等\n给定正整数 N ，我们按任何顺序（包括原始顺序）将数字重新排序，注意其前导数字不能为零。\n如果我们可以通过上述方式得到 2 的幂，返回 true；否则，返回 false。\n示例 1：\n1 2 输入：1 输出：true 示例 2：\n1 2 输入：10 输出：false 示例 3：\n1 2 输入：16 输出：true 示例 4：\n1 2 输入：24 输出：false 又是一个常规的dfs回溯\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 class Solution { int flag=0; public boolean reorderedPowerOf2(int n) { int list[]=new int [10]; int i=0; while(n\u0026gt;0){ list[i]=n % 10; n/=10; i++; } System.out.println(i); dfs(list,0,i); return flag==1; } void dfs(int list[],int start,int len){ if(start==len){ int ans=0; for(int j=0;j\u0026lt;len;j++){ if(ans==0\u0026amp;\u0026amp;list[j]==0) return;//先导0 else if(ans==0) ans=list[j]; else ans=10*ans+list[j]; } if(isPowerOfTwo(ans)) flag=1; return; } for(int i=start;i\u0026lt;len;i++){ swap(list,start,i); dfs(list,start+1,len); swap(list,i,start); } return ; } void swap(int list[],int s,int d){ int temp=list[s]; list[s]=list[d]; list[d]=temp; } boolean isPowerOfTwo(int n) { //参考2的幂那一题 if(n==0) return false; if(n==1) return true; while(((n\u0026gt;\u0026gt;1)\u0026lt;\u0026lt;1)==n){ n=n\u0026gt;\u0026gt;1; if(n==1) return true; } return false; } } ","date":"2021-10-28T00:39:21+08:00","permalink":"https://junling.li/leetcode/869.%E9%87%8D%E6%96%B0%E6%8E%92%E5%BA%8F%E5%BE%97%E5%88%B02%E7%9A%84%E5%B9%82/","section":"LeetCode","tags":["Leetcode","Medium"],"title":"869.重新排序得到 2 的幂"},{"categories":null,"contents":" 301. 删除无效的括号 难度困难\n给你一个由若干括号和字母组成的字符串 s ，删除最小数量的无效括号，使得输入的字符串有效。\n返回所有可能的结果。答案可以按 任意顺序 返回。\n示例 1：\n1 2 输入：s = \u0026#34;()())()\u0026#34; 输出：[\u0026#34;(())()\u0026#34;,\u0026#34;()()()\u0026#34;] 示例 2：\n1 2 输入：s = \u0026#34;(a)())()\u0026#34; 输出：[\u0026#34;(a())()\u0026#34;,\u0026#34;(a)()()\u0026#34;] 示例 3：\n1 2 输入：s = \u0026#34;)(\u0026#34; 输出：[\u0026#34;\u0026#34;] 提示：\n1 \u0026lt;= s.length \u0026lt;= 25 s 由小写英文字母以及括号 '(' 和 ')' 组成 s 中至多含 20 个括号 今天也是一个dfs，暴力搜索，照着模板写就可以了，需要注意\n剪枝技巧\n一旦检测到不满足有效的括号，即可退出，注意先跳出for循环，别直接return\n当没有处理的lrm和rrm大于剩下的字符串长度时，即可退出（我没写）\n（去重技巧）检测到连续的左括号或者右括号，只用取第一个就可以了\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 class Solution { HashSet\u0026lt;String\u0026gt; ans=new HashSet\u0026lt;\u0026gt;(); public List\u0026lt;String\u0026gt; removeInvalidParentheses(String s) { int lrm=0,rrm=0; for(int i=0;i\u0026lt;s.length();i++){ if(s.charAt(i)==\u0026#39;(\u0026#39;){ lrm++; }else if(s.charAt(i)==\u0026#39;)\u0026#39;){ if(lrm==0){ rrm++; }else lrm--; } } dfs(s,lrm,rrm,0,0,0); List\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;String\u0026gt;(ans); return list; } void dfs(String s,int lrm,int rrm,int donel,int doner,int start){ //必须要加上start因为前面的搜索过了后面就不需要搜索了 // System.out.println(\u0026#34;dfs\u0026#34;+s); if(lrm==0\u0026amp;\u0026amp;rrm==0){ if(isVaild(s)) ans.add(s); return; } if(lrm\u0026lt;0||rrm\u0026lt;0) return; for(int i=start;i\u0026lt;s.length();i++){ if(s.charAt(i)==\u0026#39;(\u0026#39;){ if(lrm\u0026gt;0){ dfs(s.substring(0,i)+s.substring(i+1,s.length()),lrm-1,rrm,donel,doner,i); } donel++; } if(s.charAt(i)==\u0026#39;)\u0026#39;){ if(rrm\u0026gt;0){ dfs(s.substring(0,i)+s.substring(i+1,s.length()),lrm,rrm-1,donel,doner,i); } doner++; } int rm=lrm+rrm; if(doner\u0026gt;donel){ break; } } } Boolean isVaild(String s){ int l=0,r=0; for(int i=0;i\u0026lt;s.length();i++){ if(s.charAt(i)==\u0026#39;(\u0026#39;)l++; else if(s.charAt(i)==\u0026#39;)\u0026#39;){ if(l\u0026gt;0) l--; else if(l==0) return false; } } return true; } } ","date":"2021-10-27T22:49:20+08:00","permalink":"https://junling.li/leetcode/301.%E5%88%A0%E9%99%A4%E6%97%A0%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/","section":"LeetCode","tags":["Leetcode","Difficult"],"title":"301. 删除无效的括号"},{"categories":null,"contents":"dfs回溯\n如何将1-9个数字排序？\n我们拿123来举例，\n可以设置一个函数，通过递归调用的方式完成排序功能\n将数组divide两半，排序过的和没排序过的。\n第一子树取1 没排序的是2 3 接下来调用自身对2 3进行排序，\n第二子树取2 没排序的是1 3 接下来调用自身对1 3进行排序，\n第二子树取3 没排序的是2 3 接下来调用自身对2 3进行排序，\n那么会有一个问题，取了2以后，我怎么知道没取的是2？可以将2移到已取的序列中，即移到本次递归的已排序序列的最后一个。我们用first来区隔已取和未取。\n递归退出的条件是所有的数都在已排序的序列中。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 output=[1,2,3,4,5,6,7,8,9]; dfs(1,9,output) function dfs(first,n,output) if(output(5)==1||output(1)\u0026gt;4||output(4)==1||output(9)==1) %%分析容易得知，第二个乘数不可能为1，并且第一个乘数的千位不可能大于等于5 %%需要做一些预处理工作才能达到剪枝的目的。预处理工作虽然也消耗时间，但能够剪枝节约的时间更多； return end %%从这里开始都是剪枝 firstnum=output(1)*1000+output(2)*100+output(3)*10+output(4); z=firstnum*output(5); if z \u0026gt; 9876 return; else a6=fix(z/1000); a7=fix((z-a6*1000)/100); a8=fix((z-a6*1000-a7*100)/10); a9=fix(z-a6*1000-a7*100-a8*10); if a6==a7||a6==a8||a6==a9||a7==a8||a7==a9||a8==a9 return end end %%以上是剪枝 if(first+1==n) isAns(output) return end for i=first:n temp=output(i); output(i)=output(first); output(first)=temp; %用来交换output数组中索引first和i元素，移到本次递归的已排序序列的最后一个 dfs(first+1,9,output); temp=output(i); output(i)=output(first); output(first)=temp; %用来交换output数组中索引first和i元素，这一步为回溯的关键！ end end function isAns(output) %用来判断是否找到结果 %即output的前4位乘第五位是否等于后4位 first=output(1)*1000+output(2)*100+output(3)*10+output(4); last=output(6)*1000+output(7)*100+output(8)*10+output(9); if first*output(5)==last fprintf(\u0026#39;%d * %d = %d\\n\u0026#39;,first,output(5),last) end end 一些优化，回溯，用于对空间进行优化\n搜索问题的状态空间一般很大，如果每一个状态都去创建新的变量，时间复杂度是 O(N)O(N)。在候选数比较多的时候，在非叶子结点上创建新的状态变量的性能消耗就很严重。\n","date":"2021-10-23T21:05:28+08:00","permalink":"https://junling.li/posts/%E5%85%A8%E6%8E%92%E5%88%97matlab/","section":"posts","tags":null,"title":"全排列"},{"categories":null,"contents":"拥有一个i@junling.li真的是太酷啦，如果主站和邮箱的域名都相同也方便记忆。\n虽然我不像某些人对邮箱域名非常敏感，特别是怎么有人会反感QQ邮箱啊，我觉得QQ邮箱绑定微信的推送很好啊，实时推送不香吗？非要Gmail有逼格上都上不去，非要超长的edu邮箱记不住，虽然腾讯可能活不到100年，但是哪家邮箱能存在100年呢，说不定被其他的通讯工具取代了呢。“越过长城，走向世界”这句话也仅仅发送了34年呐。根据邮箱来识人不可取，这也算是生活中的逻辑错误吧。\n言归正传，如何才能有i@xx.xxx的邮箱捏？\n首先，你得有个域名，这个可以去godaddy或者阿里云 namesilo，腾讯云上申请，.xyz .top .moe价格也不贵,5-10￥/year。然后去DNS解析商为你的邮箱服务器添加一条的MX记录就行了。\n邮箱服务器自己搭好像也行，用黑群晖试了下，可以以任意的自定义的地址发邮件，就是不一定能保证其他能投递到你的自建服务器收到，可能端口被封了。\n俺使用的是腾讯的域名邮箱，也就是QQ企业邮箱。\n(netease也有http://app.ym.163.com/ym/reg/view/index)\n虽然没有企业，但也可以白嫖一个基础款。还要注册一个企业微信，然后设立一个公司（组织），这里你只需起一个名字就行，并不要你真的建个公司，做完以后，你就可以使用企业微信的所有服务了，管理1-50人的小团队了。（不知不觉中为企业微信引流）\n最重要的一步当然是为你的域名邮箱添加mx解析了（这样别人才能根据你的域名找到邮箱服务器的ip地址）\n由于我一直用的是dnspods的解析，都是腾讯家的一键就完成了，dns记录秒生效。2023-5-10注册了一个cf账号，以后可能会用cloudfare？\n其他域名服务商需要手动设置\n腾讯企业邮箱要求设置的MX记录如下： 邮件服务器名：mxbiz1.qq.com 优先级：5 邮件服务器名：mxbiz2.qq.com 优先级：10\n之后就能自由地管理域名下的邮箱了。\n2022.8.22更新\n最近尝试了 网易的域名邮箱，还行，就是发Gmail的时候容易进入垃圾箱\n2023.1 更新\n不用网易域名邮箱了，灵犀办公真的不好用，每次登录登不上，不推荐\n","date":"2021-10-14T09:05:28+08:00","permalink":"https://junling.li/posts/%E5%9F%9F%E5%90%8D%E9%82%AE%E7%AE%B1/","section":"posts","tags":null,"title":"如何拥有一个域名邮箱？"},{"categories":null,"contents":"今天尝试使用gdb调试，相比ide的调试没那么容易好上手\n对于一个cpp文件\n1 g++ test.cpp -o test -g 记得一定要在编译时带-g参数，编译完成以后，使用gdb对生成可执行文件进行调试\nl可以查看需要 调试的文件\nbreak/b 4表示在第4行设置断点\nbreak filename:\u0026lt; function \u0026gt; 在名称为filename的文件中的function函数入口处打断点 break *address 在程序运行的内存地址处打断点\nrun/程序就会运行到断点处\ndisplay i表示显示变量i的值\nnext/n 1表示运行下一行\nsi会进入函数内部\nlayout asm\nlayout src\nlist/l 3 可以使用list/l命令查看程序，方便我们添加断点时查看信息。\nbreak … if \u0026lt; condition\u0026gt; 在处理某些循环体中可使用此方法进行调试，其中…可以是上述的break lineNumber、break +offset/break -offset中的参数，其中condition表示条件，在条件成立时程序即停止运行，如设置break if i=100表示当i为100时程序停止运行。\n查看断点时，也可以使用info命令如info breakpoints [n]、info break [n]其中n 表示断点号来查看断点信息。\n好像不能在内联汇编里面打断点\n逐步调试命令 next \u0026lt; count\u0026gt;。单步跟踪，如果有函数调用不会进入函数，如果后面不加count表示一条一条的执行，加count表示执行后面的count条指令， step \u0026lt; count\u0026gt;。单步跟踪，如果有函数调用则进入该函数（进入该函数前提是此函数编译有Debug信息）,与next类似，其不加count表示一条一条执行，加上count表示自当前行开始执行count条代码指令 set step-mode.set step-mode on用于打开step-mode模式，这样在进行单步跟踪时，程序不会因为没有debug信息而不停止运行，这很有利于查看机器码，可以通过set step-mode off关闭step-mode模式 finish。运行程序直到当前函数完成并打印函数返回时的堆栈地址和返回值及参数值等信息。 until。运行程序直到退出循环体 stepi(缩写si)和nexti(缩写ni)。stepi和nexti用于单步跟踪一条及其指令，一条程序代码有可能由数条机器指令完成，stepi和nexi可以单步执行机器指令。\ncontinue/c命令 当程序遇到断点停止运行后可以使用continue命令恢复程序的运行到下一个断点或直到程序结束。\nprint/p 显示指定变量\np $rax查看寄存器请查看：https://blog.csdn.net/linuxheik/article/details/17380767\nwatch命令 watch命令一般来观察某个表达式(变量也可视为一种表达式)的值是否发生了变化，如果由变化则程序立即停止运行，其具体用法如下：watch \u0026lt; expr\u0026gt; 为表达式(变量)expr设置一个观察点一旦其数值由变化，程序立即停止运行 rwatch \u0026lt; expr\u0026gt; 当表达式expr被读时，程序立即停止运行 awatch \u0026lt; expr\u0026gt; 当表达式expr的值被读或被写时程序立即停止运行 info watchpoints 列出当前所设置的所有观察点\nreturn命令 如果在函数中设置了调试断点，在断点后还有语句没有执行完，这个时候我们可以使用return命令强制函数忽略还没有执行的语句并返回。可以直接使用return命令用于取消当前函数的执行并立即返回函数值，也可以指定表达式如 return \u0026lt; expression\u0026gt;那么该表达式的值会被作为函数的返回值。\ninfo命令 info命令可以用来在调试时查看寄存器、断点、观察点和信号等信息。其用法如下：\ninfo registers:查看除了浮点寄存器以外的寄存器\ninfo all-registers: 查看所有的寄存器包括浮点寄存器\ninfo registers \u0026lt; registersName\u0026gt;:查看指定寄存器\ninfo break: 查看所有断点信息 info watchpoints: 查看当前设置的所有观察点 info signals info handle: 查看有哪些信号正在被gdb检测 info line: 查看源代码在内存中的地址 info threads: 可以查看多线程\nfinish命令 执行完当前的函数。\nrun(缩写r)和quit(缩写q)分别可以开始运行程序和退出gdb调试\nwhatis或ptype显示变量的类型\nbt显示函数调用路径\n回到过去record full\n查看内存 使用examine（简写x）来查看内存地址中的值。语法： x/ n、f、u是可选的参数。 （1）n 是一个正整数，表示显示内存的长度，也就是说从当前地址向后显示几个地址的内容。 （2）f 表示显示的格式，参见上面。如果地址所指的是字符串，那么格式可以是s，如果地十是指令地址，那么格式可以是i。 （3）u 表示从当前地址往后请求的字节数，如果不指定的话，GDB默认是4个bytes。u参数可以用下面的字符来代替，b表示单字节，h表示双字节，w表示四字 节，g表示八字节。当我们指定了字节长度后，GDB会从指内存定的内存地址开始，读写指定字节，并把其当作一个值取出来。 eg:\nx/3uh 0x54320 ：从内存地址0x54320读取内容，h表示以双字节为一个单位，3表示三个单位，u表示按十六进制显示。\n","date":"2021-09-28T15:35:49+08:00","permalink":"https://junling.li/posts/gdb%E8%B0%83%E8%AF%95/","section":"posts","tags":["GNU"],"title":"Gdb调试"},{"categories":null,"contents":" 103. 二叉树的锯齿形层序遍历 难度中等525\n给定一个二叉树，返回其节点值的锯齿形层序遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。\n例如： 给定二叉树 [3,9,20,null,null,15,7],\n1 2 3 4 5 3 / \\ 9 20 / \\ 15 7 返回锯齿形层序遍历如下：\n1 2 3 4 5 [ [3], [20,9], [15,7] ] 通过次数173,983\n提交次数304,411\n这一题的坑还是非常多的，没有那么容易。最初想法是改一改层序遍历的代码就行了，想用一个队列完成，根据flag决定出队列的顺序。发现不行，因为队列是一遍增加一遍移出的。入上图当队列是[9 20]，从尾部移出得到20，9.看起来没错，但是在移出9时，又像队列的尾部增加了15和7，队列变成了[9 15 7]再移出尾部就错了。\n这是想通过双队列的方式，增加到新的队列中，在移出9时，[15 7]在下一个队列。看起来比较完美，一试又不对。试想移出9时插入[15 7] 再移出20时，插入了20的子节点（这里假设它有2个子节点 1 2），会发现倒序的里面，是左节点，右节点的顺序，很奇怪。此时又想过根据flag实现从右到左，但是这似乎让顺序直接变成倒叙的队列，下一行就不必改变出队列的顺序，一直倒序出就可以了。\n但是这种太麻烦，我最后还是用了顺序的bfs，但是根据flag的值，让输出的值取反，实现不对bfs的过程做出任何改变，较为简易。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 class Solution { public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; zigzagLevelOrder(TreeNode root) { ArrayList\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; ans=new ArrayList\u0026lt;\u0026gt;(); if(root==null) return ans; LinkedList\u0026lt;TreeNode\u0026gt; queue=new LinkedList\u0026lt;\u0026gt;(); LinkedList\u0026lt;TreeNode\u0026gt; queueNext=new LinkedList\u0026lt;\u0026gt;(); LinkedList\u0026lt;TreeNode\u0026gt; queueCopy=new LinkedList\u0026lt;\u0026gt;(); ArrayList\u0026lt;Integer\u0026gt; zigzag=new ArrayList\u0026lt;\u0026gt;(); queue.add(root); queueCopy.add(root); int flag=1; int cur=1; int next=0; zigzag=new ArrayList\u0026lt;\u0026gt;(); while(!queue.isEmpty()\u0026amp;\u0026amp;!queueCopy.isEmpty()){ TreeNode t=null; TreeNode tcopy=null; if(flag==1){t=queue.removeFirst();} else if(flag==-1){t=queue.removeLast();} tcopy=queueCopy.poll(); zigzag.add(t.val); cur--; if(tcopy.left!=null){ queueNext.add(tcopy.left); next++; } if(tcopy.right!=null){ queueNext.add(tcopy.right); next++; } if(cur==0){ ans.add(zigzag); // System.out.println(queueNext); zigzag=new ArrayList\u0026lt;\u0026gt;(); flag=-flag; queue=new LinkedList(queueNext); queueCopy=new LinkedList(queueNext); // 注意不能传地址：queue=queueNext 这样会使queue 和queueNext指向的是同一个地址 queueNext.clear(); cur=next; next=0; } } return ans; } } ","date":"2021-09-28T09:49:20+08:00","permalink":"https://junling.li/leetcode/103.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%94%AF%E9%BD%BF%E5%BD%A2%E9%81%8D%E5%8E%86/","section":"LeetCode","tags":["Leetcode","Medium"],"title":"103. 二叉树的锯齿形层序遍历"},{"categories":null,"contents":"今天是辛丑年中秋节，古人选择每年月亮最圆的日子，作为节日来庆祝，并期冀着这一天假日能够团圆，吃月饼，赏明月，在我看来，中秋的节日氛围是仅次于春节的。\n苏东坡的《水调歌头》，算是中秋诗词的顶峰。我没多少文化，只能祝大家中秋节快乐。不像大师能写就\n“但愿人长久，千里共婵娟”这样的流传千古的名句。\n今天去了大熊猫基地，见到被关在一座山上的十几只大熊猫，享受着高于人类平均水平的生活条件。虽然大熊猫的算是萌物，也确实憨态可掬，确实珍贵。但却失去了自由。用自由换取活着的代价，然而被圈养的熊猫，还是原来的熊猫吗？随着人类居住生产范围的扩张和改造自然的能力的增强，野生动物生存环境逐步缩小。圈起来保护确实是最好的办法了。但是除了熊猫的其他野生动物就没有这么好的条件了。人类也没法对所有野生动物一视同仁，算是一种“偏见”吧。\n大熊猫基地的体验良好，没有特别地商业化，从地铁站到熊猫基地有专门的大巴接送，一路上都有人提醒戴好口罩，也没有多少坑钱的项目，两个小时就能全部逛完。总体上我是给好评的，是成都几个值得一去的好地方。\n没有长焦的手机拍不了月亮，所以今天晚上只能朋友圈赏月了。虽然月亮几乎天天能见到“何夜无月，何处无竹柏”，但是今天的月亮还是有些许特殊的。大家一同赏月，不是同一个地点 ，但是同一个世界，都希望能借助这轮明月，将自己的思念之情传达到远方。\n","date":"2021-09-21T23:35:19+08:00","permalink":"https://junling.li/life/%E8%BE%9B%E4%B8%91%E4%B8%AD%E7%A7%8B%E8%8A%82/","section":"life","tags":null,"title":"辛丑中秋节"},{"categories":null,"contents":"很久以前发现在浏览器里直接粘贴url就能自动下载码图提交的文件。而且是没有权限的，意味着你能下载到所有码图提交。而且对于请求次数也是没有限制的。\n比如在已经登录码图的浏览器中复制这个url：http://matu.uestc.edu.cn/aptat/file/downloadassignmentfile?assignmentid=1038358\n浏览器就会自动下载这个文件。\n这时候就有人好奇了，把assignmentid改成1038357会怎么样？会下载到另一个人的提交，这一个提交是在你之前的最近一个提交。\n最早的提交我看到id=72650，是2015年9月10号的提交，来自学号20140601xxxx的学长，题目是20_生成前n个自然数的一个随机置换。\n那么能不能把所有的码图提交都下载下来呢？只要借助一个叫Open multiple url at one click的chrome插件，将你所想要下载的码图文件url贴进去，chrome就会给你下载了。\n那么，假如我没有登录matu怎么办，或者我没有浏览器怎么办，又或是我能不能把码图的所有提交下载下来呢？\n那应该怎么做呢，码图会拦截没有登录的请求，这时就要用cookies骗过matu了，借助代理软件，可以看到\nget请求会带header，其中有cookie字段\n1 Cookie:\tJSESSIONID=ADCFAD008D39D46910DB82255253AD2E; III_EXPT_FILE=aa48738; III_SESSION_ID=d55956838bd4bf7c44eae6dbedc5d20a; SESSION_LANGUAGE=eng; zg_did=%7B%22did%22%3A%20%221784dfce5e2433-04d99af797b1f2-5771133-fa000-1784dfce5e3d03%22%7D; zg_=%7B%22sid%22%3A%201625496021694%2C%22updated%22%3A%201625496021698%2C%22info%22%3A%201625496021697%2C%22superProperty%22%3A%20%22%7B%7D%22%2C%22platform%22%3A%20%22%7B%7D%22%2C%22utm%22%3A%20%22%7B%7D%22%2C%22referrerDomain%22%3A%20%22eportal.uestc.edu.cn%22%2C%22cuid%22%3A%20%222019081305013%22%2C%22zs%22%3A%200%2C%22sc%22%3A%200%2C%22firstScreen%22%3A%201625496021694%7D; iPlanetDirectoryPro=tH0Ds91VHf5CpQJkwG4p3v 只要在请求头加上这个字段，就可以骗过拦截器了。\n写了一个java程序\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 package matudownload; import com.sun.net.httpserver.Headers; import org.jsoup.Connection; import org.jsoup.Jsoup; import org.jsoup.nodes.Document; import org.jsoup.nodes.Element; import java.io.*; public class downLoad { public static void download(String url,String filepath,String cookie)throws Exception { Connection con=Jsoup.connect(url); con.header(\u0026#34;Cookie\u0026#34;,cookie); Connection.Response res=con.method(Connection.Method.GET).execute(); String head=res.header(\u0026#34;content-disposition\u0026#34;); String str=new String(head1.getBytes(\u0026#34;ISO-8859-1\u0026#34;),\u0026#34;GBK\u0026#34;); //注意http请求的header要求其中文必须为iso8859-1编码，此时需要转化成gbk编码 str=str.toString().substring(21,str.length()-1); BufferedWriter bw = new BufferedWriter (new OutputStreamWriter(new FileOutputStream(filepath))); bw.write(new String(res.body().toString())); bw.flush(); bw.close(); } public static void main(String[] args) { try { String cookie=\u0026#34;\u0026#34;; //cookie需要你从已登陆matu的浏览器中获取 download(\u0026#34;http://matu.uestc.edu.cn/aptat/file/downloadassignmentfile?assignmentid=1038000\u0026#34;,\u0026#34;D:/download\u0026#34;,cookie); } catch (Exception e) { e.printStackTrace(); } } } 我在github仓库上传了1038000-1038530的530个提交，大家可以参考别人的matu提交代码互相学习。\nhttps://github.com/BachWV/matu/tree/main/allMatuCommit\n至于部分码图考试能不能用这种方法抄到别人的提交，我不知道，也希望码图早日把这个漏洞给补上。\n","date":"2021-09-20T15:57:28+08:00","permalink":"https://junling.li/posts/%E6%80%8E%E4%B9%88%E6%9C%89%E4%BA%BA%E7%94%A8%E7%A0%81%E5%9B%BE%E5%95%8A/","section":"posts","tags":null,"title":"怎么有人用码图啊"},{"categories":["算法"],"contents":"一个二进制数中有多少个1 我只能想到用移位消去最小的1的方法\n时间复杂度为i中1的个数的做法 1 2 3 4 5 6 7 8 9 10 public int hammingWeight(int n) { int ans=0; while(n!=0){ ans++; n=n\u0026amp;(n-1); } return ans; } java 本身也提供了这个方法，所以就来看看底层的源码。 这个方法非常有意思，我已经被迷住了，源码的分析部分来自于\nhttps://blog.csdn.net/weixin_42092787/article/details/106607426\n1 2 3 4 5 6 7 8 9 public static int bitCount(int i) { // HD, Figure 5-2 i = i - ((i \u0026gt;\u0026gt;\u0026gt; 1) \u0026amp; 0x55555555); i = (i \u0026amp; 0x33333333) + ((i \u0026gt;\u0026gt;\u0026gt; 2) \u0026amp; 0x33333333); i = (i + (i \u0026gt;\u0026gt;\u0026gt; 4)) \u0026amp; 0x0f0f0f0f; i = i + (i \u0026gt;\u0026gt;\u0026gt; 8); i = i + (i \u0026gt;\u0026gt;\u0026gt; 16); return i \u0026amp; 0x3f; } 简单来说，源码非常非常巧妙的利用了 位运算的性质，大概我这辈子也想不到吧。\n我们从最后的落脚点出发，或许更能理解这种思路：\nreturn i \u0026amp; 0x3f; 0x3f 十六进制转为二进制是：\n十六进制\t二进制 0x3f\t00 00 00 00 00 00 00 00 00 00 00 00 00 11 11 11 这时候我们想一下这行代码，对于 0x3f 来说，它和变量 i 做 与 运算，得到的最大结果也就是 0x3f 本身，也就是二进制 111111 ，对应 十进制是 63。\n这是什么意思呢？\n对于 输入 n ，即使这个数字的二进制表达占满了 32 位比特 且全都是 1，那么这条语句的功能，数 1 的个数，结果最多也就是 32 ，对应二进制表达是 100 000，长度为 6 位。\n所以这一点上，这种方法的计算过程保证了有效位足够，另一方面保证，最终返回的是 前面计算结果的最后六位的值，去掉了高位上面的干扰。\n而这整个代码也都是基于这种思想的，逐渐缩小有效位的范围\n我们先总结一下代码中的十六进制数：\n十六进制\t二进制 0x55555555\t01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 0x33333333\t00 11 00 11 00 11 00 11 00 11 00 11 00 11 00 11 0x0f0f0f0f\t00 00 11 11 00 00 11 11 00 00 11 11 00 00 11 11 接着一行一行来看代码。\n第一行代码 i = i - ((i \u0026gt;\u0026gt;\u0026gt; 1) \u0026amp; 0x55555555); 我直接告诉你，它完成的功能叫做，每两位进行一次统计，统计 1 的个数，并把结果放在对应的原来位置上。\n1. i \u0026raquo;\u0026gt; 1 是将 i 无符号右移一位 2. 0x55555555 是 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 3. 右移后 和 0x55555555 进行按位与操作 4.再用 i 减去 “3” 的结果 上面的 “1” 想一想：对于一个 32 位的数 i ，右移一位之后，第 2、4、6、……、32位的数字，分别跑到了第 1、3、5、……、31位上，也就对应到了 0x55555555 的 所有 1 的位置。\n上面的 “2” 和 “3” i 在右移之后和 0x55555555 进行 与 操作，就会得到原来 i 的第 2、4、6、……、32 位上的所有真实的值；同时，第 1、3、5、……、31位上的值都和 0 进行与操作之后变成了0。（到这里还看不出这么做的意义，别着急，看下一步）\n上面的 “3” 重点来了，接着用 i - （2 和 3 的结果）会发生什么事？\n一个二进制两位的数字，可能的形式有：00,01,10,11. 右移之后分别和 01 进行与运算，得到： 00,00,01,01. 用原来的数减去右移后的，就能够得到： 00,01,01,10.\n观察一下结果可以发现：每两位的数值 就表示了以前这两位上 有 1 的个数\n（这里可以回头想一想，先和0x55555555 进行 与 操作是非常必要的，因为如果仅仅右移，第 3 位如果有 1，右移之后会占用第二位，会影响统计结果，因此必须把这些位都通过和 0 的与操作清零。）\n第二行代码 i = (i \u0026amp; 0x33333333) + ((i \u0026gt;\u0026gt;\u0026gt; 2) \u0026amp; 0x33333333); 第二行和第一行的本质思路是一样的，进一步扩大范围，统计原始 i 每 4 位上 1 的个数。\n1. 0x33333333 是 00 11 00 11 00 11 00 11 00 11 00 11 00 11 00 11 2. i 和 0x33333333 进行按位与操作 3. i 右移两位，再和 0x33333333 进行按位与操作 4.将 “ 2 ” 和 “ 3 ” 的结果相加 上面的 “1” 和 “2” 和 0x33333333 进行 与 操作，就会得到第一行代码运行之后 的第 1 2、5 6、9 10、……、29 30 位上的所有真实的值；同时，第 3 4、7 8、11 12、……、31 32位上的值都和 00 与之后变成了00。\n上面的 “3” 和只有 两位 的二进制数的减法性质不同，所以这里不能再使用减法。 那么丢掉的那一半位置的数字还是需要找回来的。怎么办呢\ni 右移两位，第 3 4、7 8、11 12、……、 31 32 位上的值跑到了 第 1 2、5 6、9 10、……、 29 30位上。此时再做了一边和 “2” 一样的事情，这就得到了第一行代码运行之后的第 3 4、7 8、11 12、……、 31 32 位上的真实的值。\n上面的 “4” 简单相加，功能完成。（直接相加不用考虑进位吗？答案是不用，原来的数字 每四位上面 1 的个数最多是 4 个，对应成二进制是 100 ，只会占用 3 个二进制位。）\n可以回头想想。源数字 i 的 每四位上面 1 的个数，已经被统计出来了，替换在了对应的位置上。\n第三行代码 i = (i + (i \u0026gt;\u0026gt;\u0026gt; 4)) \u0026amp; 0x0f0f0f0f; 这一步，要开始统计 原始数字 i 每 8 位上面 1 的个数。我们可以看到代码的方式又变了。 （和第二行写法不一样，但其实第三行可以写成和第二行一样的格式；第二行却不能写成第三行这样的形式，大家可以想想为什么）\n1. 将 i 右移四位，再与 i 相加 2.0x0f0f0f0f 的二进制表达是 0000 1111 0000 1111 0000 1111 0000 1111 3.将第一步的结果 和 0x0f0f0f0f 进行与操作 上面的 “1” 对其相加个数的时候，显然要以低位为准，所以第 5 6 7 8 、13 14 15 16、20 21 23 24、29 30 31 32 位的数字，挪到了 1 2 3 4 、 9 10 11 12、17 18 19 20 、25 26 27 28 位上，对应相加。\n这里的加和，最多不会超过 8 ，对应二进制是 1000，（因为源数字 i 每 8 位上面 1 个数不会超过 8）所以直接加也不会产生错误。\n上面的 “2” 和“3” 和 0x0f0f0f0f 进行 与 操作，就会得到源数字 i 每 8 位上面 1 的个数，存储在了第 1 2 3 4 、 9 10 11 12、17 18 19 20 、25 26 27 28位上。而第 5 6 7 8 、13 14 15 16、20 21 23 24、29 30 31 32 位一定是 0.\n第四行和第五行代码\n1 2 i = i + (i \u0026gt;\u0026gt;\u0026gt; 8); i = i + (i \u0026gt;\u0026gt;\u0026gt; 16); 这两行，完成的是一个功能，也就是把源数字 i 每 16 位上面 1 的个数，存储在了 1~16位上。（此时没有做第17~32位的清零）\n当然，如果按照前几步的思路，你当然可以把这两行代码替换成：\ni = i + (i \u0026gt;\u0026gt;\u0026gt; 8) \u0026amp; ‭FF00FF‬; 这行是我想的，但经过验证可以达到一样的效果，因为 ‭FF00FF‬ 的二进制表达是： ‭0000 0000 1111 1111 0000 0000 1111 1111‬\n不过显然原作者的做法更巧妙，毕竟直接右移16位就能达到效果。\n第六行代码 return i \u0026amp; 0x3f; 回到最开始我们对这一步的分析，源数字 i 作为32位二进制数字，1 的个数就最多 32 而已。\n那么代码的意义显而意见。 最终就会返回 原始输入 i 的二进制形式上 1 的个数。\n总结一下，如果这道题交给我们来做，即使是位运算，按位与 和 用了 n\u0026amp;(n-1) 这两种方法，最差的情况下都是要运行 32 次位运算的，但是底层源码的方法，却是恒定只进行 6 次计算。不得不说真实优秀。\n相信我讲的很清楚了，希望对大家有帮助。（苦心成果，转载请标明出处 ———————————————— 版权声明：本文为CSDN博主「JohnArchie」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。 原文链接：https://blog.csdn.net/weixin_42092787/article/details/106607426\n我的理解 第一行代码：将每两位的 1 的个数统计，并把结果每两位保存，例如1101一个有3个1，高2位(11)中1的个数为2(01)，低2位(01)的个数为1(01),最后保存的结果为0101 i=0010010100101011\n0001001010010101 (i\u0026raquo;\u0026gt;1)\n0001000000010101(i\u0026raquo;\u0026gt;1\u0026amp;0x5555555)\n0001010100010110\n第二行代码：将将每4位的 1 的个数统计，并把结果每4位保存\n0001010100010110(i)\n0000010101000101(i\u0026raquo;\u0026gt;2)\n0011001100110011\n0000000100000001(i\u0026raquo;\u0026gt;2\u0026amp;0x3333333333)\n0001000100010010(i\u0026amp;0x333333333)\n0001001000010011\n相当于对i=0001010100010110每隔两位提出来：\n0001000100010010(i\u0026amp;0x333333333)\n0001001000010011\n每4位得到四位 的1的值\n第三行代码：将将每8位的 1 的个数统计，并把结果每8位保存\n0000111100001111\n0000001100000100\n每8位表示8位 的1的数量\n0000000000000011(i\u0026raquo;\u0026gt;8)\n0000000000000100\n0000000000000111\n这样就得到一共有7个1.\n异或的性质： 110=100^10\n观察这三个数110 100 10\n任意两个异或的结果是另外一个数：\n110^100=10\n110^10=100\n1720. 解码异或后的数组 难度简单80\n未知 整数数组 arr 由 n 个非负整数组成。\n经编码后变为长度为 n - 1 的另一个整数数组 encoded ，其中 encoded[i] = arr[i] XOR arr[i + 1] 。例如，arr = [1,0,2,1] 经编码后得到 encoded = [1,2,3] 。\n给你编码后的数组 encoded 和原数组 arr 的第一个元素 first（arr[0]）。\n请解码返回原数组 arr 。可以证明答案存在并且是唯一的。\n示例 1：\n1 2 3 输入：encoded = [1,2,3], first = 1 输出：[1,0,2,1] 解释：若 arr = [1,0,2,1] ，那么 first = 1 且 encoded = [1 XOR 0, 0 XOR 2, 2 XOR 1] = [1,2,3] 示例 2：\n1 2 输入：encoded = [6,2,7,3], first = 4 输出：[4,2,0,7,4] 提示：\n2 \u0026lt;= n \u0026lt;= 104 encoded.length == n - 1 0 \u0026lt;= encoded[i] \u0026lt;= 105 0 \u0026lt;= first \u0026lt;= 105 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public int[] decode(int[] encoded, int first) { int n=encoded.length; int []ans=new int[n+1]; ans[0]=first; for(int i=1;i\u0026lt;n+1;i++){ ans[i]=encoded[i-1]^ans[i-1]; } return ans; } } 还有一题：\n371. 两整数之和 难度中等425\n不使用运算符 + 和 - ，计算两整数 a 、b 之和。\n示例 1:\n1 2 输入: a = 1, b = 2 输出: 3 示例 2:\n1 2 输入: a = -2, b = 3 输出: 1 通过次数54,177\n提交次数93,386\n1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public int getSum(int a, int b) { System.out.println(a+\u0026#34; b=\u0026#34;+b); int xor=a^b; int and=(a\u0026amp;b)\u0026lt;\u0026lt;1; System.out.println(and); if(and!=0) xor=getSum(xor,and); return xor; } } ","date":"2021-09-13T20:56:00+08:00","permalink":"https://junling.li/posts/%E5%A4%9A%E5%B0%91%E4%B8%AA1/","section":"posts","tags":null,"title":"多少个1"},{"categories":null,"contents":"11. 盛最多水的容器 给你 n 个非负整数 a1，a2，...，a``n，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0) 。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。\n**说明：**你不能倾斜容器。\n示例 1：\n1 2 3 输入：[1,8,6,2,5,4,8,3,7] 输出：49 解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。 示例 2：\n1 2 输入：height = [1,1] 输出：1 示例 3：\n1 2 输入：height = [4,3,2,1,4] 输出：16 示例 4：\n1 2 输入：height = [1,2,1] 输出：2 提示：\nn == height.length 2 \u0026lt;= n \u0026lt;= 105 0 \u0026lt;= height[i] \u0026lt;= 104 这一题的证明还不是特别理解。给出的题解使用了双指针法。\n核心思想是两个指针向中间缩小，规则是只缩小水桶的最小的板。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public int maxArea(int[] height) { int l=0,r=height.length-1,ans=0; while(l\u0026lt;r){ int temp=0; if(height[l]\u0026gt;height[r]){ temp=(r-l)*height[r]; r--; }else{ temp=(r-l)*height[l]; l++; } System.out.println(temp); ans=Math.max(temp,ans); } return ans; } } 证明过程没怎么看懂：\n若暴力枚举，水槽两板围成面积 S(i, j)S(i,j) 的状态总数为 C(n, 2)C(n,2) 。\n假设状态 S(i, j)S(i,j) 下 h[i] \u0026lt; h[j]h[i]\u0026lt;h[j] ，在向内移动短板至 S(i + 1, j)S(i+1,j) ，则相当于消去了 {S(i, j - 1), S(i, j - 2), \u0026hellip; , S(i, i + 1)}S(i,j−1),S(i,j−2),\u0026hellip;,S(i,i+1) 状态集合。而所有消去状态的面积一定都小于当前面积（即 \u0026lt; S(i, j)\u0026lt;S(i,j)），因为这些状态：\n短板高度：相比 S(i, j)S(i,j) 相同或更短（即 ≤h[i] ）； 底边宽度：相比 S(i, j)S(i,j) 更短； 因此，每轮向内移动短板，所有消去的状态都 不会导致面积最大值丢失 ，证毕。\n作者：jyd 链接：https://leetcode-cn.com/problems/container-with-most-water/solution/container-with-most-water-shuang-zhi-zhen-fa-yi-do/ 来源：力扣（LeetCode） 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n我的理解是，只比较S(i,j)的大的，然后证明舍去的状态比ans里面存的要小。\n","date":"2021-09-10T18:06:12+08:00","permalink":"https://junling.li/leetcode/11/","section":"LeetCode","tags":["Leetcode","Medium"],"title":"11.盛水最多的容器"},{"categories":null,"contents":"I am an undergraduate student\nwith School of Computer Science and Engineering\n.University of Electronic Science and Technology of China(UESTC).\nI wish I could excel in algorithms. You can find my leetcode problem solution on left tag \u0026ldquo;Leetcode\u0026rdquo;.\nI am a fan of GNU/Linux and I use Manjaro and Debian.\nI hope to contribute myself to open sourse software project.\nabout GNU/Linux gdb\nqemu\ncrontab\ntmux\nunix\nffmpeg\ngit\nmanjaro setup\ngithub actions\nOperate System Note Updating I am learning Operate System to increase my understanding of the computer system based on hardware.\nIt\u0026rsquo;s a tough journey and I suffered a lot of difficulties.But in jyy\u0026rsquo;s course, this journey may not be so painful. Jyy\u0026rsquo;s courses are strongly recommended .You can find them on bilibili.\n1 绪论 2 程序就是状态机\n3 多处理器时代状态机模型\n4 互斥算法\n5 互斥锁和自旋锁的实现\n7 真实世界的并发编程\n8 并发 bug 和应对\n9 操作系统的状态机模型和boot\n10 状态机模型的应用\n11 操作系统上的进程\n12 进程的地址空间 13 系统调用和Shell\n14 C标准库的实现 15 fork 的应用 16 什么是可执行文件\n17 动态链接和加载 18 Xv6 代码导读\n19 状态机模型的应用\nTodo list neXt target is cmu15445\nneXt next is 6.824\nCourse notes 计算机体系结构\n编译原理\nProject More content is updating.\n2020 cpp项目\n2021 软件工程项目\n课程设计项目\n2022 信息安全竞赛项目 National Second Prize\nkaggle ranked 46/3046\nContact lijunlin0012@126.com\ni@junling.li\nlijunling2077@gmail.com\nFind me on Github: https://github.com/BachWV\nbilibili: https://space.bilibili.com/36175480\nThis site used to have a lot of content about life, and I removed it. Of course you can still find it in my git commit(you know it is Github pages). Now my life insights have been published on the Weixin Official Account and a private site (you can dig my GitHub to find the site).This site will only share technical content for now.\nWeixin Official Account : 一行瑠璃\ntrigger music server: https://music.junling.li\nbilibili record:http://junling.li:2345 (need password)\nfrp:http://junling.li:7500 (need password)\nIf you wanna to use my private frp server ,you can contact me to get the password.\nabout domain junling.li junling.li and junling.xyz\nNew about-me is building ,you can find a demo on New about me\n","date":"2021-09-09T22:12:07+08:00","permalink":"https://junling.li/about/","section":"","tags":null,"title":"About"},{"categories":["tech"],"contents":"弄了快半年的黑群晖，感觉太难受了，处处受限，想来一个花生壳内网穿透都不行，zerotie没效果，放在docker里也不行，索性放弃，直接咸鱼15块洗白。\n速速开始改sn/mac吧\n1 开放SSH端口 在群晖上操作：控制面板里面——\u0026gt;终端机和SNMP 下，启动SSH功能。端口为22\n2 SSH连接 随便用一个ssh软件连接你的群晖，我一般使用bitvise\nip就是你的群晖的局域网ip，我的是192.168.31.95\n用户名密码就是平时登录的密码(我用admin账户登录的)\n3 cli修改sn/mac 提权 sudo -i ：再次输入当前账号的密码\n在/tmp 目录下创建临时目录 名字随便起 比如boot mkdir -p /tmp/boot\n切换到dev目录，挂载引导分区到boot mount -t vfat synoboot1 /tmp/boot/\n挂载成功以后，切换到/tmp/boot目录，ls以后发现有一个文件夹叫grub\n我们需要修改的就是grub.cfg文件\n看到那个sn和mac了吗，这就是我们目的要改的东西，改成洗白以后的号码，:wq完成！\n4 重启 最后一步：reboot 然后耐心等待即可！\n使用Sysnology assistant重新搜索，即可看到改成了刚才的sn和mac，一般来说不要重新搜索也能用\n之后就可以愉快使用群晖官方服务的了，建议用非国区的账号哦\n参考资料：\nhttps://shimo.im/docs/KwwyWvkqJTrQvhvg/read\n","date":"2021-09-09T21:58:12+08:00","permalink":"https://junling.li/posts/%E4%BB%8E%E9%BB%91%E7%BE%A4%E6%99%96%E8%B5%B0%E5%90%91%E7%99%BD/","section":"posts","tags":null,"title":"从黑群晖走向白"},{"categories":null,"contents":"1567. 乘积为正数的最长子数组长度\n难度中等\n给你一个整数数组 nums ，请你求出乘积为正数的最长子数组的长度。\n一个数组的子数组是由原数组中零个或者更多个连续数字组成的数组。\n请你返回乘积为正数的最长子数组长度。\n示例 1：\n1 2 3 输入：nums = [1,-2,-3,4] 输出：4 解释：数组本身乘积就是正数，值为 24 。 示例 2：\n1 2 3 4 输入：nums = [0,1,-2,-3,-4] 输出：3 解释：最长乘积为正数的子数组为 [1,-2,-3] ，乘积为 6 。 注意，我们不能把 0 也包括到子数组中，因为这样乘积为 0 ，不是正数。 示例 3：\n1 2 3 输入：nums = [-1,-2,-3,0,1] 输出：2 解释：乘积为正数的最长子数组是 [-1,-2] 或者 [-2,-3] 。 示例 4：\n1 2 输入：nums = [-1,2] 输出：1 示例 5：\n1 2 输入：nums = [1,2,3,5,-6,4,0,10] 输出：4 提示：\n1 \u0026lt;= nums.length \u0026lt;= 10^5 -10^9 \u0026lt;= nums[i] \u0026lt;= 10^9 把数组想成1，0，-1三个数组成的，0是分隔数组的标志，\n比如1 1 1 -1 0 1 1 1 0 1 1，可以分成3块，1 1 1 -1；1 1 1；1 1\n下面在每一块中套圈，规定圈中的-1的个数为偶数；\n从第一个数开始套，遇到-1将flag取反，每前进一步length加1，将flag为正的length记录下来，遇到0重置。\n有人可能会问为什么总是从第一个数开始套，万一第一个数字是负数-1 1 1 1怎么办呢？用我的算法会计算成0，可是实际上是3，结果根本不对。\n没事，咱们从后往前遍历一次就行了，-1 1 1 1从后往前数，最大子数组长度不就是3了嘛。\n这样能覆盖所有情况吗？\n对于每块来说，只有偶数个-1 ，奇数个-1两种情况；偶数个-1自然是皆大欢喜，这一块全部算上；奇数个-1就得想一想了：\n1 1 1 -1 1 1 1 1 一眼看出，-1把数组分成两半，左边数组最长为3，右边为4；如果从左边第一个开始遍历答案为3，从右边遍历最大为4，取两次遍历的最大值4即可。\n1 1 1 1 1 -1 1 1 1 -2 1 1 -3 1 1 1对于3 个负数来说的来说，最长的子数组会取-3左边所有数字，或者-1右边的所有数字，是不是从左向右遍历和从右向左遍历两遍就行了呢？\n代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 public int getMaxLen(int[] nums) { int ans=0,lenth=0,flag=1; for(int i=0;i\u0026lt;nums.length;i++){//从左向右遍历 if(nums[i]\u0026lt;0){ lenth++; flag*=-1; }else if(nums[i]==0){ lenth=0; flag=1; }else lenth++; if(flag==1) ans=Math.max(ans,lenth); } int anstemp=ans; ans=0;lenth=0;flag=1; for(int i=nums.length-1;i\u0026gt;=0;i--){//从右向左遍历 if(nums[i]\u0026lt;0){ lenth++; flag*=-1; }else if(nums[i]==0){ lenth=0; flag=1; }else lenth++; if(flag==1){ans=Math.max(ans,lenth);} } return Math.max(anstemp,ans); } ","date":"2021-08-24T21:03:42+08:00","permalink":"https://junling.li/leetcode/1567%E4%B9%98%E7%A7%AF%E4%B8%BA%E6%AD%A3%E6%95%B0%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E6%95%B0%E7%BB%84/","section":"LeetCode","tags":["Leetcode","Medium"],"title":"1567.乘积为正数的最长子数组"},{"categories":null,"contents":"740. 删除并获得点数\n给你一个整数数组 nums ，你可以对它进行一些操作。\n每次操作中，选择任意一个 nums[i] ，删除它并获得 nums[i] 的点数。之后，你必须删除 所有 等于 nums[i] - 1 和 nums[i] + 1 的元素。\n开始你拥有 0 个点数。返回你能通过这些操作获得的最大点数。\n示例 1：\n1 2 3 4 5 输入：nums = [3,4,2] 输出：6 解释： 删除 4 获得 4 个点数，因此 3 也被删除。 之后，删除 2 获得 2 个点数。总共获得 6 个点数。 示例 2：\n1 2 3 4 5 6 输入：nums = [2,2,3,3,3,4] 输出：9 解释： 删除 3 获得 3 个点数，接着要删除两个 2 和 4 。 之后，再次删除 3 获得 3 个点数，再次删除 3 获得 3 个点数。 总共获得 9 个点数。 提示：\n1 \u0026lt;= nums.length \u0026lt;= 2 * 104 1 \u0026lt;= nums[i] \u0026lt;= 104 这一题很迷惑人，什么“每次操作中，选择任意一个 nums[i] ，删除它并获得 nums[i] 的点数。之后，你必须删除 所有 等于 nums[i] - 1 和 nums[i] + 1 的元素。”这都是些什么鬼操作。绕了我那么久，实际上就是打家劫舍。\n不能连着获得两个挨着的点数。\n打家劫舍中，挨着的是数组，nums[1]和nums[2]不能同时存在；这一题中，nums[x]+1和nums[x]不能同时存在，怎么办呢？\n可以把点数映射到另一个数组中，比如 1 1 3 3 3 4 6 8 8 10这9个数，稍微处理一下\n值 1 2 3 4 5 6 7 8 9 10 个数 2 0 3 1 0 1 0 2 0 1 这样就变成了打家劫舍的题目了，不能同时存在相邻的值\ndp[i]=Math.max(dp[i-2]+a[i]*i,dp[i-3]+a[i]*i);\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 public static int deleteAndEarn(int[] nums) { if (nums == null || nums.length == 0) { return 0; } else if (nums.length == 1) { return nums[0]; }else if(nums.length==2){ if(nums[1]==nums[0]){ return 2*nums[0]; }else if(nums[0]-nums[1]==1||nums[0]-nums[1]==-1){ return Math.max(nums[1],nums[0]); } return nums[1]+nums[0]; } Arrays.sort(nums); int n=nums.length; int maxnum=nums[n-1]; int []a=new int[maxnum+1]; for(int i=0;i\u0026lt;n;i++){ a[nums[i]]++; } int []dp=new int[maxnum+1]; System.out.println(Arrays.toString(a)); dp[1]=a[1]*1; dp[2]=a[2]*2; dp[3]=a[3]*3+dp[1]; for(int i=3;i\u0026lt;=maxnum;i++){ dp[i]=Math.max(dp[i-2]+a[i]*i,dp[i-3]+a[i]*i); } System.out.println(Arrays.toString(dp)); return Math.max(dp[maxnum-1],dp[maxnum]); } ","date":"2021-08-23T19:39:21+08:00","permalink":"https://junling.li/leetcode/740.%E5%88%A0%E9%99%A4%E5%B9%B6%E8%8E%B7%E5%BE%97%E7%82%B9%E6%95%B0/","section":"LeetCode","tags":["Leetcode","Medium"],"title":"740.删除并获得点数"},{"categories":null,"contents":"1329. 将矩阵按对角线排序 矩阵对角线 是一条从矩阵最上面行或者最左侧列中的某个元素开始的对角线，沿右下方向一直到矩阵末尾的元素。例如，矩阵 mat 有 6 行 3 列，从 mat[2][0] 开始的 矩阵对角线 将会经过 mat[2][0]、mat[3][1] 和 mat[4][2] 。\n给你一个 m * n 的整数矩阵 mat ，请你将同一条 矩阵对角线 上的元素按升序排序后，返回排好序的矩阵。\n示例 1：\n1 2 输入：mat = [[3,3,1,1],[2,2,1,2],[1,1,1,2]] 输出：[[1,1,1,1],[1,2,2,2],[1,2,3,3]] 示例 2：\n1 2 输入：mat = [[11,25,66,1,69,7],[23,55,17,45,15,52],[75,31,36,44,58,8],[22,27,33,25,68,4],[84,28,14,11,5,50]] 输出：[[5,17,4,1,52,7],[11,11,25,45,8,69],[14,23,25,44,58,15],[22,27,31,36,50,66],[84,28,75,33,55,68]] 提示：\nm == mat.length n == mat[i].length 1 \u0026lt;= m, n \u0026lt;= 100 1 \u0026lt;= mat[i][j] \u0026lt;= 100 普通题，但是耗时太久.\n思路就是按照提示找到同一斜边的元素，arraylist排序，写回去。\n问题在于找到同一斜边的元素，注意边界。我将遍历过程分成两段，分别是下三角和上三角，利用mat[i][j]的条件i\u0026lt;m\u0026amp;\u0026amp;j\u0026lt;n来控制边界。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 public static int[][] diagonalSort(int[][] mat) { int m=mat.length; // System.out.println(m); int n=mat[0].length; //System.out.println(n); if(m==1|n==1) return mat; for(int i=m-1;i\u0026gt;=0;i--){ ArrayList\u0026lt;Integer\u0026gt; s=new ArrayList\u0026lt;Integer\u0026gt;(); for(int j=0;i+j\u0026lt;m\u0026amp;\u0026amp;j\u0026lt;n;j++){ s.add(mat[i+j][j]); } // System.out.println(s); s.sort(Comparator.naturalOrder()); //System.out.println(s); for(int j=0;i+j\u0026lt;m\u0026amp;\u0026amp;j\u0026lt;n;j++){ mat[i+j][j]=s.get(j); } } System.out.println(\u0026#34;-----------------\u0026#34;); for(int i=0;i\u0026lt;n+1;i++){ ArrayList\u0026lt;Integer\u0026gt; s=new ArrayList\u0026lt;Integer\u0026gt;(); int i2=0; for(int j=i+1;(j\u0026lt;n)\u0026amp;\u0026amp;(i2\u0026lt;m);j++,i2++){ // System.out.println(\u0026#34;i2=\u0026#34;+i2+\u0026#34; j=\u0026#34;+j); s.add(mat[i2][j]); } // System.out.println(s); s.sort(Comparator.naturalOrder()); // System.out.println(s); i2=0; for(int j=i+1;(j\u0026lt;n)\u0026amp;\u0026amp;(i2\u0026lt;m);j++,i2++){ //System.out.println(\u0026#34;i2=\u0026#34;+i2+\u0026#34; j=\u0026#34;+j); mat[i2][j]=s.get(i2); } } return mat; } 看了题解，所有的同一斜边的元素有一个共同特征：i和j的差为定值，也就是说，给定i，j唯一确定是哪一条对角线，一共m+n-1个对角线，创建m+n-1个arraylist。\n对每一条对角线上的元素进行排序。\n填回去的操作：按照从左到右，从上往下遍历时，每次都是最小的在前，可以另外用一个数组保存，或者也可以将arraylist转成栈，按次序填回去的数一定是从小到大的。\n别人的code:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 public int[][] diagonalSort(int[][] mat) { // 行数 int m = mat.length; // 列数 int n = mat[0].length; // 主对角线的条数 int dLen = m + n - 1; // 每一条对角线都创建一个动态数组 ArrayList\u0026lt;Integer\u0026gt;[] diagonal = new ArrayList[dLen]; for (int i = 0; i \u0026lt; dLen; i++) { diagonal[i] = new ArrayList\u0026lt;\u0026gt;(m); } // 遍历原始矩阵，把原始矩阵中的元素放进对应的动态数组中 // 主对角线上元素的特点是：纵坐标 - 横坐标 = 定值 // 加上偏移 m - 1 是为了能够放进数组中 for (int i = 0; i \u0026lt; m; i++) { for (int j = 0; j \u0026lt; n; j++) { diagonal[j - i + (m - 1)].add(mat[i][j]); } } // 对每一个对角线上的动态数组分别进行升序排序 for (int i = 0; i \u0026lt; dLen; i++) { Collections.sort(diagonal[i]); } int[][] res = new int[m][n]; // 对角线数组上还未取出的元素的下标，初始化的时候均为 0 int[] next = new int[dLen]; for (int i = 0; i \u0026lt; m; i++) { for (int j = 0; j \u0026lt; n; j++) { // 对角线的坐标 int index = j - i + (m - 1); // 记录结果 res[i][j] = diagonal[index].get(next[index]); // 维护 next 数组的值 next[index]++; } } return res; } 作者：Code_respect 链接：https://leetcode-cn.com/problems/sort-the-matrix-diagonally/solution/javati-jie-by-code_respect-66zw/ 来源：力扣（LeetCode） 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 ","date":"2021-08-12T16:19:27+08:00","permalink":"https://junling.li/leetcode/1329%E5%B0%86%E7%9F%A9%E9%98%B5%E6%8C%89%E5%AF%B9%E8%A7%92%E7%BA%BF%E6%8E%92%E5%BA%8F/","section":"LeetCode","tags":["Leetcode","Medium"],"title":"1329.将矩阵按对角线排序"},{"categories":null,"contents":"东哥 首先是东哥，一个啥手机都有的神，从经典iPhone SE 到机皇 Samsung Galaxy Note 10+ ,再到爵士Huawei Mate 30 Pro ，还有守门员小米10 ，大清亡了的一加7Pro, 以及东哥新宠 iPhone 13 mini。无论是配备M1的iPad Pro Cellular 256GB with 2 years Apple Care+，还是Pixel C。数不清的数码产品东哥这里应有尽有。\nAlexhhh 这个真的是大佬\n女子 高中生 某个看起来很牛逼实际上是带专的大学的学生 全盘Arch Linux的忠实教徒 会在10行代码里隐藏100个bug的优秀开发者 以上说的bug是能报错的 酷安Linux交流群最大绒布球 minecraft lover（虽然不太适应电脑版） 不高兴就打音游然后就更不高兴的屑 类原生爱好者 gay里gay气但不是gay Abi-ku 一位年轻的大学生，有热情，有理想，热爱生活.Leetcode周赛ak选手\niLei 335最强的男人\n三味冰淇淋 很快，他就走出了公园。第二天去了墨西哥。\n欢迎在评论区交换友链\n","date":"2021-08-07T23:41:56+08:00","permalink":"https://junling.li/links/","section":"","tags":null,"title":"Links"},{"categories":null,"contents":"41. 缺失的第一个正数 给你一个未排序的整数数组 nums ，请你找出其中没有出现的最小的正整数。\n请你实现时间复杂度为 O(n) 并且只使用常数级别额外空间的解决方案。\n示例 1：\n1 2 输入：nums = [1,2,0] 输出：3 示例 2：\n1 2 输入：nums = [3,4,-1,1] 输出：2 示例 3：\n1 2 输入：nums = [7,8,9,11,12] 输出：1 这一题也是我没想到的解法，只知道用哈希，没想到原地哈希，直接操作原数组：\n最早知道这个思路是在《剑指 Offer》这本书上看到的，感兴趣的朋友不妨做一下这道问题：剑指 Offer 03. 数组中重复的数字。下面简要叙述：\n由于题目要求我们「只能使用常数级别的空间」，而要找的数一定在 [1, N + 1] 左闭右闭（这里 N 是数组的长度）这个区间里。因此，我们可以就把原始的数组当做哈希表来使用。事实上，哈希表其实本身也是一个数组； 我们要找的数就在 [1, N + 1] 里，最后 N + 1 这个元素我们不用找。因为在前面的 N 个元素都找不到的情况下，我们才返回 N + 1； 那么，我们可以采取这样的思路：就把 11 这个数放到下标为 00 的位置， 22 这个数放到下标为 11 的位置，按照这种思路整理一遍数组。然后我们再遍历一次数组，第 11 个遇到的它的值不等于下标的那个数，就是我们要找的缺失的第一个正数。 这个思想就相当于我们自己编写哈希函数，这个哈希函数的规则特别简单，那就是数值为 i 的数映射到下标为 i - 1 的位置。\n作者：liweiwei1419 链接：https://leetcode-cn.com/problems/first-missing-positive/solution/tong-pai-xu-python-dai-ma-by-liweiwei1419/ 来源：力扣（LeetCode） 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public static int firstMissingPositive(int[] nums) { int n=nums.length; for(int i=0;i\u0026lt;n;i++){ while(nums[i]\u0026gt;0\u0026amp;\u0026amp;nums[i]\u0026lt;=n\u0026amp;\u0026amp;nums[i]!=i+1\u0026amp;\u0026amp;nums[nums[i]-1]!=nums[i]){ //替代以后还要不断判断这一个数，因为新的数来了,所以用while //nums[nums[i]-1]!=nums[i]这个条件必须要用上，不仅可以简化运算，还要针对这种【1，1】无限循环的情况 swap(nums,i,nums[i]-1); } } for(int i=0;i\u0026lt;n;i++){ if(nums[i]!=i+1) return i+1; } return n+1;//针对只有【1】的数组 } 相似的一题，剑指offer3：\n剑指 Offer 03. 数组中重复的数字 找出数组中重复的数字。\n在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。\n示例 1：\n1 2 3 输入： [2, 3, 1, 0, 2, 5, 3] 输出：2 或 3 这一题给了明示，所有数字都在 0～n-1 的范围内，也是同样的方法,原地hash\n可以看作成为一种排序占位，值为i的占到下标为i的位置，如果有人占到位子，说明重复了，最终达到O(n)的时间复杂度\n1 2 3 4 5 6 7 8 9 10 11 12 13 public static int findRepeatNumber(int[] nums) { int n=nums.length; for(int i=0;i\u0026lt;n;i++){ while(nums[i]!=i){ if(nums[i]==nums[nums[i]]) return nums[i]; swap(nums,i,nums[i]); } } return 1; } ","date":"2021-08-07T21:49:20+08:00","permalink":"https://junling.li/leetcode/41%E7%BC%BA%E5%A4%B1%E7%9A%84%E7%AC%ACn%E4%B8%AA%E6%AD%A3%E6%95%B4%E6%95%B0/","section":"LeetCode","tags":["Leetcode","Difficult"],"title":"41缺失的第n个正整数"},{"categories":null,"contents":"二叉树的前中后序遍历 前序：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public static List\u0026lt;Integer\u0026gt; preorderTraversal(TreeNode root) { List\u0026lt;Integer\u0026gt; ans=new ArrayList() ; if(root!=null){ ans.add(root.val); if(root.left!=null){ ans.addAll(preorderTraversal(root.left)); } if(root.right!=null){ ans.addAll(preorderTraversal(root.right)); } } return ans; } 中序：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public static List\u0026lt;Integer\u0026gt; inorderTraversal(TreeNode root) { List\u0026lt;Integer\u0026gt; ans=new ArrayList() ; if(root!=null){ if(root.left!=null){ ans.addAll(inorderTraversal(root.left)); } ans.add(root.val); if(root.right!=null){ ans.addAll(inorderTraversal(root.right)); } } return ans; } 后序：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 public List\u0026lt;Integer\u0026gt; postorderTraversal(TreeNode root) { List\u0026lt;Integer\u0026gt; ans=new ArrayList() ; if(root!=null){ if(root.left!=null){ ans.addAll(postorderTraversal(root.left)); } if(root.right!=null){ ans.addAll(postorderTraversal(root.right)); } ans.add(root.val); } return ans; } ","date":"2021-07-29T22:56:00+08:00","permalink":"https://junling.li/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E4%B8%AD%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/","section":"LeetCode","tags":["Leetcode","Easy"],"title":"二叉树的前中后序遍历"},{"categories":null,"contents":"Z字型变换 6. Z 字形变换 将一个给定字符串 s 根据给定的行数 numRows ，以从上往下、从左到右进行 Z 字形排列。\n比如输入字符串为 \u0026quot;PAYPALISHIRING\u0026quot; 行数为 3 时，排列如下：\n1 2 3 P A H N A P L S I I G Y I R 之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：\u0026quot;PAHNAPLSIIGYIR\u0026quot;。\n请你实现这个将字符串进行指定行数变换的函数：\n1 string convert(string s, int numRows); 示例 1：\n1 2 输入：s = \u0026#34;PAYPALISHIRING\u0026#34;, numRows = 3 输出：\u0026#34;PAHNAPLSIIGYIR\u0026#34; 示例 2：\n1 2 3 4 5 6 7 输入：s = \u0026#34;PAYPALISHIRING\u0026#34;, numRows = 4 输出：\u0026#34;PINALSIGYAHRPI\u0026#34; 解释： P I N A L S I G Y A H R P I 示例 3：\n1 2 输入：s = \u0026#34;A\u0026#34;, numRows = 1 输出：\u0026#34;A\u0026#34; 提示：\n1 \u0026lt;= s.length \u0026lt;= 1000 s 由英文字母（小写和大写）、',' 和 '.' 组成 1 \u0026lt;= numRows \u0026lt;= 1000 解法1： 写出每一个字母的坐标，然后找出规律\n比如(P点是原点，向下是x轴，向右是y轴)\n1 2 3 4 5 6 7 s = \u0026#34;PAYPALISHIRING\u0026#34;, numRows = 3 //P0,0 A1,0 Y2,0 P1,1 //A0,2 L1,2 I2,2 S1,3 // P A H N // A P L S I I G // Y I R 注意到，每4次出现循环，将字母填入坐标系中。\n最后按顺序遍历坐标系，即可获得变换后的顺序。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 public static String convert(String s, int numRows) { if(numRows==1){ return s; } int n_temp=s.length(); char bb[][]=new char[numRows][n_temp]; String ans=\u0026#34;\u0026#34;; int cir=0; int x=0,y=0; int flag=0; for(int i0=0;i0\u0026lt;n_temp;i0++){ cir=i0%(2*numRows-2); if(cir\u0026gt;=numRows|cir==0\u0026amp;i0\u0026gt;0){ y++; } if(cir\u0026gt;=numRows) x--; else x=cir; bb[x][y]=s.charAt(i0); } for(int i=0;i\u0026lt;bb.length;i++){ for(int j=0;j\u0026lt;bb[i].length;j++){ //char的默认值是0 if(bb[i][j]!=0) ans=ans+bb[i][j]; } } return ans; } 这样时间和空间效率都不高。给出每一个字母的索引就能得到位置。反过来通过位置找到字母行不行呢？\n解法2： 比如变换后的第一个字母是P（拿以上的例子），索引是0；第二个字母是A，对应的原来的索引是4；然后8，12，16\u0026hellip;\u0026hellip;取0，4，8，12，16个字母即可获得第一行。\n第二行同样的方法，A(1),P(3),L(5),S(7),I(9)\n第三行：Y(2),I(6),R(10)\n对于示例 2：\n1 2 3 4 5 6 7 输入：s = \u0026#34;PAYPALISHIRING\u0026#34;, numRows = 4 输出：\u0026#34;PINALSIGYAHRPI\u0026#34; 解释： P I N A L S I G Y A H R P I 第一行：0，6，12\n第二行：1，5，7，11，13（其实是0，6，12的前一个和后一个）\n第三行：2，4，8，10（其实是3，9的前一个和后一个）\n第四行：3，9\n思路好像没问题？\n但是看了下其他人的解法，我还是弱爆了。\n解法3： 简单易懂空间小，膜！\n注意flag的巧妙用法。\nhttps://leetcode-cn.com/problems/zigzag-conversion/solution/zzi-xing-bian-huan-by-jyd/\n","date":"2021-07-20T15:27:36+08:00","permalink":"https://junling.li/leetcode/6.z%E5%AD%97%E5%9E%8B%E5%8F%98%E6%8D%A2/","section":"LeetCode","tags":["Leetcode","Medium"],"title":"6.Z字型变换"},{"categories":null,"contents":"415. 字符串相加 给定两个字符串形式的非负整数 num1 和num2 ，计算它们的和。\n提示：\nnum1 和num2 的长度都小于 5100 num1 和num2 都只包含数字 0-9 num1 和num2 都不包含任何前导零 你不能使用任何內建 BigInteger 库， 也不能直接将输入的字符串转换为整数形式 根据朴素的加法思想，关键在于模拟竖式计算，用一个字符串存储进位，每一列超过十进位。\n注意要对齐，在短的字符串首部补零。字符串的生成使用拼接的方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 public static String addStrings(String num1, String num2) { String numjinwei=\u0026#34;0\u0026#34;; String addsum=\u0026#34;\u0026#34;; int n1=num1.length(); int n2=num2.length(); if(n1\u0026gt;n2) for(int i=0;i\u0026lt;n1-n2;i++) num2=\u0026#34;0\u0026#34;+num2; else for(int i=0;i\u0026lt;n2-n1;i++) num1=\u0026#34;0\u0026#34;+num1; //对齐 int n_max=Integer.max(n1,n2); int jinwei=0; for(int i=0;i\u0026lt;n_max;i++){ int temp_lenthof_numjinwei=numjinwei.length(); int t1=num1.charAt(n_max-1-i)-48; int t2=num2.charAt(n_max-1-i)-48; int t3=numjinwei.charAt(temp_lenthof_numjinwei-1-i)-48; int temp=t1+t2+t3; jinwei=temp/10; int val=temp%10; numjinwei=jinwei+numjinwei; addsum=val+addsum; } if(jinwei==1){ addsum=jinwei+addsum; } return addsum; } ","date":"2021-07-18T19:39:21+08:00","permalink":"https://junling.li/leetcode/415%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E5%8A%A0/","section":"LeetCode","tags":["Leetcode","Easy"],"title":"415.字符串相加"},{"categories":null,"contents":"48. 旋转图像 48. 旋转图像 难度中等933收藏分享切换为英文接收动态反馈\n给定一个 n × n 的二维矩阵 matrix 表示一个图像。请你将图像顺时针旋转 90 度。\n你必须在** 原地** 旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要 使用另一个矩阵来旋转图像。\n示例 1：\n1 2 输入：matrix = [[1,2,3],[4,5,6],[7,8,9]] 输出：[[7,4,1],[8,5,2],[9,6,3]] 示例 2：\n1 2 输入：matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]] 输出：[[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]] 示例 3：\n1 2 输入：matrix = [[1]] 输出：[[1]] 示例 4：\n1 2 输入：matrix = [[1,2],[3,4]] 输出：[[3,1],[4,2]] 提示：\nmatrix.length == n matrix[i].length == n 1 \u0026lt;= n \u0026lt;= 20 -1000 \u0026lt;= matrix[i][j] \u0026lt;= 1000 通过次数192,922\n提交次数263,618\n一个很久就看到的题目，一直没写，不过上手发现思路不难。\n观察旋转过程中坐标的变化,以3*3矩阵来举例：\n(1,1)-\u0026gt; (1,3)\n(1,2)-\u0026gt;(2,3)\n(1,3)-\u0026gt;(3,3)\n(2,1)-\u0026gt;(1,2)\n(2,2)-\u0026gt;(2,2)\n(2,3)-\u0026gt;(3,2)\n多写几个就可以发现规律了：(i,j)-\u0026gt;(j,n+1-i)，这就意味着，将所有(i,j)位置上的值移到(j,n+1-i)位置上就行了，为了方便，可以另起一个矩阵，填入新值，就完成了。\n注意下标是从0开始的，坐标转化应该是(i,j)-\u0026gt;(j,n-1-i)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public static void rotate(int[][] matrix) { int n_temp=matrix.length; int bb[][]=new int[n_temp][n_temp]; // System.out.println(matrix.length); for( int i=0;i\u0026lt;matrix.length;i++){ for(int j=0;j\u0026lt;n_temp;j++){ bb[i][j]=matrix[i][j]; }} for( int i=0;i\u0026lt;matrix.length;i++){ for(int j=0;j\u0026lt;n_temp;j++){ matrix[j][n_temp-1-i]=bb[i][j]; } } 这就是一个最简单的旋转移动的思路了。可以拿一个图像试验一下，这里使用matlab\n原始图片是这样，\n使用matlab获得rgb值，进行旋转变换：\n1 2 3 4 5 6 7 8 9 10 11 12 tu = imread(\u0026#39;image2022.png\u0026#39;); tu1=tu(:,:,1); s=size(tu1) tu2=zeros(s(2),s(1)); for i=1:s(1) for j=1:s(2) tu2(j,s(1)+1-i)=tu1(i,j); end end image(tu2) 得到的结果：\n注意matlab中数组下标是从1开始的。\n回到题目中来，题目要求请不要 使用另一个矩阵来旋转图像，怎么办？\n观察(i,j)-\u0026gt;(j,n+1-i)，能不能看成两步(i,j)-\u0026gt;(n+1-i,j)，(n+1-i,j)-\u0026gt;(j,n+1-i)\n第一步是左右颠倒，(1,3)移到了(3,3);(3,3)移到了(1,3)，这样就可以交换了。\n第二步是对称交换，根据对角线对称。\n这样不需要使用另外一个矩阵进行保存数据了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public void rotate(int[][] matrix) { int n = matrix.length; // 水平翻转 for (int i = 0; i \u0026lt; n / 2; ++i) { for (int j = 0; j \u0026lt; n; ++j) { int temp = matrix[i][j]; matrix[i][j] = matrix[n - i - 1][j]; matrix[n - i - 1][j] = temp; } } // 主对角线翻转 for (int i = 0; i \u0026lt; n; ++i) { for (int j = 0; j \u0026lt; i; ++j) { int temp = matrix[i][j]; matrix[i][j] = matrix[j][i]; matrix[j][i] = temp; } } } } //官方题解 第三种方法：\n一次性移动4格，详见官方题解。（公式的复制出现问题了，不然我就粘贴在这里了）\n1 2 3 4 5 6 7 8 9 10 11 12 public void rotate(int[][] matrix) { int n = matrix.length; for (int i = 0; i \u0026lt; n / 2; ++i) { for (int j = 0; j \u0026lt; (n + 1) / 2; ++j) { int temp = matrix[i][j]; matrix[i][j] = matrix[n - j - 1][i]; matrix[n - j - 1][i] = matrix[n - i - 1][n - j - 1]; matrix[n - i - 1][n - j - 1] = matrix[j][n - i - 1]; matrix[j][n - i - 1] = temp; } } } 作者：LeetCode-Solution 链接：https://leetcode-cn.com/problems/rotate-image/solution/xuan-zhuan-tu-xiang-by-leetcode-solution-vu3m/ 来源：力扣（LeetCode） 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n","date":"2021-07-17T19:56:17+08:00","permalink":"https://junling.li/leetcode/48%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F/","section":"LeetCode","tags":["Leetcode","Medium"],"title":"48.旋转图像"},{"categories":null,"contents":"第2章：UNIX 发展历史以及系统架构 发展历史：\n1965年 MULTICS ( Multiplexed Information and Computing Service) 的开发\n1970年 Ken Thompson 和 Dennis Ritchie 在PDP7上用汇编语言开发出UNICS\n1971年 在PDP-11上用汇编开发出UNIX v.1\n1972年 增加管道功能后开发出UNIX v.2\n1973年 Dennis Ritchie 在B language基础上发明了C language 并用C重写UNIX, 形成v.5 \u0026mdash;- 当时第一个高级语言OS\n1975年 发表UNIX v.6 并广泛扩散到大学和科研单位, 为后期发展奠定了良好的基础\n1978年 优化后发布UNIX v.7 \u0026mdash;- UNIX的第一个商业版本 \u0026mdash;- 我国开始研究应用的最早版本\n1981年 AT\u0026amp;T发布UNIX System III, 完全转向为社会提供的商品软件\n1983年 AT\u0026amp;T发布UNIX System V, 系统功能已趋于稳定和完善. 此后System V又有一系列的公布号:1.0/2.0/2.3/3.5/4.0/4.2 等, 现在最后版本为 System V Release 4 (SVR4)\n有代表性的版本：\nAIX IBM公司 XENIX/OpenServer Microsoft、SCO公司 HP-UX HP公司 BSD 加州大学伯克利分校 Solaris SUN公司 IRIX SGI公司 Ultrix DEC公司 Linux 开放源代码\n系统结构： 内核：负责管理所有与硬件相关的功能，这些功能由UNIX内核中的各个模块实现。内核包括直接控制硬件的各个模块，这样能够极大程度上保护这些硬件，以避免应用程序直接操作而导致混乱。用户不能直接访问内核。\n注意：系统工具和UNIX命令不是内核组件。\n用户应用程序得到保护，避免被其他用户的无意写操作破坏。\n常驻模块层：提供执行用户请求服务的例程，包括IO控制服务，文件/磁盘访问服务，以及进程创建和终止服务。\n工具层：是UNIX的用户接口，通常成为shell在后面会详细讲到shell\n虚拟计算机：UNIX操作系统向系统中的每个用户指定一个执行环境，这个环境成为虚拟计算机，包括一个用户终端和共享的其他的计算机资源。而UNIX上可以存在多个用户，所以每一个用户都有自己的专用虚拟计算机。不同的用户的虚拟计算机共享CPU和其他计算机资源，所以虚拟计算机比真实的计算机要慢。\n进程：一个重要的概念。一般面试时都会问进程和线程 的区别。UNIX系统通过进程向用户和程序分配资源（这句话不怎么懂）。每个进程都有一个进程号pid和一组与之相关的资源。进程在虚拟计算机环境下运行，就好像在一个专用CPU上执行一样。\n第3章 UNIX入门 3.1登录与退出 1.登录\n输入用户名，密码\n2.修改密码：passwd和一般的修改要验证旧密码并两次重新输入新密码，具体操作不再赘述\n3.退出系统：[ctrl+d] 或是exit，即可退出\n3.2 简单的UNIX命令 命令行格式：[命令] [选项] [参数]\n字段间要用一个或多个空格隔开。选项的前面一般会有连字符-，一个命令同时也可以有多个，例如下列著名的命令：\nrm表示删除，-rf表示两个选项：r和f，/*表示的磁盘路径就是参数，告诉系统在哪里要删除什么文件\n下面介绍一些简单的命令：\n1.date：显示日期和时间\n2.who：列出登录系统的所有用户的用户名，终端号，和登录时间。这里wsl没有这个命令，原因如下\nwho程序跟Linux内核无关，只是读取Unix里约定俗成的utmp,wtmp登录文件。你第一次打开wsl2的终端，或者通过其他方式运行wsl2的这个系统，就是第一次登录。但是wsl2子系统不会用utmp/wtmp记录这些，没有任何意义\n但在wsl里/init does not create /var/run/utmp\n解决方案： Use \u0026rsquo;touch /var/run/utmp\u0026rsquo; in some \u0026ldquo;system startup script\u0026rdquo;\n来源：https://github.com/Microsoft/WSL/issues/573\nwho还有一些的选项：-q -H -b。\n3.显示日历：cal\n3.3 获取帮助信息 learn和help，使用时需要安装\n比如我不知道exit的用法\n3.3.3 man手册： 学习新命令时使用，可以得到该man(manual)命令的详细说明，当然\n在简洁的wsl中也是没有man的，需要先sudo apt install man-db manpages manpages-dev,之后才能愉快地使用man\n3.4 更正键盘输入错误 中断程序的执行，在大多数系统中，del或者ctrl-c就是中断键，比如不小心按了rm -rf /*，这是就要猛敲[ctrl-c]\n3.5 使用shell 命令的处理是位于用户和操作系统的其他部分之间的shell完成的，每输入一个命令以后，命令被传到shell，先进行分析，然后执行。\nbulitin命令：包含的是一些比较简单的linux系统命令，这些命令由shell程序识别并在shell程序内部完成运行，通常在linux系统加载运行时shell就被加载并驻留在系统内存中。内部命令是写在bashy源码里面的，其执行速度比外部命令快，因为解析内部命令shell不需要创建子进程。比如：exit，history，cd，echo等。\n外部命令是linux系统中的实用程序部分，因为实用程序的功能通常都比较强大，所以其包含的程序量也会很大，在系统加载时并不随系统一起被加载到内存中，而是在需要时才将其调用内存。通常外部命令的实体并不包含在shell中，但是其命令执行过程是由shell程序控制的。shell程序管理外部命令执行的路径查找、加载存放，并控制命令的执行。外部命令是在bash之外额外安装的，通常放在/bin，/usr/bin，/sbin，/usr/sbin\u0026hellip;\u0026hellip;等等。可通过“echo $PATH”命令查看外部命令的存储路径，比如：ls、vi等。\n用type命令可以分辨内部命令与外部命令\n关于内部命令和外部命令执行顺序的问题：\npwd命令用于显示当前工作目录，是Linux系统下最常用的命令之一。在不太能确定当前位置时，可以使用pwd命令来判断目录在文件系统内的确切位置。而涉及pwd指令，就不得不提及三个环境变量：PATH、OLDPWD、PWD。\nPATH：执行文件路径的变量；\u0026ldquo;echo $PATH\u0026rdquo;（PATH前面加$表示后面接的是变量）\nOLDPWD：表示前一次的工作目录；\nPWD：表示当前的工作目录。\n问题缘由：当输入“man pwd”时可以查看pwd的帮助文档，而输入“pwd \u0026ndash;help”就提示有错误bash: pwd: \u0026ndash;: invalid option；若输入“ /bin/pwd \u0026ndash;help”就能正常显示pwd的帮助文档。\n从网上查找原因并经过整合可知，这主要是由于内部命令和外部命令的区别，pwd是内部命令，而/bin/pwd就是外部命令。在显示当前目录时，/bin/pwd能显示当前工作目录的完整文件路径，能更准确些。在多人共享同一台Linux机器时，经常会发现当前目录被别人删除后，pwd命令仍然会显示那个目录。\n后续试验：切换至root权限下，将/bin目录下的执行文件ls移动到非正规目录中去，mv /bin/ls /root（#mv为移动，可将文件在不同的目录间进行移动操作），然后不管在哪个目录底下输入任何与ls相关的指令，都不能顺利执行ls了（因为/root这个目录并不在PATH指定的目录中，外部命令ls是没法通过PATH路径找到执行文件ls），除非用/root/ls 才行。\n如果想要让root在任何目录下均可执行/root底下的ls，那么可以将/root加入到PATH当中，该命令PATH=\u0026quot;$PATH\u0026quot;:/root即可。若有两个ls指令在不同的目录中，例如/usr/local/bin/ls 和/bin/ls ，那么当我下达 ls命令时，是根据PATH里面哪个目录先被查询到，则那个目录下的指令就先被执行。\n而即使采用相同的方法移动/bin目录下的执行文件pwd，仍可以输入pwd命令执行，因为这时仍是调用内部命令pwd指令。\n故shell命令解释器在执行命令时，是应先执行内部指令，若要执行的指令不是内部指令，则应是调用的外部指令。 ———————————————— 版权声明：本文为CSDN博主「JustDo-IT」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。 原文链接：https://blog.csdn.net/taohuaxinmu123/article/details/10845001\n3.5.2 更改用户shell 可以在 /etc/passwd里查看用户登录的shell\n例如第一行：root:x:0:0:root:/root:/bin/bash 用户名：密码：UID：GID：描述性信息：用户主目录：Shell　具体shell的内容将在第9章中详细说明\n第4章 vi 编辑器入门 vi 文件名启动vi 编辑器，进入的是shell的命令模式,如果你要输入文本，可以按i进入文本输入模式，退出vi：先esc，再输入:wq，即可保存或退出。\n以上就是最最基础的用法。下面介绍高级用法：\n4.1模式： 从命令模式进入文本输入模式：\n文本输入模式 i 在光标左侧加入文本 I 在光标所在行首插入文本 a 在光标右侧加入文本 A 在光标所在行尾加入文本 o 在光标所在行下面新加一行 O 在光标所在行上面新加一行 ESC 退出文本输入模式 4.2 命令模式： 光标移动：\n光标移动 h j k l 左下上右移动 ^ 行首 $ 行尾 + 下一行的行首 _ 上一行的行首 Space 右移 Backspace 左移 w 下一个字 b 前一个字 e 当前字的末尾 文本修改：\n文本修改 x 删除光标所在字符 dw 删除光标所在词的从光标开始到该词结尾 D 删除从光标到行尾 dd 删除光标所在行 u 撤销上一次修改 r 把当前光标所在字符替换为紧跟在r后的一个字 x,dw,dd前都可加上数字，表示同时删除多个单位\n.可以重复最近一次对文本的修改操作\n搜索文本\n搜索 / 输入搜索词并回车，向尾部查找下一个词 ? 与/相同，查找方向相反 4.3 退出 在命令模式时，\n退出 :wq 保存文本，退出vi，返回shell :w 保存文本，不退出 :w file 把文本保存到文件file中，不退出 :q 退出vi，返回shell ZZ 快速保存文件并退出 4.4 存储缓冲区 vi编辑器为用户所要创建或修改的文件建立了一个临时工作区，用户编辑的过程中只作用于工作区的文件副本而不是源文件。如果用户需要保存，必须用命令将修改的文件替换原文件。\n4.5 高级操作 希望能在vim中完成大多数工作，而不是频繁的退出vim 首先:tabnew创建一个标签 然后:e 文件名打开一个文件 :tabnext在窗口上打开下一个tab :tabprevious在窗口上打开前一个tab :q或者:tabclose关闭tab 更多的高级用法将在第6章讲到\n第5章 UNIX 文件系统介绍 5.1 磁盘组织 UNIX允许用户将硬盘分为很多单元（称为目录）和子单元（子目录），这样可以在目录里嵌套子目录。UNIX提供命令，可以在磁盘上创建、组织、和查找目录和文件。\n文件系统原理\nUnix有三大抽象\n进程、线程对执行过程 文件对io 地址空间对内存 Unix有四种io：文件系统、块设备、字符设备、socket\n块设备和字符设备出现在文件系统的名字空间 Socket仅表现为文件 考虑到磁盘的空间组织，主要有边长的堆、定长的记录、索引\nUnix文件系统选择：堆 + 索引\n5.2 UNIX中的文件类型 普通文件：包含字节序列，如程序代码、数据、文本。\n目录文件：目录文件和其他文件一样，用户可以像命名其他文件一样来命名目录文件。区别在于不是标准的ascii文本文件，包含的是关于其他文件的信息。\n特殊文件：包含与外部设备，如打印机、磁盘等相联系的的特定信息。unix的一大抽象就是将io设备视同文件对待，系统中的每个设备都分别对应一个文件。\n5.3 目录详述 目录结构以层次形式组织，称为层次结构（其实可以理解为树）。最高层目录为根目录。\n5.3.1 重要的目录： /usr 用户主目录，当用户在系统中登录时，会自动进入用户主目录，它在/usr/[username]下。\n/bin 可执行文件\n/dev设备文件，代表物理设备的抽象，如终端是/dev/tty文件。/dev/null是一个特殊设备，即空设备，所有发给空设备的信息都被删除。\n/sbin 存放系统文件，在3.5章讲到：\n外部命令是在bash之外额外安装的，通常放在/bin，/usr/bin，/sbin，/usr/sbin\u0026hellip;\u0026hellip;等等\n/etc 存放unix配置文件，通常是文本，只要特权用户才有权限编辑。\n5.3.2 路径 绝对路径名：从根目录到该文件的路径，以/开始\n相对路径名：从当前路径到目的文件，开头没有/\n5.4 目录命令 1.打印工作目录 pwd(print working directory)\n2.改变工作目录 cd cd命令 cd 返回用户主目录，缺省值 cd $HOME 返回用户主目录 cd .. 返回上一级目录 3.创建目录 mkdir\n选项有-p\nmkdir -p xx/yy/zz 创建xx目录，在xx下创建yy目录，在yy下创建zz目录\n4.删除目录 rmdir\n注意只能删除空目录，即除了本目录（.）和父目录（..）外，该目录不包含其他任何子目录和文件。\n5.目录列表 ls\n显示指定目录的信息，如果没有指定目录，则列出当前目录。\nUNIX选项 linux选项 功能 -a \u0026ndash;all 列出所有文件，包括隐藏文件 -C \u0026ndash;format=vertical \u0026ndash;format=horizontal 用多列方式列出文件，按列排列 -F \u0026ndash;classify 将子目录与普通文件类型分开，子目录加/，可执行文件加* -l \u0026ndash;format=single-column 详细列出文件的属性，每行一个文件 -m \u0026ndash;format=commas 按页宽列出文件，用逗号隔开 -p 在目录文件名后加斜杠 / -r \u0026ndash;reverse 以反字母顺序列出文件 -R \u0026ndash;recursive 递归列出子目录的内容 -s \u0026ndash;size 以block为单位列出文件大小 -x \u0026ndash;format=horizontal \u0026ndash;format=across 以多列方式列出文件，按行排列 \u0026ndash;help 显示帮助信息 例如：\ndrwxr-xr-x 为属性字段\n文件属性字段总共有10个字母组成；第一个字符代表文件的类型。\n字母**“-”**表示该文件是一个普通文件\n字母**“d”**表示该文件是一个目录，字母\u0026quot;d\u0026quot;，是dirtectory(目录)的缩写\n**注意：**目录或者是特殊文件，这个特殊文件存放其他文件或目录的相关信息\n字母**“l”**表示该文件是一个链接文件。字母\u0026quot;l\u0026quot;是link(链接)的缩写，类似于windows下的快捷方式\n字母**“b”**的表示块设备文件(block)，一般置于/dev目录下，设备文件是普通文件和程序访问硬件设备的入口，是很特殊的文件。没有文件大小，只有一个主设备号和一个辅设备号。一次传输数据为一整块的被称为块设备，如硬盘、光盘等。最小数据传输单位为一个数据块(通常一个数据块的大小为512字节)\n字母**“c”**表示该文件是一个字符设备文件(character)，一般置于/dev目录下，一次传输一个字节的设备被称为字符设备，如键盘、字符终端等，传输数据的最小单位为一个字节。\n字母**“p”**表示该文件为命令管道文件。与shell编程有关的文件。\n字母**“s”**表示该文件为sock文件。与shell编程有关的文件。\n后面的是文件访问模式：rwx分别为read，write，执行的权限。分为3组，第一组rwx是文件所有者，第二组r-x是同组用户权限，第三组r-x是其他用户权限。\n第2列是链接数，第3列是文件所有者，第4列是文件组，第5列是文件大小，第6列是上次修改的日期和时间，第7列是文件名。\n6.隐藏文件\n文件名以点开始的文件，不可见。\nchmod命令 chmod命令可以使用八进制数来指定权限。文件或目录的权限位是由9个权限位来控制，每三位为一组，它们分别是文件所有者（User）的读、写、执行，用户组（Group）的读、写、执行以及其它用户（Other）的读、写、执行。历史上，文件权限被放在一个比特掩码中，掩码中指定的比特位设为1，用来说明一个类具有相应的优先级。\n# 权限 rwx 二进制 7 读 + 写 + 执行 rwx 111 6 读 + 写 rw- 110 5 读 + 执行 r-x 101 4 只读 r\u0026ndash; 100 3 写 + 执行 -wx 011 2 只写 -w- 010 1 只执行 \u0026ndash;x 001 0 无 \u0026mdash; 000 .和. .目录项\n本目录（.）和父目录（..）mkdir命令自动将两项放到创建的每个目录中。分别代表当前目录和上一级目录。\n5.5 显示文件 cat concatenate命令 可以显示一个、多个、创建文件、连接文件。\n5.6 打印文件内容 lp 将文件发送给打印机\nLinux中的打印请求 lpr命令\n取消打印命令cancel\n获取打印机状态lpstat\n5.7 删除文件 rm可以删除指定的文件\n选项 功能 -i 删除文件前，给出确认信息 -r 删除指定的目录及目录下的所有文件和子目录 -rf 无提示地强制递归删除文件 如果想无提示删除所有文件，可以作死尝试sudo rm -rf /*\n第6章 vi编辑器的高级用法 6.1 更多vi知识 6.1.1 启动vi编辑器 以不依靠文件的方式启动vi，可以最后用:w filename保存（如果有同名文件会提示）\n启动选项：\n-R 只读，如果希望保存的话，必须用!强制执行写选项\nview filename同样可以以只读模式打开\n6.1.2 编辑多个文件 :n 启动下一个编辑文件，此时用下一个文件替换工作缓冲区的内容（源文件要保存）。我觉得唯一作用就是可以省略退出的操作。\n:e编辑另一个文件，感觉这种方法和:n一样啊\n:r读另一个文件，将指定文件的副本放到缓冲区中光标位置之后，指定文件成为当前文件的一部分。保存到源文件。\n:w将正在编辑的文件写入另一个文件中，就相当于6.1.1中最后的保存操作\n6.2 重排文本 vi提供了删除，复制，剪贴操作。就是命令有点复杂。\n书中讲了几个例子：\n1.剪贴行（使用删除和put操作符）\n在某一行按dd，会发现这一行消失了，但并没有完全消失，只是保存到临时缓冲区中，在合适的地方按p，这时刚才被删除的行就被放在当前行下。\n2.复制行（使用复制和put操作符）\n在某一行按yy，这一行保存到临时缓冲区中，在合适的地方按p，粘贴。\n当然先要精细化粘贴怎么办呢？\n6.3 操作符的域 命令=操作符+域\n确定操作域后，可以使用户更好地控制编辑任务。\n键 功能说明 $ 标识域为从光标位置后到当前行尾 0 标识域为从光标位置前到当前行首 e/w 标识域为从光标位置后到当前字尾 b 标识域为从光标位置前到当前字首 比如要复制从光标到行尾的所有，可以按d$，这就实现了复制，再按p粘贴。\n删除2行，d2d\n6.4 使用缓冲区 6.4.1 数字编号缓冲区 编号1-9，每次删除或复制的文本就会放在这些地方。使用\u0026quot;1p就可以把1号缓冲区粘贴到下一行。\n6.4.2 字母编号缓冲区 编号a-z，用户可以保存指定文本到某字母编号缓冲区。\n比如\u0026quot;wdd将当前行删除，删除的副本保存在w号缓冲区\n\u0026quot;z7yy，复制7行内容到z缓冲区\n6.5 光标定位键 键 功能说明 Ctrl-d 将光标向下移动到文件尾，通常每次移动12行 Ctrl-u 将光标向下移动到文件头，通常每次移动12行 Ctrl-f 将光标向下移动到文件尾，通常每次移动24行 Ctrl-b 将光标向下移动到文件头，通常每次移动24行 6.6 定制vi 用户可以调整vi编辑器的设置\n可以看到有众多选项可以自定义。\n下面介绍一些常用选项：\n选项 缩写 功能 autoindent ai 将新行与前一行的行首对齐 ignorecase ic 在搜索选项中忽略大小写 magic 允许在搜索时使用特殊字符 number nu 显示行号 report 通知用户上一个命令影响的行号 scroll 设定Ctrl-d命令翻动的行数 shiftwidth sw 设置缩进的空格数，与autoindent选项一起使用 showmode smd 在屏幕的右角显示vi编辑器的模式 terse 缩短错误信息 wrapmargin wm 设置距屏幕右边界为指定的字符数 6.6.4 缩写ab 在命令模式输入:ab hos harmony OS，进入文本模式，在任何地方输入hos，注意前后要有空格，vi就会把hos替换为harmony OS。\n:ab [return]可以查看所有的缩写\n宏操作符map：可以指定单个键代表键序列。例如：想要用q代替删除5行5dd，可以在命令模式输入:map q 5dd\n以上取消可以按:unab hos和:unmap q\n6.6.5 .exrc文件 用户的设置都是临时的，如果想要永久保存对vi的设置，可以在.exrc文件保存设置\n6.7 其他命令 当你想在vi编辑时运行shell命令，为了在vi中编辑文件不被打断，可以:! 执行shell命令\n第7章 正则表达式 Regular Expressions RE分为BRE和ERE\nBasic RE：\n字 符 BRE/ERE 含义 \\ Both 转义 . Both 匹配单个字符 * Both 匹配任意次，可以是0次。a*表示匹配任意多次a，.*表示任意字符串 ^ Both 锚定匹配位置，从一行的行首开始 $ Both 锚定匹配位置，到一行的行尾 […] Both 匹配中括号内的某个字符。x-y表示一个范围；[^…]表示不匹配中括号中的任意字符。[开括号后跟-或]，-]转义为普通字符 \\{n,m\\} BRE 匹配次数为[n,m]，{n}匹配n次，{n,}最小匹配次数为n \\ (\\ ) BRE 定义一个匹配位置，在后部可以引用该位置。例如，\\(ab\\).*\\1表示ab字符串包夹了一个任意字符串。 \\n BRE 引用已经定义的位置，可以从\\1到\\9 下面是一些例子：\na*g$ 匹配到行尾\n^a*g 匹配到行首（*表示0-任意次）\na[a-z]g可以匹配aag，abg，\u0026hellip;,azg都可以\na[^0-9]g不匹配a9g\n[]中也可以加[[:alnum:]]表示字符+数字\n[[:alpha:]]表示字符\n[[:digit:]]表示数字\n[[:lower:]]表示小写字符\n[[:upper:]]大写字符\n[[:space:]]空字符：空格、tab\na{3}匹配aaa,aaaaaa\na{3,}匹配aaa，aaaa，aaaaaa\n例子 在leetcode上有shell分类，随便点开一题，发现是正则表达式的题目\n给定一个包含电话号码列表（一行一个电话号码）的文本文件 file.txt，写一个单行 bash 脚本输出所有有效的电话号码。\n你可以假设一个有效的电话号码必须满足以下两种格式： (xxx) xxx-xxxx 或 xxx-xxx-xxxx。（x 表示一个数字）\n你也可以假设每行前后没有多余的空格字符。\n示例：\n假设 file.txt 内容如下：\n987-123-4567 123 456 7890 (123) 456-7890 你的脚本应当输出下列有效的电话号码：\n987-123-4567 (123) 456-7890\n来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/valid-phone-numbers\n首先当然是匹配行首到行尾，^和$不能少\n三位数字怎么弄：[0-9]{3}\n^[0-9]{3}-[0-9]{3}-[0-9]{4}$|^(\\([0-9]{3}\\) [0-9]{3}-[0-9]{4})$ 当然也可以不同，下面截取一个leetcode网友的题解\n1 cat file.txt | grep -P \u0026#34;^(\\([0-9]{3}\\)\\s|[0-9]{3}-)[0-9]{3}-[0-9]{4}$\u0026#34; 简单修改一下在支持re的idea中搜索(\\([0-9]{3}\\)\\s|[0-9]{3}-)[0-9]{3}-[0-9]{4}$成功匹配到了正确的电话号码\n第8章 UNIX文件系统的高级操作 8.1 重定向 C语言程序一般会打开三个缺省文件，stdin、stdout、stderr，文件描述符分别是0,1,2。\n在Unix系统中，文件是io的基本抽象。标准输入、标准输出、错误输出可以替换为其它文件。\n输出重定向\ncommand \u0026gt; file\ncommand \u0026gt;\u0026gt; file 追加\n标准输入重定向\ncommand \u0026lt; file\ncommand \u0026lt;\u0026lt; EOF 标准输入，当碰到EOF字符串时，输入结束\n标准错误输出重定向\ncommand 2\u0026gt; file 将command的错误输出重定向到file文件\ncommand 2\u0026gt;\u0026gt; file 追加重定向\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 ls \u0026gt; mydir.list cat mydir.list //显示mydir.list 此时再 ls .. \u0026gt;\u0026gt; mydir.list //将新的内容追加到mydir.list rmdir ggg \u0026amp;\u0026gt;\u0026gt; mydir.list//将报错消息追加到mydir.list cat mydir.list ! anaconda3 CLionProjects Downloads examples.desktop mydir.list myfirst snap rmdir: 删除 \u0026#39;ggg\u0026#39; 失败: 没有那个文件或目录 为了提高效率，可以直接使用cat和\u0026gt;创建文件：cat file1\ncat file1 file2\u0026gt; file3可以将file1和file2文件内容复制到file3中。\ncat file3 \u0026gt;\u0026gt; file4 将file3追加到file4的末尾。\n8.2 管道 shell将一个程序的标准输出作为另一个程序的标准输入，形成管道（pipeline）\ncommand A | command B\n注意两条命令之间是以一个匿名文件传输\n单向通过，没有格式，以流的形式进行通信\n例如，我想在查找ls -l的结果中以正则表达式搜索s.*h，可以执行\nls -l|grep -e\u0026quot;s.*h\u0026quot;\n8.2.1 Shell如何实现管道？ 1.pipe()函数创建一个管道，两个文件描述符，一个输入，一个输出\n2.fork()创建子进程\n3.父进程关闭管道的输出端。\n4.子进程dup2，将标准输入替换为管道输入。\n5.子进程进一步关闭管道输入和输出。\n6.父进程写完数据后，关闭管道输出。\n7.子进程从父进程收到EOF，输入数据完毕。\n8.3 文件操作 cp拷贝源文件成目标文件\n短选项 长选项 功能 -b \u0026ndash;backup 如果目标文件存在，创建备份 -i \u0026ndash;interactive 如果目标文件存在，要求确认 -r \u0026ndash;recursive 将目录复制到新的目录 \u0026ndash;verbose 解释操作 \u0026ndash;help 显示帮助页并退出 mv移动文件\n短选项 长选项 功能 -b \u0026ndash;backup 如果目标文件存在，创建备份 -i \u0026ndash;interactive 如果目标文件存在，要求确认 -f \u0026ndash;force 强制移动，不要求确认 -v \u0026ndash;verbose 解释操作 \u0026ndash;help 显示帮助页并退出 \u0026ndash;version 显示版本信息并退出 8.4 ln链接文件 用于为已存在的文件创建另外的名字（链接）。\n假设有一个a.txt文件，想给他另一个名字b.txt\n输入$ sudo ln a.txt b.txt\n再查看一下目录$ ls -li\n1 2 10878 -rw-r--r-- 2 endwsl endwsl 0 Apr 12 20:08 a.txt 10878 -rw-r--r-- 2 endwsl endwsl 0 Apr 12 20:08 b.txt 1 2 3 4 5 endwsl@LAPTOP-U1E6STIA:/home$ cat \u0026gt;\u0026gt;a.txt atxt //修改一下a.txt的内容 endwsl@LAPTOP-U1E6STIA:/home$ cat b.txt //再去看b.txt的内容 atxt //发现竟然也是atxt 甚至ln命令不会创建新的i-node，而是引用已有i-node，增加引用计数。\nln –s符号链接，分配一个新的inode，内部记录指向原有文件。\n8.5 其他wc,head,tail wc统计字数\n短选项 长选项 功能 -l \u0026ndash;lines 统计行数 -w \u0026ndash;words 统计单词数量 -c \u0026ndash;chars 统计字符数量 \u0026ndash;help 帮助 1 2 3 4 5 6 $ wc -l mydir.list 19 mydir.list $ wc -w mydir.list 23 mydir.list $ wc -c mydir.list 215 mydir.list head显示文件头部，缺省显示头部10行。\n短选项 长选项 功能 -n \u0026ndash;lines=n 显示头部n行 -c \u0026ndash;chars=n 显示头部n个字符 \u0026ndash;help 显示帮助页并退出 \u0026ndash;version 显示版本信息并退出 tail显示文件尾部，缺省是尾部10行，与head类似就不再列举出。\npaste命令横向连接两个文件。缺省分隔符为TAB制表符。\n短选项 长选项 功能 -d x \u0026ndash;delimiters=x 指定域分隔符 \u0026ndash;help 显示帮助页并退出 \u0026ndash;version 显示版本信息并退出 8.6 sed替换 选项 含义 -e 脚本命令 该选项会将其后跟的脚本命令添加到已有的命令中。 -f 脚本命令文件 该选项会将其后文件中的脚本命令添加到已有的命令中。 -n 默认情况下，sed 会在所有的脚本指定执行完毕后，会自动输出处理后的内容，而该选项会屏蔽启动输出，需使用 print 命令来完成输出。 -i 此选项会直接修改源文件，要慎用。 一个使用的例子：\n我在使用群晖时发现：一旦ssd温度升高到61度就会引起自动关机,由于我的群晖没有风扇，对于ssd达到这个温度轻而易举，一个24小时工作的设备肯定不希望它经常关机，根据教程查看群晖的配置文件发现\n1 2 3 4 5 admin@DiskStation:/usr/syno/etc.defaults$ cat scemd.xml | grep -E \u0026#34;61\u0026#34; \u0026lt;disk_temperature fan_speed=\u0026#34;FULL\u0026#34; action=\u0026#34;SHUTDOWN\u0026#34;\u0026gt;61\u0026lt;/disk_temperature\u0026gt; \u0026lt;disk_temperature fan_speed=\u0026#34;FULL\u0026#34; action=\u0026#34;SHUTDOWN\u0026#34;\u0026gt;61\u0026lt;/disk_temperature\u0026gt; \u0026lt;disk_temperature fan_speed=\u0026#34;FULL\u0026#34; action=\u0026#34;SHUTDOWN\u0026#34;\u0026gt;61\u0026lt;/disk_temperature\u0026gt; \u0026lt;disk_temperature fan_speed=\u0026#34;FULL\u0026#34; 群晖的温度墙为61度，此时使用sed替换所有的61为70\nsudo sed -i\u0026quot;s/61/70/g\u0026quot; scemd.xml\n1 2 3 4 5 admin@DiskStation:/usr/syno/etc.defaults$ cat scemd.xml | grep -E \u0026#34;70\u0026#34; action=\u0026#34;SHUTDOWN\u0026#34;\u0026gt;70\u0026lt;/disk_temperature\u0026gt; \u0026lt;disk_temperature fan_speed=\u0026#34;FULL\u0026#34; action=\u0026#34;SHUTDOWN\u0026#34;\u0026gt;70\u0026lt;/disk_temperature\u0026gt; \u0026lt;disk_temperature fan_speed=\u0026#34;FULL\u0026#34; action=\u0026#34;SHUTDOWN\u0026#34;\u0026gt;70\u0026lt;/disk_temperature\u0026gt; \u0026lt;disk_temperature fan_speed=\u0026#34;FULL\u0026#34; action=\u0026#34;SHUTDOWN\u0026#34;\u0026gt;70\u0026lt;/disk_temperature\u0026gt; 这样就让温度墙设定为70度\n（由于群晖基于的是freebsd，因此在群晖的控制面板打开ssh即可使用ssh client登陆，注意：SSH 仅支持属于 local administrators 群组的帐户登录系统。默认端口为22）\n（尴尬的是改完温度墙以后，使用一段时间温度就会达到70°，只好去加了个风扇）\n不过使用s///g对替换里面字符里面要是有路径的话就会很难受,所以可以用s:::g来表示同样的意思。\n8.7 打开文件：grep命令 grep命令打开文件，在文件中以RE方式搜索字符串\n短选项 长选项 功能 -c \u0026ndash;count 只显示匹配的行数 -i \u0026ndash;ignore-case 忽略大小写匹配 -G \u0026ndash;basic-regexp BRE，grep缺省 -E \u0026ndash;extended-regexp ERE，egrep缺省 -e PATTERNS \u0026ndash;regexp=PATTERNS 指定一个或多个RE -v \u0026ndash;invert-match 显示不匹配的行 -n \u0026ndash;line-number 输出行号 -o \u0026ndash;only-matching 只输出匹配的部分 8.8 find查找文件 选项 功能 -name filename 根据给定的filename查找文件。 -size ± n 查找文件大小为n的文件 -type file type 查找指定类型的文件 -atime ± n 查找n天以前访问的文件 -mtime ± n 查找n天以前修改的文件 -newer filename 查找比filename更近期更新的文件 -print 显示找到的每个文件的路径名 -exec command\\； 对找到的文件执行command -ok command\\； 在执行command之前要求确认 -name选项实例：\n-find.-name first.c-print[Return] 查找文件名为first.c的文件。\n$find.-name \u0026ldquo;*.？\u0026quot;-print[Return] 查找文件名为点和单个字符结尾的文件。\n-size ± n选项：+表示大于，-表示小于。\n-type选项：\n-b : 块特殊文件（如磁盘） -c ：字符特殊文件（如终端） -d ： 目录文件 -f ： 普通文件 -emax\n统计/usr/include/sys目录下的所有目录及子目录个数\n1 find /usr/include/sys -type d|wc -l 查找epoll_wait函数在那个文件： find /usr/include –name “*.h” -type f | xargs grep ‘epoll_wait’\n搜索/usr/include目录中，引用EPOLLIN常数的头文件\n1 find -name \u0026#34;*.h\u0026#34; -type f|xargs grep \u0026#34;EPOLLIN\u0026#34;./linux/eventpoll.h:#define EPOLLIN\t0x00000001./x86_64-linux-gnu/sys/epoll.h: EPOLLIN = 0x001,./x86_64-linux-gnu/sys/epoll.h:#define EPOLLIN EPOLLIN 在usr/include中查找文件名以.h结尾的所有普通文件。\n1 find /usr/include -name \u0026#34;*.h\u0026#34; 8.9 文件系统 unix文件系统将每一个文件名与一个数字(inode)连接起来，并用文件的inode来标识每一个文件。\n磁盘结构：\n在unix先，磁盘是标准的块设备，unix的磁盘分为4个块\n引导块\n超级块 包含有关磁盘自身的信息\n磁盘的总块数 空闲块数 块的大小 已使用的块数 inode列表块\n保存inode列表，列表中的每一个表项是一个inode，有64字节存储空间。普通文件或者目录文件的inode包含文件在磁盘块的位置。特殊文件的inode包含标识外部设备的信息。除了以上，还有：\n文件访问权限（读写执行） 文件属主和组id 文件链接数 文件最后修改时间 文件最后访问时间 每个普通文件和目录文件的块位置 特殊文件的设备标识号 文件和目录块\n第二个inode包含根目录所在块的位置。创建目录时，系统自动创建两个表项：.（表示子目录）和..（表示父目录）\n第9章 探索Shell unix由内核和系统工具组成。内核是核心，所有直接与硬件通信的常规程序都集中在内核中。\nshell是用户和系统交流的工具，自身是一个应用程序。当用户登录到系统时shell被装入内存。\n用户登录时，init（进程号1）拉起login，输入密码成功后，由login进程拉起shell进程\n对于大多数用户键入的命令，shell并不执行，它fork子进程来执行命令，shell等待wait子进程结束（等待SIGCHLD信号）。\nshell的主要功能：\n命令执行 文件名替换 I/O重定向 管道：把简单程序连接到一起来完成一个较为复杂的任务。“|”就是管道操作符 环境控制：用户通过设定，可以变更主目录、命令提示符或工作环境 后台计算：shell的后台计算能力使用户能够在前台进行工作的同时在后台运行程序。 shell脚本 9.1 显示消息：echo命令 echo命令输出字符串，echo hello there就会输出hello there\n一般默认输出禁止换行\n9.2 shell 变量 bash shell 用一个叫做环境变量(environment variable)的特性来存储有关shell会话和工作环境的信息。这项特性允许用户存储信息，以便程序或shell中运行的脚本能够轻松访问。这也是持久存储数据的一种简便方法。\nUNIX支持两种变量:环境变量和局部变量。（shell变量是字符串）\n环境变量：为系统所知道的变量名，通常由系统管理员定义。 局部变量：用户定义，并完全由用户控制。 9.2.1 显示和清除变量：set和unset命令 使用set命令可以查看当前使用的shell变量\n使用echo显示变量的值。在这种情况下引用某个环境变量的时候，必须在变量前面 加上一个美元符（$）。\n1 echo $HOME 在echo命令中，在变量名前加上$可不仅仅是要显示变量当前的值。它能够让变量作为命令 行参数。\n1 ls $HOME 全局环境变量可用于进程的所有子shell。\nunset可以清除不想要的变量，也可以用赋值语句来修改用户变量或者标准变量。注意：标准shell变量的改变是占时的，只用于当前会话，当下次登录时，还要重新进行设置。如果想要长久改变系统变量的值，可以把变量放到名为.profile的文件中。\n9.2.2 标准 shell 变量 HOME 变量：shell把用户主目录的完整路径赋值给变量HOME。 IFS 变量：内部字段分隔符，用来用户输入的分隔命令。包括空格，tab，换行符。即IFS=$\u0026rsquo; \\t\\n\u0026rsquo; 。 MAIL 变量：接收用户邮件文件的文件名。 PATH 变量：shell在定位命令时所要查找的目录名。UNIX一般把可执行文件存在一个叫做bin的目录中。以下是我的键入shell后的结果： 1 PATH=\u0026#39;/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games\u0026#39; 9.3 其他元字符 9.3.1 重音符号 shell执行重音符号`中的命令，并将命令的输出插入到命令行的相应位置中，也被称为命令替换符。\n9.3.2 括号 将几个命令放在括号里，可以编组。一个命令组可以像单条命令一样被重定向。\n9.3.3 后台处理\u0026amp; jobs命令列举后台执行的作业\n9.4 其他UNIX工具 9.4.1 延时定时 sleep，让某个命令延缓一段时间执行。\n9.4.2 显示PID 当程序运行在系统上时，我们称之为进程（process）。想监测这些进程，需要熟悉ps命令的 用法。ps命令能输出运行在系统上的所有程序的许多信息。\n默认情况下，ps命令并不会提供那么多的信息,只显示PID,TTY,TIME,COMMAND\n默认情况下，ps命令只会显示运行在当前控制台下的属于当前用户的进程。\n选项 功能 -a 显示所有进程，但不包括会话leader，不包括无终端进程 -f 显示进程完整信息 -e 显示所有进程 -H 按照树型显示 -j 按照job形式输出 9.4.3 kill命令 终止不想要的进程\n根据执行情况的不同，kill发送给进程的信号范围可以取1-15.\n9.4.4 分离输出 tee将命令结果显示到终端同时保存到指定文件中。\nsort new.list|tee new1.list\n9.4.5 文本排序 sort对文件内容按照字母或数字排序。\n9.5 列出之前输入的命令 Bash在执行命令后，会在内存中记录所有使用的命令。当用户退出登录，所有命令保存在~/.bash_history文件中，history命令则列出到目前为止，执行的所有命令。使用这一功能可以使用用户已经键入过的命令，找到已经执行过的命令。\n~/.bash_history记录的是到上次退出前的所有命令，会一直增加并保存，最终会变得非常大。想要重新记录history的话可以将其删除。\nfc命令:列出、编辑和重复执行history命令列表文件的命令。\nfc first last 先编辑从first到last的命令，然后执行\nfc –s cmd cmd是history的命令编号，执行该编号任务\n9.6 创建别名 alias ll=‘ls –al’设置ll为ls -al命令的别名。\n第10章 Unix通信 UNIX提供了一组与其他用户通信的命令和工具。\n10.1 通信方式 10.1.1 write命令 write命令可以发送消息给系统内其他的已经登陆的用户。另一个用户无论在干什么，消息都会出现在屏幕上。甚至在使用vi时，write消息也会显示在光标处。但仅仅是覆盖在屏幕上的消息，不会破坏用户正在编辑的任务。当然也可以使用mesg禁止终端接收来自write命令的消息。\n10.1.2 显示新闻：news命令 用户可以使用news命令来看看系统正在做什么。news从系统news命令读出消息。默认显示news目录下用户还没有看过的所有文件。\n选项 操作 -a 显示所有的新闻项，无论是新的还是旧的 -n 仅仅列出新闻名 -s 显示当前新闻的总数 10.1.3 广播消息：wall命令 wall(write all)命令给当前登录到系统上的所有用户发送消息。通常由系统管理员使用，用于通知用户一些紧急事件。\n10.1.4 全双工通信：talk命令 talk命令与write相似，都用于用户与系统中已经登录的其他用户通信。输入talk和用户名，连接建立成功，两个用户就可以进行交谈了。这时，双方的终端屏幕上都将显示信息[Connection established]并响铃，同时屏幕被linux中talk命令程序以一条水平线分割为上下两部分，上半部分用来显示用户自己输入的内容，下半部分用来显示对方输入的内容。两个用户可以同时输入，他们输入的内容将会立即显示在双方的屏幕上。\n在用户进行输入时，可按BACKSPACE见来更正前一个字符，也可按CTRL+w来删除一个完整的单词，或者用CTRL+U来删除一整行，另外，用户还可以通过按CTRL+L来刷新屏幕。如果要结束交谈，可由任何一方按下CTRL+C来中断连接，但在结束对话前最好道声“再见”，并等待对方回应。linux中talk命令程序结束时，在屏幕上将回显示一条信息：\n[Connection closing. Exiting] 并非每次要求对方交谈都能成功，有时对方没有登录，则linux中talk命令程序提示信息：\n[Your party is not logged on] 并退出；如果对方已登录，但因某种原因（如不是正在使用机器）没有响应，那么linux中talk命令程序将会每隔10秒钟给他发一条邀请信息，同时在自己的屏幕上显示：\n[Ringing your party again] 如果用户不愿等待，则可以按CTRL+C终止linux中talk命令程序。还有的时候系统可能出现下面的信息： [Checking for invitation on caller’s machine] 这说明双方的linux中talk命令程序不兼容，这时可以试试ntalk和ytalk命令，如果没有，就只好找系统管理员了。\n如果用户在做某些紧急工作（如编辑邮件）时不希望被linux中talk命令的邀请打搅，他可以使用命令：mesg n来暂时拒绝交谈，这时如果有用户邀请他交谈，只能得到提示信息：[Your party is refusing messages]\n10.2 电子邮件 mailx工具为用户提供电子邮件系统，可以给系统上其他用户发邮件，无论对方是否已经登录到系统。\n当用户使用mailx读取文件时，它处于命令模式，该模式的命令提示符是问号。\n命令 功能 ! 让用户执行shell命令（shell转义） cd directory 切换到指定的目录direction，如果没有指定目录，则切换到主目录 d 删除指定消息 f 显示消息头行 q 退出mail，并将消息从系统邮箱移去 h 显示当前消息头 m users 给指定用户users发送邮件 R messages 给消息messages发送者回复消息 r messages 给消息messages发送者和同一消息的其他所有接收者回复消息 s messages 保存消息到filename文件 t messages 显示指定消息messages u messages 恢复已删除的指定消息messages x 退出mailx，不将消息从系统邮箱中移去 mailx的~转义命令\n命令 功能 ~? 显示~转义命令列表 ~! command 在编辑邮件时，让用户调用指定的shell命令command ~ e 调用编辑器 ~ p 显示当前正编辑的消息 ~r filename 读取filename文件 ~\u0026lt; filename 读取filename文件 ~\u0026lt;! command 执行指定命令command ~v 调用默认编辑器vi ~q 推出输入模式 ~w filename 将当前正编辑的消息写到filename文件中 第11章 GNU 工具链 11.1 Gnu工具链 Gnu toolchain是开发操作系统、应用程序的一套完整的程序和库，包括gcc、gdb、glibc：\n11.2 gcc 是一族编译器，包括c、c++、go、java等\n前端+后端\n.c为后缀的文件，C语言源代码文件；\n.a为后缀的文件，是由目标文件构成的档案库文件；\n.C、.cc或.cxx 为后缀的文件，是C++源代码文件；\n.h为后缀的文件，是程序所包含的头文件；\n.i 为后缀的文件，是已经预处理过的C源代码文件；\n.ii为后缀的文件，是已经预处理过的C++源代码文件；\n.m为后缀的文件，是Objective-C源代码文件；\n.o为后缀的文件，是编译后的目标文件；\n.s为后缀的文件，是汇编语言源代码文件；\n.S为后缀的文件，是经过预编译的汇编语言源代码文件。\nC语言编译过程\ngcc -E hello.c -o hello.i\ngcc -S hello.i -o hello.s\ngcc -c hello.s -o hello.o\ngcc -o hello hello.o\n11.3 gdb gdb program 命令 缩写 描述 list l 打印当前位置源码 break b 设置断点 run r 运行程序 step s 单步，进入函数 next n 单步，不进入函数 print p 打印变量 continue c 继续运行 backtrace bt 显示调用栈 info threads 显示线程 thread n 切换线程 set scheduler-locking on 关闭线程调度 11.4 makefile Makefile用于工程组织和编译，与常见的命令式语言不同，它是一种依赖推导语言。\nShell语言：变量定义+命令执行\nMakefile：变量定义+依赖描述\n显式规则与隐式规则\n%.o: %.c\n$(COMPILE.c) $(OUTPUT_OPTION) $\u0026lt;\n推导规则\n检查目标和依赖文件的时间，如果依赖更新，则执行动作\n显式规则 \u0026gt; 隐式规则\n推导过程\n动态规划\n从target出发，枚举所有规则，直到依赖可达\n11.5 cmake cross platform make跨平台自动化建置系统。\nCmake vs Makefile\nMakefile的依赖推导不直观 Cmake的语法设计采用命令式 跨平台，可以导出为makefile、sln等 Cmake在不同平台上生成不同的本地化脚本\nLinux下的Gnu Makefile Visual Studio的sln Google等ninja Cmake管理的代码编译主要有两步：\n利用cmake生成本地编译脚本\n利用本地脚本编译程序\n基本语法\n定义工程\n设置变量\n添加可执行目标\n添加递归目录\n添加静态库、动态库\n条件分支\n定制命令和目标add_custom_command/add_custom_target\n第12章 Shell编程 Shell是一种语言，bash、csh\nUnix的传统是提供基本的功能，由用户自行扩展，包括自己编写shell脚本 12.1.1 编写简单脚本 1 2 $ cat \u0026lt;\u0026lt;EOF\u0026gt;\u0026gt; won.list\u0026gt; ls\u0026gt; -bash: warning: here-document at line 74 delimited by end-of-file (wanted `EOF\u0026#39;) $ cat won.listls 12.1.2 执行脚本 执行脚本 sh won.list :\n1 $ sh won.list- ew ew.list goodstuff new.list vinew won.list xxxscript 另一种方法：chmod改变文件权限，使其变成可执行\n脚本工作原理\nloader程序加载脚本，发现不是elf可执行文件，返回错误\nbash收到错误，然后打开文件头部，发现是脚本\n调用脚本执行\n•基于兼容性考虑\n#! /bin/sh\nDebian上的/bin/sh符号链接指向dash\ndash对标准的兼容性更好\n12.2.1 使用特殊字符 echo换行：echo \u0026quot;\\nhello\\n\u0026quot;\n12.2.2 退出系统的方式 在shell脚本里写exit是没用的，因为shell会fork子进程来执行命令。\n12.2.3 点命令 可以使用点命令来阻止shell创建子进程。\n12.2.4 读取命令：read 从标准输入设备读取用户输入，并将值存入用户自定义变量中。\n12.3.1 注释 12.3.2 变量 字符串类型，具体内容在前面讲过。\n12.3.3 命令行参数 shell脚本可以从命令行最多读取10个命令行参数存入特殊变量，命令行参数是用户输入命令后所跟的数据项，通常用空格分隔。这些变量按顺序从1到9计数。\n参数变量 $1-$9，${10}表示参数 $0表示被调用脚本的名字 $#表示参数个数 $*将所有参数使用$IFS隔开，形成一个字符串 $@是每个参数一行，将参数隔开，实际上是多个字符串，可以用在for循环 $$表示当前进程id 特殊变量\n$?表示进程退出状态\nls -al hello\necho $? 前面命令退出的状态\n另外一个给变量赋值的方式是set\nset hello \u0026quot;I love bash\u0026quot; world\n1 2 3 4 5 6 7 8 9 10 endwsl@LAPTOP-U1E6STIA:~$ echo $0 -bash endwsl@LAPTOP-U1E6STIA:~$ echo $# 3 endwsl@LAPTOP-U1E6STIA:~$ set hello \u0026#34;i love\u0026#34; world endwsl@LAPTOP-U1E6STIA:~$ echo $#3 //3个参数hello 和\u0026#34;i love\u0026#34;和world endwsl@LAPTOP-U1E6STIA:~$ echo $1hello endwsl@LAPTOP-U1E6STIA:~$ echo $2i love bash endwsl@LAPTOP-U1E6STIA:~$ echo $3world endwsl@LAPTOP-U1E6STIA:~$ echo $* //$*和$@相似hello i love world 1 2 endwsl@LAPTOP-U1E6STIA:~$ echo $*hello i love world endwsl@LAPTOP-U1E6STIA:~$ echo $@hello i love world 12.3.4 条件与测试 if-then-elif结构：\n1 if条件; then command1elif command2 then command3 else command4fi 真或假：test命令\n实际上，if语句中括住条件的方括号是test命令的一种特殊形式。\n例子：\n1 minatoxeon@OMEN:~$ cat eg_conditionechoecho \u0026#34;enter y or n:\\c\u0026#34;read condif [ $cond = y ]then echo \u0026#34;you enter y\u0026#34;else echo \u0026#34;you not enter n\u0026#34;fiechoexit 0minatoxeon@OMEN:~$ sh eg_conditionenter y or n:yyou enter yminatoxeon@OMEN:~$ sh eg_conditionenter y or n:llyou not enter n 12.3.5 不同类型的判断 不单单是相等的判断，test可以进行多种类型的判断\n操作符 例子 含义 -eq a -eq b a是否等于b -ne a -ne b a是否不等于b -gt a -gt b a是否大于b -ge a -ge b a是否大于大于b -lt a -lt b a是否小于b -le a -le b a是否小于等于b test还可以比较字符串\n操作符 示例 说明 = “$STR1” = “STR2” 两个字符串是否相同 != “$STR1” != “STR2” 两个字符串是否不同 -n -n “$STR” 字符串不是null -z -z “$STR” 字符串是null 注意：在引用变量做字符串测试时，一定要加引号\n操作符两侧必须有空格\n[ … ]中括号必须有空格 [ \u0026quot;$VAR1\u0026quot; = \u0026quot;VAR3\u0026quot; ]\n文件\n12.3.6 参数替换 用户可以检验参数的值并根据选项改变它的值。\n格式为${parameter:optionchar word}\n变量替换\n替换操作 功能 ${VAR:-word} 如果变量不存在，返回word #变量不会创建 ${VAR:=word} 如果变量不存在，设置VAR变量为word，返回word ${VAR:?message} 如果变量不存在，打印message，退出，但交互shell不会退出 ${VAR:+word} 如果变量存在，返回word；否则返回null 1 endwsl@LAPTOP-U1E6STIA:~$ echo ${VAR:-world} #变量不会创建worldendwsl@LAPTOP-U1E6STIA:~$ echo $VAR ${var:?meg}通常用来显示错误信息\n12.4 算术表达式 12.4.1 算术运算：expr命令 在powershell里可以直接输入1+1，会得到2\n但是在shell里直接输入1+1不会有结果，因为Shell会把1单作是字符串而不是变量，那么要想在shell里面计算1+1怎么办？\n1 expr 1+1 expr提供数字和非数字的关系运算符\n12.4.2 算术运算：let命令 let命令与expr命令类似，并可以相互替换。\nlet命令自动使用变量的值：\n1 minatoxeon@OMEN:~$ x=100minatoxeon@OMEN:~$ let x=x+1minatoxeon@OMEN:~$ echo $x101 let命令的缩写：双括号(())\n下面就是i++的经典问题\n1 endwsl@LAPTOP-U1E6STIA:~$ i=4endwsl@LAPTOP-U1E6STIA:~$ echo $i4endwsl@LAPTOP-U1E6STIA:~$ echo $((i++)) $i4 5endwsl@LAPTOP-U1E6STIA:~$ echo $((++i)) $i6 6 12.5 循环结构 Shell提供三种循环：for、while、until 循环与分支类似，都带有一定的结构，是shell语言的支持 12.5.1 for循环：for-in-done 结构 1 for variablein list-of-valuesdo\tcommands ...\tlast-commanddone 例子：\n1 endwsl@LAPTOP-U1E6STIA:~$ cat sum1.sh#! /bin/bashtotal=0for i in \u0026#34;$@\u0026#34;do total=$(($total + $i)) printf \u0026#34;$i + \u0026#34;doneprintf \u0026#34;\\b\\b= $total\u0026#34; 12.5.2 while循环 直接上例子：\n1 2 3 4 5 6 7 8 9 10 11 endwsl@LAPTOP-U1E6STIA:~$ cat sum.sh #! /bin/bash #这里的$#每经过一轮循环就会减1 #位置参数可以用shift命令左移 total=0 while [ $# -gt 0 ]; do total=$(($total + $1)) printf \u0026#34;$1 + \u0026#34; shift done printf \u0026#34;\\b\\b= $total\u0026#34; 12.5.3 until循环 1 2 3 4 5 6 7 8 #! /bin/bash total=0 until [ $# -le 0 ]; do total=$(($total + $1)) printf \u0026#34;$1 + \u0026#34; shift done printf \u0026#34;\\b\\b= $total\u0026#34; 逻辑连接 这里的\u0026amp;\u0026amp;和||和预想的会很不一样，举例如下：\ncommand1 \u0026amp;\u0026amp; command2当command1正确执行，才会执行command2\n相当于：\n1 2 if command1 : command2 command1 || command2，当command1执行错误，才会执行command2\n1 if !command1 : command2 代码分块 将多行命令用分号;隔开，再利用()将多条命令组合在一起\n1 endwsl@LAPTOP-U1E6STIA:~$ (date ; echo $$)(date ; echo $$)+ dateMon 26 Apr 2021 09:07:31 PM CST+ echo 1717 算术表达式测试\n利用$(())计算算术表达式 利用字符串比较 [ $((2+3)) = 5 ]; echo $? i=3; [ $((i+7)) = 10 ];echo $? 调试 替换处理后真实执行的指令，比如展开$$\n1 endwsl@LAPTOP-U1E6STIA:~$ echo \u0026#34;hello world\u0026#34;hello worldendwsl@LAPTOP-U1E6STIA:~$ set -vxendwsl@LAPTOP-U1E6STIA:~$ echo \u0026#34;hello world\u0026#34;echo \u0026#34;hello world\u0026#34; #原始命令+ echo \u0026#39;hello world\u0026#39; #替换处理后真实执行的指令hello world# 指令结果endwsl@LAPTOP-U1E6STIA:~$ 第13章 Shell脚本：编写应用程序 13.2 UNIX内核：信号 终止一个进程可以通过产生一个中断信号来终止进程。例如Del键、Break键和Ctrl-c键。\n有几类不同的事件导致内核向进程发送信号。信号编号表明它们代表的事件。\n信号编号 信号名 含义 1 挂起 丢失终端连接 2 中断 按下任一中断键 3 退出 按下任一退出键 9 杀死 发出kill-9命令 15 终止 发出kill命令 挂起信号：信号1用来通知进程系统已经与终端失去联系。当用户终端和计算机的连线断开，或者电话线（用来调制解调器相连）断开时，产生该信号。在某些系统中，如果用户关闭终端，系统也会产生挂起信号。\n中断信号：当按下任何一个中断键时，产生信号2。中断键可以是Del键、Break键或者Ctrl-c键。\n退出信号：当按下Ctrl-\\键时，产生信号3。在进程终止之前，将进行内存信息转储。\n终止信号：信号9和15由kill命令产生。信号15是默认的信号。信号9和15都使收到信号的进程终止。\nkill -l查看信号表\n1 endwsl@LAPTOP-U1E6STIA:~$ kill -l 1) SIGHUP 2) SIGINT 3) SIGQUIT 4) SIGILL 5) SIGTRAP 6) SIGABRT 7) SIGBUS 8) SIGFPE 9) SIGKILL 10) SIGUSR111) SIGSEGV 12) SIGUSR2 13) SIGPIPE 14) SIGALRM 15) SIGTERM16) SIGSTKFLT 17) SIGCHLD 18) SIGCONT 19) SIGSTOP 20) SIGTSTP21) SIGTTIN 22) SIGTTOU 23) SIGURG 24) SIGXCPU 25) SIGXFSZ26) SIGVTALRM 27) SIGPROF 28) SIGWINCH 29) SIGIO 30) SIGPWR31) SIGSYS 34) SIGRTMIN 35) SIGRTMIN+1 36) SIGRTMIN+2 37) SIGRTMIN+338) SIGRTMIN+4 39) SIGRTMIN+5 40) SIGRTMIN+6 41) SIGRTMIN+7 42) SIGRTMIN+843) SIGRTMIN+9 44) SIGRTMIN+10 45) SIGRTMIN+11 46) SIGRTMIN+12 47) SIGRTMIN+1348) SIGRTMIN+14 49) SIGRTMIN+15 50) SIGRTMAX-14 51) SIGRTMAX-13 52) SIGRTMAX-1253) SIGRTMAX-11 54) SIGRTMAX-10 55) SIGRTMAX-9 56) SIGRTMAX-8 57) SIGRTMAX-758) SIGRTMAX-6 59) SIGRTMAX-5 60) SIGRTMAX-4 61) SIGRTMAX-3 62) SIGRTMAX-263) SIGRTMAX-1 64) SIGRTMAX 13.2.1 捕捉信号：trap命令 当进程接收到任何信号时，其默认处理功能是立即终止。使用trap命令可以改变进程的默认处理功能，执行指定的处理功能。\ntrap命令的格式：trap\u0026quot;optional commands\u0026quot;signal numbers\ncommands部分是可选的。如果有这一部分，当进程收到任一指定捕捉信号时，执行这些命令。\n注意：trap指定的命令必须用单引号或者双引号括起来。\n说明：1. 可以指定捕捉多个信号。\n​\t2.信号编号是与用户希望用trap命令捕捉的信号相关联的数字。\n13.2.2 捕捉复位 当希望在脚本中的一部分捕捉信号，而另一部分不捕捉信号时，捕捉复位命令就很有用。\n例如：\n$trap \u0026quot; \u0026quot;2 3 15 忽略中断、退出和终止信号，如果按下这些键中的任一个，脚本继续运行。 $trap 2 3 15 复位指定的信号，就是恢复中断、退出和终止键。按下些键中的任一个，正在运行的脚本就会终止。 13.2.3 设置终端参数：stty命令 stty命令用来设置和显示终端属性。不带参数的stty命令显示指定的一组设置。用-a选项可以列出所有的终端设置。\n•stty设定终端模式\nstty –echo禁止回显，输入口令时，同时也会把命令会先禁了 stty echo打开回显，撤销上一步 13.3 对终端的进一步讨论 UNIX操作系统支持多钟终端类型，功能不限于清屏，还有粗字体、闪烁、下划线，等等。利用这些特性能使屏幕显示更有意义或更美观。\n13.3.1 终端数据库：terminfo文件 terminfo数据库是一个文本文件，其中包括各种终端类型的描述。数据库里的每一类终端都有一个功能列表。\n13.3.2 设置终端功能：tput命令 tput实用程序允许用户打印出任一功能的值。这样就可以在shell编程中使用终端的功能。\n•tput向终端缓冲输出控制字符\n•tput clear清屏\n•tput cup row column移动光标到row行column列\n终端功能的简单列表：\n参数 功能 bel 回显终端的响铃字符 blink 闪烁显示 bold 粗体显示 clear 清屏 cup r c 将光标移到r行c列 dlim 使显示变暗 ed 从光标位置到屏幕底清屏 el 清除从光标位置到行末的字符 smso 启动突显模式 rmso 结束突显模式 smul 启动下划线模式 rmul 结束下划线模式 rev 反色显示，白底上显示黑色 sgr 0 关闭所有属性 13.4 其他命令 多路分支：case结构 当需要使用许多elif语句时，用case结构更好。\ncase、in和esac（case的反序）是保留字（关键字）。case和esac之间的语句称为case结构体。\nshell执行case语句时，将变量的内容与每一个模式比较，知道发现一个匹配或者shell到达关键字esac。shell执行与匹配模式相关联的命令。默认情况用*)表示，必须是程序的最后一种情况。每一种情况用两个分号（；；）结束。\n其他命令 磁盘命令\ndu\n1 2 3 4 5 6 7 8 9 10 11 12 13 endwsl@LAPTOP-U1E6STIA:~$ df Filesystem 1K-blocks Used Available Use% Mounted on /dev/sdb 263174212 788056 248948000 1% / tmpfs 6475860 0 6475860 0% /mnt/wsl tools 209715196 192647796 17067400 92% /init none 6473568 0 6473568 0% /dev none 6475860 4 6475856 1% /run none 6475860 0 6475860 0% /run/lock none 6475860 0 6475860 0% /run/shm none 6475860 0 6475860 0% /run/user tmpfs 6475860 0 6475860 0% /sys/fs/cgroup C:\\ 209715196 192647796 17067400 92% /mnt/c D:\\ 289083388 253954812 35128576 88% /mnt/d tar\ntldr tar\nchown修改文件目录的owner,修改inode\nchgrp修改文件目录的group\n","date":"2021-06-17T13:50:16+08:00","permalink":"https://junling.li/posts/unix%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/","section":"posts","tags":null,"title":"Unix笔记"},{"categories":null,"contents":"19. 删除链表的倒数第 N 个结点 难度中等\n给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。\n**进阶：**你能尝试使用一趟扫描实现吗？\n示例 1：\n1 2 输入：head = [1,2,3,4,5], n = 2 输出：[1,2,3,5] 示例 2：\n1 2 输入：head = [1], n = 1 输出：[] 示例 3：\n1 2 输入：head = [1,2], n = 1 输出：[1] 提示：\n链表中结点的数目为 sz 1 \u0026lt;= sz \u0026lt;= 30 0 \u0026lt;= Node.val \u0026lt;= 100 1 \u0026lt;= n \u0026lt;= sz 相比昨天写的147题，这个明显就简单很多，一次遍历解题的关键：两个间隔长度为n的指针，当第二个指针滑到最后时，第一个指针就达到的倒数第n个，此时删除这一个节点就行了。\n小技巧，添加dummy节点，以防第一个节点被删除。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public static ListNode removeNthFromEnd(ListNode head, int n) { ListNode dummyHead =new ListNode(0); dummyHead.next=head; ListNode pre=dummyHead; ListNode last=dummyHead; for(int i=0;i\u0026lt;n;i++){ last=last.next; } while(last.next!=null){ last=last.next; pre=pre.next; } pre.next=pre.next.next; return dummyHead.next; } ","date":"2021-05-05T23:26:12+08:00","permalink":"https://junling.li/leetcode/19%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACn%E4%B8%AA%E7%BB%93%E7%82%B9/","section":"LeetCode","tags":null,"title":"19.删除链表的倒数第N个结点"},{"categories":null,"contents":"147. 对链表进行插入排序 对链表进行插入排序。\n插入排序的动画演示如上。从第一个元素开始，该链表可以被认为已经部分排序（用黑色表示）。 每次迭代时，从输入数据中移除一个元素（用红色表示），并原地将其插入到已排好序的链表中。\n插入排序算法：\n插入排序是迭代的，每次只移动一个元素，直到所有元素可以形成一个有序的输出列表。 每次迭代中，插入排序只从输入数据中移除一个待排序的元素，找到它在序列中适当的位置，并将其插入。 重复直到所有输入数据插入完为止。 示例 1：\n1 2 输入: 4-\u0026gt;2-\u0026gt;1-\u0026gt;3 输出: 1-\u0026gt;2-\u0026gt;3-\u0026gt;4 示例 2：\n1 2 输入: -1-\u0026gt;5-\u0026gt;3-\u0026gt;4-\u0026gt;0 输出: -1-\u0026gt;0-\u0026gt;3-\u0026gt;4-\u0026gt;5 看起来很简单的插入排序花了我一晚上.\n插入排序不需要多讲，题面总结得很精辟，每一步将一个待排序的数据插入到前面已经排好序的有序序列中，直到插完所有元素为止。在其实现过程使用双层循环，外层循环对除了第一个元素之外的所有元素，内层循环对当前元素前面有序表进行待插入位置查找，并进行移动。\n插入排序的平均时间复杂度也是 O(n^2)，空间复杂度为常数阶 O(1)，具体时间复杂度和数组的有序性也是有关联的。\n插入排序中，当待排序数组是有序时，是最优的情况，只需当前数跟前一个数比较一下就可以了，这时一共需要比较 N-1 次，时间复杂度为 O(N)。最坏的情况是待排序数组是逆序的，此时需要比较次数最多，最坏的情况是 O(n^2)。\n但是 链表就不能简单移动了，而是要做到插入（把节点插入相应的地方），遍历找到要插入的地方以后，还要实现交换操作（和数组最大的不同也是最难的地方）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 public static ListNode insertionSortList(ListNode head) { ListNode todo=head.next; /*最坑的地方是在画图，总结到一个经验，画图其实不如调试，调试起来看变化，再画图微调最好，傻乎乎画图最后会绕死进去 * 添加一个表头节点非常有必要，这还是看题解发现的，不然插入时只能分情况讨论越来越复杂 * pre节点防止断裂，注意要及时更新pre节点 * todo这种变量名就不知所云，下次记得用cur * */ ListNode dummyHead=new ListNode(0); dummyHead.next=head; ListNode todohead=dummyHead; ListNode todopre=dummyHead.next; while (todo!=null){ while(todohead.next!=null\u0026amp;\u0026amp; todo.val\u0026gt;todohead.next.val){ todohead=todohead.next; } if(todo==todohead.next){ /*不能用值的比较！！！！，这个是作为循环终止的条件（使用continue直接下一步，防止进行5步交换）：等到todohead.next循环到todo时，让todo后移，注意不仅仅要使得todo后移，todopre也要后移，todohead要归零*/ todo=todo.next; todopre=todopre.next; todohead=dummyHead; continue; } todopre.next=todo.next; todo.next=todohead.next; todohead.next=todo; todo=todopre.next; todohead=dummyHead; //这5步画图吧 } return dummyHead.next; } ","date":"2021-05-04T22:08:41+08:00","permalink":"https://junling.li/leetcode/147%E9%93%BE%E8%A1%A8%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/","section":"LeetCode","tags":null,"title":"147.链表插入排序"},{"categories":null,"contents":" 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class moveZeroes { public static void moveZeroes(int[] nums){ //快慢指针的思想和removeElement这一题有着异曲同工之妙 int i=0,j=0;//i是慢指针 指向第一个0，j是快指针 指向第一个非0 for(;;i++){ if(nums[i]==0)break;//虽然我也觉得这里的循环写得很奇怪，但是思想还是很清晰的：第一个找到0！！如果出界就退出 if(i+1==nums.length) return; } j=i+1;//j是从i右边开始起步的 for (;;j++){ if(j\u0026gt;=nums.length) return; if(nums[j]!=0)break; } // System.out.println(i+\u0026#34;j\u0026#34;+j+\u0026#34;----------\u0026#34;); for(;j\u0026lt;nums.length;j++){ if(nums[j]!=0){ if(nums[j]!=0){ nums[i]=nums[j]; nums[j]=0; i++; } } } } public static void main(String[] args) { int []nums={0,0}; moveZeroes(nums); for(int i=0;i\u0026lt;nums.length;i++){ System.out.println(nums[i]); } } } ","date":"2021-04-30T17:01:19+08:00","permalink":"https://junling.li/leetcode/283.%E7%A7%BB%E5%8A%A80/","section":"LeetCode","tags":["Leetcode","Medium"],"title":"283.移动0"},{"categories":null,"contents":"来源https://sspai.com/post/59904\n利用github + hugo 搭建轻量化的blog ，非常有用的教程！\n1. 安装 Git 和 Go 使用Hugo前需要安装Git 和 Go 语言开发环境，点击对应网址下载安装包即可。\n2. 安装Hugo 网上存在很多用工具安装的方式，我这里讲述一个我认为最简单的方式，不用涉及太多的代码（本方法针对pc）。\n（1）在Hugo的官网中选择想要的版本下载zip，将其中的hugo.exe文件解压到想要的地方，比如 C:\\Hugo\\bin。\n（2）将Hugo添加到Windows的环境变量 PATH中。\n（3）添加完PATH后，打开Git Bash 输入 hugo version 出现hugo static site generator相关信息表示安装完成。\n3. 生成博客 （1）打开Git Bash 输入hugo new site \u0026quot;你的文件名字\u0026quot;，便可以生成一个用于存放博客的文件夹。\n（2）安装主题。\n不同于hexo，hugo没有自带主题，所以建立完文件夹后要导入主题文件。导入主题方式和hexo相似，可以用git clone 的方式，也可以到相应主题的github中下载zip文件然后解压到自己博客的themes文件夹中。\n推荐几个主题：Pure、Even、Coder\n官网主题库：Hugo Themes\n（3）配置文件\nHugo配置文件放置在源文件下，并且支持三种格式：toml，yaml，yml。这个配置文件可以直接从主题文件中的exampleSite 里copy到博客文件夹下，然后进行修改。\n注意点1：有些主题没有提供相应的配置文件，得进行自己修改，不建议选用这类主题。 注意点2：配置文件中要确保里面的主题名字和你themes文件夹中相应的主题文件夹名字一样，比如我的主题是pure，那么配置文件里的theme = pure，并且themes 文件夹中也有一个pure的文件夹。这是为了保证工具能依据名字找到相应的主题文件。 （4）生成博文\n在 Git Bash 中输入 hugo new posts/xxxx.md，这时候就会在文件夹 content/posts形成你要的markdown文件，打开进行编辑即可。\n（5）渲染查看效果\n在博客文件夹中打开Git Bash，输入 hugo server，然后打开 http://localhost:1313/ 来查看效果。注意，markdown文件中的 front matter 部分有一个draft 参数，如果draft设置为true 则可正常渲染，如果设置为false则不予以渲染。相应的如果想查看全部效果则输入hugo server -D 表示将草稿文件也进行渲染。\n4. 代码托管 这里主要以GitHub 作为代码托管，假定你已经建立了一个xxx.github.io的一个仓库。官方提供了三四种上传方式，本文采用生成docs的方式进行部署，个人认为这种方式比较简单明了。\n（1）修改配置文件。在配置文件config.toml中添加publishDir = docs，其他格式的配置文件类似。\n（2）打开Git Bash，输入hugo，就会发现博客文件中出现了docs文件夹，这是因为hugo将网页的信息都存储在docs里，而不是public中。\n（3）在博客文件夹中，打开Git Bash，依次输入以下代码（注意 git remote add 后跟随自己github的对应地址）：\n1 2 3 4 git remote add origin https://github.com/xxxxx/xxxx.github.io.git git add . git commit -m \u0026#34;first commit\u0026#34; git push -u origin master （4）在GitHub对应的仓库设置中，将Github Pages source改成branch/docs 。\n（5）这时候点击网址会发现内容已经成功渲染了，但是跳转连接出现问题，这是因为我们没有在配置文件中的baseURL中更新我们未来发布的网址链接。因此我们将GitHub Pages 对应的网址进行复制然后添加到配置文件的第一个 baseURL中，重新进行第二步和第三步即可。\n","date":"2021-04-27T21:50:40+08:00","permalink":"https://junling.li/posts/%E6%90%AD%E5%BB%BA%E4%B8%8E%E5%8F%91%E5%B8%83blog/","section":"posts","tags":null,"title":"搭建与发布blog"},{"categories":null,"contents":" 这种链表题一定要画图\n头插法\n遍历原链表+每次插入到新表最前面\n206. 反转链表 难度简单\n给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。\n示例 1：\n1 2 输入：head = [1,2,3,4,5] 输出：[5,4,3,2,1] 示例 2：\n1 2 输入：head = [1,2] 输出：[2,1] 示例 3：\n1 2 输入：head = [] 输出：[] 提示：\n链表中节点的数目范围是 [0, 5000] -5000 \u0026lt;= Node.val \u0026lt;= 5000 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 package Test; class ListNode { int val; ListNode next; ListNode() {} ListNode(int val) { this.val = val; } ListNode(int val, ListNode next) { this.val = val; this.next = next; } }5t class Test { public static ListNode reverseList(ListNode head){ ListNode first= new ListNode(); ListNode copy; if(head!=null){ first.val=head.val; copy=head.next; }else return head; while (copy!=null){ ListNode temp= new ListNode(); temp.val=copy.val; temp.next=first; copy=copy.next; first=temp;//每次first指针前移，让他始终指向第一个元素 } return first; } public static void main(String[] args) { ListNode a=new ListNode(5); a.next=new ListNode(4); a.next.next=new ListNode(3); ListNode b=reverseList(a); while(b!=null){ System.out.println(b.val); b=b.next; } } } ","date":"2021-04-27T20:27:17+08:00","permalink":"https://junling.li/leetcode/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/","section":"LeetCode","tags":null,"title":"反转链表"},{"categories":null,"contents":"评价手机免不了打打嘴炮，写写垃圾，以下为云评测，如有不对的地方敬请指教。\n1.K40系列\nK40系列只有标准版是比较出众的，可以说把性价比做到了极致，卢伟冰可以说很好地完成了雷军交给红米的任务：极致性价比，留下小米的学生党和性价比党用户，并与realme和iqoo相比不落下风。redmi没有品牌转型的任务，价位段封顶4000元，不需要使用最新的技术，所以小米的120W快充不会下放redmi，红米今年的充电上限还是33w。这一点和iqoo不一样，iqoo作为19年的新品牌，初期仍需要打品牌，做充分的推广。所以iqoo从20年失败的iqoo3到120w的iqoo5p，再到今年的iqoo7，努力想做高端手机。\n红米今年K40系列采用几乎相同的磨具，只在SoC和摄像头做区分，pro的升级点可以说少得可怜，3699的pro+甚至还是33w的快充，只能看做成pro的大内存版，没有充足的理由让人掏钱买pro+；这一点，是redmi头顶上有小米11的无奈，如果小米数字旗舰站稳4999价位，那么红米才会有充足的加价空间。\n采用相同的模具可以降低研发、制造、售后成本，降低售价，并且快速进行产能切换，哪款卖得好就生产哪一款，但是也造成了pro的平庸，无法增加更多的配置打动消费者，仅凭1个系列覆盖2000-4000价位段十分困难，所以才会有去年三种不同的屏幕形态的K30，ultra和s ultra\n小米一直希望极致性价比，但是性价比并不是出路。经过市场的磨练，除了小米，其他玩性价比的厂商都死了，虽然可以证明小米的牛逼，但同时也证明了性价比模式的脆弱。小米也意识到这一点，所以在19年时，将性价比的任务全部交给redmi，但是，红米的骨子里永远摆脱不了小米的基因，始终无法做切割。一是红米的独立性不足，战略受限于小米的高层。二是名字相近，红米==小米的印象已经深深刻入大众的骨子里。不像realme和oppo一加，iqoo和vivo，在绝大部分人眼里，红米就是小米的低端，小米就是中低端性价比手机品牌。而要打破这一品牌认知，没有3-5年的积累是不够的，而且需要在3-5年里在核心技术、渠道、售后超越oppo，vivo，才能做到最后的销量超越。\n（K40的顶配是3月初在小米商城用米金兑换的购买资格，日常用它来打paj，不算云评测了哈，在性能释放方面很舒服，但感觉比k30p烫点，不知道是不是开了90hz的缘故）\n2.Realme GT系列\nrealme显然没有做到iqoo的水平，在中高端旗舰产品上比友商差很多，没有特色功能和眼前一亮的点，总之还没找到感觉。\n3.IQOO neo 5\nneo5在大部分参数做到了甚至超过了k40的水平，imx598胜过k40的582，55w快充也比33w快充牛\n但同时也在价格上超越了k40，在买不到K40 的情况下，是公认的平价替代的最佳选择，最高价12+256可以2800左右拿到，仅比k40的12+256黄牛加价版高一点点。没有什么好评价的，k40的第一竞争对手足以说明实例。\n4.小米11 Pro 和 Ultra 及 MIX FOLD\n预热时说产品很多，没想到这么多，更没想到开两天的发布会。重磅消息一个接一个。小米新logo，三个旗舰手机，一个11青春版，一台屏幕素质高的轻薄笔记本，一颗澎湃芯片，最重要的是小米宣布造车。\n手机方面，最具关注的是ultra，作为小米的最高端手机，背面的副屏赚足了眼球，5999的起售价也刷新了记录，6999的顶配12+512，价格不用多说，小米的顶峰。\n67W有线+67W无线，无线刷新了记录，234g的重量也刷新了记录，小米能给你的最好的堆料，都在这里，我就不复述厂商的PPT了。\n而对小米最大的意义，是有一台手机能在7000元的价位和iPhone华为抢销量，但也有不足，就是缺少了华为苹果独有的东西。华为有麒麟芯片，2020年9月14号前生产的9000系列做到了安卓端至今最强，5G技术领先全球，标志着中国大陆芯片设计的最好水平，可见华为人熬掉了多少头发。被美国制裁，是整个中国的不幸。任正非专注研发这一点，值得尊敬。\n小米相比华为的差距，不是一般的大。而现在小米转向造车，赚钱，芯片的事小米暂时不会碰了，和ov一样打算一辈子躺着挣钱，不打算思考一些如何体面的活着的问题。\nPro同样有竞争力，但是被ultra的光芒掩盖了，补足了4000-5000的价位的短板，同样的GN2,同样的IP68，更轻的重量208g，可以说比去年的10pro竞争力大大提高，就看出货了。\nMIX FOLD：最便宜的折叠屏，搭载小米自研的isp，，加上液态镜头。适合手上有闲钱的米粉。首发5w台销量，作为探索者，这个目标达到了。但是和友商mate和galaxy相比有差距，能不能稳定迭代更新，拭目以待吧。\n暂时小米在线上还没有对手，今年的find x3系列和一加9系列不够猛，在纯硬件竞争上比不过Pro,上半年线上市场收割问题不大。但是下半年有复出的荣耀，是有华为级别实力和财力的竞争对手，一旦走上正轨，不容小觑。\n","date":"2021-04-24T20:15:28+08:00","permalink":"https://junling.li/life/%E4%BA%91%E6%B5%8B%E8%AF%84/","section":"life","tags":null,"title":"云测评"},{"categories":null,"contents":"14. 最长公共前缀 编写一个函数来查找字符串数组中的最长公共前缀。\n如果不存在公共前缀，返回空字符串 \u0026quot;\u0026quot;。\n示例 1：\n1 2 输入：strs = [\u0026#34;flower\u0026#34;,\u0026#34;flow\u0026#34;,\u0026#34;flight\u0026#34;] 输出：\u0026#34;fl\u0026#34; 示例 2：\n1 2 3 输入：strs = [\u0026#34;dog\u0026#34;,\u0026#34;racecar\u0026#34;,\u0026#34;car\u0026#34;] 输出：\u0026#34;\u0026#34; 解释：输入不存在公共前缀。 提示：\n0 \u0026lt;= strs.length \u0026lt;= 200 0 \u0026lt;= strs[i].length \u0026lt;= 200 strs[i] 仅由小写英文字母组成 先上我写的垃圾代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 public class Test { public static String longestCommonPrefix(String strs[]) { try {//trycatch是针对输入空字符串的情况，输出空字符串 int len = strs[0].length(); for (String s : strs) {//这是一个foreach循环，算出最小的长度，这样在接下来就只要循环最小的长度了 if (s.length() \u0026lt; len) { len = s.length(); } } int count = -1;//用作计数 for (int i = 0; i \u0026lt; len; i++) { char c0 = strs[0].charAt(i); //这里将第一个字符串作为标准，将后面的字符串与第一个分别比较 for (String s : strs) {//这也是一个foreach循环 if (c0 != s.charAt(i)) {//一旦遇到不相等，就为count赋值，停止所有循环 count = i; break; } if(i+1==len){count=i+1;}//针对情况：“ab”，“a”，循环结束仍然没有为count赋值，那就手动赋值 } if ( count != -1) {//一旦count被赋值了（即不等于-1），立即break break; } }//完成循环，开始输出结果 return strs[0].substring(0, count);//如果count==-1或者0，不用担心，exception会帮我们处理掉哦 }catch (Exception x){return \u0026#34;\u0026#34;;} } public static void main(String[] args) { String strs[] =new String[3]; strs[0]=\u0026#34;floger\u0026#34;; strs[1]= \u0026#34;flog\u0026#34;; strs[2]=\u0026#34;floght\u0026#34;; System.out.println(strs.length); System.out.println(longestCommonPrefix(strs)); } } 暴力求解，逐个循环，相信你一定没心情看我的烂代码。时隔不少天我再编辑时，发现我也看不懂了。\n下面给大家分享一个大神解法\n字典序最大和最小字符串的公共前缀 悠远的苍穹L3发布于 2020-06-1514.1kC++PythonPython3\n解题思路 先找出数组中字典序最小和最大的字符串，最长公共前缀即为这两个字符串的公共前缀 代码 下面是 C++17 的代码\n1 2 3 4 5 6 7 8 9 10 11 12 class Solution { public: string longestCommonPrefix(vector\u0026lt;string\u0026gt;\u0026amp; strs) { if(strs.empty()) return \u0026#34;\u0026#34;; // c++17 结构化绑定 // str0, str1 分别是一个 pair\u0026lt;string, string\u0026gt; 的 first 和 second const auto [str0, str1] = minmax_element(strs.begin(), strs.end()); for(int i = 0; i \u0026lt; str0-\u0026gt;size(); ++i) if(str0-\u0026gt;at(i) != str1-\u0026gt;at(i)) return str0-\u0026gt;substr(0, i); return *str0; } }; 等同的 C++11 代码如下\n1 2 3 4 5 6 7 8 9 10 class Solution { public: string longestCommonPrefix(vector\u0026lt;string\u0026gt;\u0026amp; strs) { if(strs.empty()) return \u0026#34;\u0026#34;; const auto p = minmax_element(strs.begin(), strs.end()); for(int i = 0; i \u0026lt; p.first-\u0026gt;size(); ++i) if(p.first-\u0026gt;at(i) != p.second-\u0026gt;at(i)) return p.first-\u0026gt;substr(0, i); return *p.first; } }; Python 代码\n1 2 3 4 5 6 7 8 9 class Solution: def longestCommonPrefix(self, strs: List[str]) -\u0026gt; str: if not strs: return \u0026#34;\u0026#34; str0 = min(strs) str1 = max(strs) for i in range(len(str0)): if str0[i] != str1[i]: return str0[:i] return str0 这里关键在于minmax_elements的使用\n该函数是返回指定范围内的最大最小值的元素的迭代器组成的一个pair, 如果最值多于一个， first返回的是第一个出现的最小值的迭代器，second返回的是最后一个出现的最大值的迭代器 。\n下面是一个例子：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 void minmaxelement(){ vector\u0026lt;int\u0026gt; vi{3,5,4,1,3,1,9,9,5}; cout\u0026lt;\u0026lt;\u0026#34;vi=\u0026#34;; for(int i:vi) cout\u0026lt;\u0026lt;i\u0026lt;\u0026lt;\u0026#34; \u0026#34;; cout\u0026lt;\u0026lt;endl; auto it=minmax_element(vi.begin(),vi.end()); cout\u0026lt;\u0026lt;\u0026#34; auto it=minmax_element(vi.begin(),vi.end())\u0026#34;\u0026lt;\u0026lt;endl; cout\u0026lt;\u0026lt;\u0026#34;*it.first=\u0026#34;\u0026lt;\u0026lt;*it.first\u0026lt;\u0026lt;\u0026#34; ,*it.second=\u0026#34;\u0026lt;\u0026lt;*it.second\u0026lt;\u0026lt;endl; cout\u0026lt;\u0026lt;\u0026#34;*(it.first-1)=\u0026#34;\u0026lt;\u0026lt;*(it.first-1)\u0026lt;\u0026lt;\u0026#34; ,*(it.second-1)=\u0026#34;\u0026lt;\u0026lt;*(it.second-1)\u0026lt;\u0026lt;endl; } // auto it=minmax_element(vi.begin(),vi.end()) //it.first=1 it.second=9 //*(it.first-1)=4 *(it.second-1)=9 注意 string 比较采用的是 ”字典序“，a,bc,aac按照字典序比较就是：a,aac,bc.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 template\u0026lt;class ForwardIt, class Compare\u0026gt; std::pair\u0026lt;ForwardIt, ForwardIt\u0026gt; minmax_element(ForwardIt first, ForwardIt last, Compare comp) { auto min = first, max = first; if (first == last || ++first == last) return {min, max}; if (comp(*first, *min)) { min = first; } else { max = first; } while (++first != last) { auto i = first; if (++first == last) { if (comp(*i, *min)) min = i; else if (!(comp(*i, *max))) max = i; break; } else { if (comp(*first, *i)) { if (comp(*first, *min)) min = first; if (!(comp(*i, *max))) max = i; } else { if (comp(*i, *min)) min = i; if (!(comp(*first, *max))) max = first; } } } return {min, max}; } https://en.cppreference.com/w/cpp/algorithm/minmax_element\n这是最初c语言第一节课的知识，strcmp的比较方法\ncomparison function object (i.e. an object that satisfies the requirements of Compare) which returns true if if *a is less than *b. The signature of the comparison function should be equivalent to the following:\nbool cmp(const Type1 \u0026amp;a, const Type2 \u0026amp;b);\nWhile the signature does not need to have const \u0026amp;, the function must not modify the objects passed to it and must be able to accept all values of type (possibly const) Type1 and Type2 regardless of value category (thus, Type1 \u0026amp; is not allowed, nor is Type1 unless for Type1 a move is equivalent to a copy (since C++11)). The types Type1 and Type2 must be such that an object of type ForwardIt can be dereferenced and then implicitly converted to both of them.\nhttps://en.cppreference.com/w/cpp/algorithm/minmax_element\n","date":"2021-04-20T16:32:05+08:00","permalink":"https://junling.li/leetcode/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80/","section":"LeetCode","tags":null,"title":"最长公共前缀"},{"categories":null,"contents":"secTest 希望这里是不太正经的自我介绍\n","date":"2021-04-20T16:00:12+08:00","permalink":"https://junling.li/posts/sec/","section":"posts","tags":null,"title":"Sec"},{"categories":null,"contents":"今天在B站看到一个up讲浏览器的前世今生，我平时不会轻易评价一个技术视频讲得好不好，深入了就没有受众，浅显易懂才符合大众的口味。但是这个视频和Life of a Pixel相比，属于是一个班门弄斧了。所以我还是想要吹一下Life of a Pixel。 The system is very complicated,and the design doc is tended to assume that you already knew a lot of stuffs\n让我们跟着Steve Kobes，了解web内容是怎么渲染成像素的吧。\n我们要渲染什么 当然是网页啦 包括html,css,js，还有一些图片视频什么的，就这么多啦。\n当然考虑到受众，还是解释一下这些东西是什么。\nhtml是一种标记语言，比如\n1 \u0026lt;p\u0026gt;hello world\u0026lt;/p\u0026gt; 这就是一段最简单的代码啦，带尖括号的p标识了hello world是一个段落\ncss是控制样式的\n以上内容适用于Chrome 版本 69.0.3445 ","date":"0001-01-01T00:00:00Z","permalink":"https://junling.li/posts/life-of-a-pixel/","section":"posts","tags":null,"title":"Life of a Pixel"},{"categories":null,"contents":"使用古老的Java Swing框架\n实现功能：\n文件类型支持(Java文件接口，支持软链接，硬链接) 我们使用File类来与操作系统交互。对软链接特殊处理\n元数据支持（属主、时间权限） 这里的实现同样是使用File类。我们将文件的创建时间、最后修改时间、属主等元数据打包至新文件结构字段中，解包时先创建新文件完成所有解包解密操作，最后修改创建时间，保证last modified time与源文件一致。\n自定义备份 文件名过滤，指定备份文件位置。\n压缩解压 我们将打包后的文件看作字节流，对字节出现频率构建Huffman树对文件进行压缩，\n打包解包 ：将目录下文件按照规则写入同一个文件。 加密解密：使用自定义的映射函数实现\n实时备份：Java WatchService监听目录变化。 图形界面：Java Swing\n网络备份：将备份后的本地文件一键上传至网盘 ，借助Alist开源项目实现存放到商业网盘如百度网盘、阿里网盘。\n构建了跨系统运行的jar包。\n提供了dockerfile构建脚本，在docker hub提供了测试镜像，并借助x11vnc项目实现docker的GUI展示。 可以使用docker pull bachwv/docker-desktop:zh_CN命令下载镜像。\n项目目录 https://github.com/BachWV/backup\n功能 整体功能为备份指定文件夹并还原。\n备份过程分为以下几步：\n打包（sourceDir -\u0026gt; sourceDir.pack ）：将指定文件夹下的文件（普通文件、目录和软链接）打包，可以通过创建 .bakignore 文件指定需要过滤的文件。打包目录中如果多个硬链接指向同一份数据，那么该数据只会打包一次，并且还原时也只还原一份，并建立多个指向它的硬链接。 压缩（sourceDir.pack -\u0026gt; sourceDir.pack.huff）：使用 Huffman 压缩算法进行压缩。 加密（sourceDir.pack.huff -\u0026gt; sourceDir.pack.huff.enc ）：使用一个简单的带混淆机制的加密算法进行加密。 还原过程就是上面过程反过来。\n上传至网盘，当然是公共目录。http://120.24.176.162:5244/aliyun/pantest\n编译运行 本项目使用 Maven 构建。 编译：\n1 mvn compile 运行:\n1 java -jar backup_lab.jar docker 运行环境 本项目使用的运行环境 已上传至docker hub\n1 docker pull bachwv/docker-desktop:zh_CN 构建参考 https://github.com/BachWV/x11vnc-desktop/ 的zh_CN分支，并使用Github Action打包，直接使用dockerfile打包可能出现问题\n使用python init_desktop.py运行docker（挂载当前目录至docker中的~/shared目录，在docker中使用java -jar backup_lab.jar运行本软件 ）\n","date":"0001-01-01T00:00:00Z","permalink":"https://junling.li/posts/backup-lab/","section":"posts","tags":null,"title":"一个不知名的备份打包程序"},{"categories":null,"contents":"","date":"0001-01-01T00:00:00Z","permalink":"https://junling.li/essay/","section":"","tags":null,"title":"我的BB"},{"categories":null,"contents":"","date":"0001-01-01T00:00:00Z","permalink":"https://junling.li/movies/","section":"","tags":null,"title":"我的观影"},{"categories":null,"contents":"第四讲 Python 实现操作系统模型 可以说从这一讲开始，才真正迈入操作系统的殿堂 https://jyywiki.cn/OS/2023/build/lect4.ipynb 一个由 sys_write(),sys_spawn(),sys_sched(),sys_choose() 四个系统调用 组成的简单操作系统\njyy在2023年使用python重写了这个threads.h，几乎在50行里实现了一个解释器 因为我太菜了，所以这段代码看了我一下午才理解\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 #os-model.py import sys import random from pathlib import Path class OperatingSystem(): \u0026#34;\u0026#34;\u0026#34;A minimal executable operating system model.\u0026#34;\u0026#34;\u0026#34; SYSCALLS = [\u0026#39;choose\u0026#39;, \u0026#39;write\u0026#39;, \u0026#39;spawn\u0026#39;, \u0026#39;sched\u0026#39;] class Thread: \u0026#34;\u0026#34;\u0026#34;A \u0026#34;freezed\u0026#34; thread state.\u0026#34;\u0026#34;\u0026#34; def __init__(self, func, *args): self._func = func(*args) self.retval = None def step(self): \u0026#34;\u0026#34;\u0026#34;Proceed with the thread until its next trap.\u0026#34;\u0026#34;\u0026#34; syscall, args, *_ = self._func.send(self.retval)# 第一次调用send 到达第一个yield，获得返回值 \u0026#34;choose\u0026#34;,并将syscall： choose返回，交给match比较 # 注意，这里同时传递了args参数，可以解答下面的xs的疑问 self.retval = None return syscall, args def __init__(self, src): variables = {} exec(src, variables) self._main = variables[\u0026#39;main\u0026#39;] def run(self): threads = [OperatingSystem.Thread(self._main)] print(threads[0]) while threads: # Any thread lives try: match (t := threads[0]).step(): case \u0026#39;choose\u0026#39;, xs: # Return a random choice t.retval = random.choice(xs) case \u0026#39;write\u0026#39;, xs: # Write to debug console print(xs, end=\u0026#39;\u0026#39;) case \u0026#39;spawn\u0026#39;, (fn, args): # Spawn a new threadL::: threads += [OperatingSystem.Thread(fn, *args)] case \u0026#39;sched\u0026#39;, _: # Non-deterministic schedule random.shuffle(threads) except StopIteration: # A thread terminates threads.remove(t) random.shuffle(threads) # sys_sched() if __name__ == \u0026#39;__main__\u0026#39;: if len(sys.argv) \u0026lt; 2: print(f\u0026#39;Usage: {sys.argv[0]} file\u0026#39;) exit(1) src = Path(sys.argv[1]).read_text() for syscall in OperatingSystem.SYSCALLS: src = src.replace(f\u0026#39;sys_{syscall}\u0026#39;, # sys_write(...) f\u0026#39;yield \u0026#34;{syscall}\u0026#34;, \u0026#39;) # -\u0026gt; yield \u0026#39;write\u0026#39;, (...) OperatingSystem(src).run() 前置知识yield Generator Object\n1 2 3 4 5 6 7 8 def numbers(): i = 0 while True: ret = yield f\u0026#39;{i:b}\u0026#39; i += ret n=numbers() n.send(None) s.send(0) 在调用生成器函数的过程中，每次遇到 yield 时函数会暂停并保存当前所有的运行信息（保留局部变量），返回yield的值, 并在下一次执行next()方法时从当前位置继续运行，直到生成器被全部遍历完。\nhttps://www.liaoxuefeng.com/article/895920356978720\nsend()的意思是，传入给ret值，让迭代器能接受外部的值，从而改变状态机的状态\n1 2 3 4 5 6 7 def fab(max): n, a, b = 0, 0, 1 while n \u0026lt; max: yield b print(\u0026#34;fab:\u0026#34;+n+\u0026#34;val:\u0026#34;+a) a, b = b, a + b n = n + 1 如果你大致明白了 yield 是做什么的，再来看一下os-model.py究竟做了什么。\n基础的玩具 读入thread.py的内容，这里有一个巧妙的地方，把threads.py替换成下面代码，通过exec运行\n1 2 3 4 5 6 7 8 9 10 11 12 13 count = 0 def Tprint(name): global count for i in range(3): count += 1 yield \u0026#34;write\u0026#34;, (f\u0026#39;#{count:02} Hello from {name}{i+1}\\n\u0026#39;) yield \u0026#34;sched\u0026#34;, () def main(): n = yield \u0026#34;choose\u0026#34;, ([3, 4, 5]) yield \u0026#34;write\u0026#34;, (f\u0026#39;#Thread = {n}\\n\u0026#39;) for name in \u0026#39;ABCDE\u0026#39;[:n]: yield \u0026#34;spawn\u0026#34;, (Tprint, name) yield \u0026#34;sched\u0026#34;, () 创建迭代器，然后选择迭代器执行下一步，就相当于选择状态机执行。在外部针对syscall做了传递\n这个模型还可以更加简化，比如现在有3个迭代器，斐波那契迭代器，倍增迭代器，和倒数迭代器，每次通过random选择迭代器执行一步，然后转交控制权，等待调度执行。感谢python，让写代码变得这么容易。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 import random def fab(max): n, a, b = 0, 0, 1 while n \u0026lt; max: yield b print(f\u0026#34;fab:{n} val:{b}\u0026#34;) a, b = b, a + b n = n + 1 def declin(max): n, a= 0, 0 while n \u0026lt; max: yield a print(f\u0026#34;dec:{n} val:{a}\u0026#34;) a = a - 1 n = n + 1 def doubl(max): n, a= 0, 1 while n \u0026lt; max: yield a print(f\u0026#34;dou:{n} val:{a}\u0026#34;) a *= 2 n = n + 1 threads = [fab(10),doubl(10),declin(10)] while threads: try: random.shuffle(threads) next(threads[0]) except StopIteration: # A thread terminates threads.remove(threads[0]) random.shuffle(threads) 当你熟悉了python构建的状态机，来试试c吧\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;pthread.h\u0026gt; static pthread_t threads[64]; static int nthreads = 0; static inline void sys_write(const char *s) { printf(\u0026#34;%s\u0026#34;, s); fflush(stdout); } static inline void sys_sched() { usleep(rand() % 10000); } static inline void sys_spawn(void *(*fn)(void *), void *args) { pthread_create(\u0026amp;threads[nthreads++], NULL, fn, args); } static inline int sys_choose(int x) { return rand() % x; } // Constructor called before main() static inline void __attribute__((constructor)) srand_init() { srand(time(0)); } // Destructor called after main() static inline void __attribute__((destructor)) thread_join() { for (int i = 0; i \u0026lt; nthreads; i++) { pthread_join(threads[i], NULL); // Wait for thread terminations } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include \u0026#34;os-real.h\u0026#34; int count = 0; void *Tprint(void *s) { char buf[64]; for (int i = 0; i \u0026lt; 3; i++) { sprintf(buf, \u0026#34;#%02d Hello from %c%d\\n\u0026#34;, ++count, *(const char *)s, i); sys_write(buf); sys_sched(); } return NULL; } int main() { int n = sys_choose(3) + 3; char buf[64]; sprintf(buf, \u0026#34;#Thread = %d\\n\u0026#34;, n); sys_write(buf); for (int i = 0; i \u0026lt; n; i++) { sys_spawn(Tprint, \u0026amp;\u0026#34;ABCDE\u0026#34;[i]); } } 将上面的调度改写成c的\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 void *fab(int max){ int n=0, a=0, b=1; char buf[64]; while(n \u0026lt; max){ sys_sched(); sprintf(buf,\u0026#34;fab: %d val:%d\\n\u0026#34;,n,b); sys_write(buf); int tmp=a; a=b; b=tmp + b; n++; } return NULL; } void *declin(int max){ int n=0,a=0; char buf[64]; while (n\u0026lt;max){ sys_sched(); sprintf(buf,\u0026#34;dec: %d val:%d\\n\u0026#34;,n,a); sys_write(buf); a--; n++; } return NULL; } void *doubl(int max){ int n=0,a=1; char buf[64]; while (n\u0026lt;max){ sys_sched(); sprintf(buf,\u0026#34;dou: %d val:%d\\n\u0026#34;,n,a); sys_write(buf); a*=2; n++; } return NULL; } int main() { sys_spawn(doubl,10); sys_spawn(fab,10); sys_spawn(declin,10); } 更完善的玩具 所以这节课学了什么呢？一个简化的操作系统模型，如果你对一个简化的系统了解非常深刻，再去学习实际的操作系统，去比较其中的差异，就不会那么困难了。\n","date":"0001-01-01T00:00:00Z","permalink":"https://junling.li/posts/os-jyy-4/","section":"posts","tags":null,"title":"操作系统-jyy-4 Python 实现操作系统模型"},{"categories":null,"contents":"进程间是否共享内存？\n是，怎么证明？ 栈空间有多大？\n大概8192KB 来看一个例子，基于线程库的编程\n谁主导了这一切？\n线程库 多线程比单线程多了什么？\n放弃原子性 放弃执行顺序 放弃多处理器间内存访问的即时可见性 山寨支付宝多线程支付 对共享内存的修改，导致两次读到不同的x\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include \u0026lt;pthread.h\u0026gt; int pthread_join(pthread_t thread, void **retval); Compile and link with -pthread. The pthread_join() function waits for the thread specified by thread to terminate. If that thread has already terminated, then pthread_join() returns immediately. The thread specified by thread must be joinable. If retval is not NULL, then pthread_join() copies the exit status of the target thread (i.e., the value that the target thread supplied to pthread_exit(3)) into the location pointed to by retval. If the target thread was canceled, then PTHREAD_CANCELED is placed in the location pointed to by retval. If multiple threads simultaneously try to join with the same thread, the results are undefined. If the thread calling pthread_join() is canceled, then the target thread will remain joinable (i.e., it will not be detached). pthread_join()函数可以阻塞当前线程，直到指定的线程完成执行为止。它的作用是等待一个线程结束并回收它的资源，同时将线程的返回值传递给调用线程。\n不正常的sum 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include \u0026#34;thread.h\u0026#34; #define N 100000000 long sum = 0; void Tsum() { for (int i = 0; i \u0026lt; N; i++) { //sum++; asm volatile( \u0026#34;incq %0\u0026#34; : \u0026#34;+m\u0026#34;(sum) ); } } int main() { create(Tsum); create(Tsum); join(); printf(\u0026#34;sum = %ld\\n\u0026#34;, sum); } 你可能得不到200000000这个答案，为什么？\n哦，这该死的编译器\n其他意想不到的问题： 处理器指令重排 1 2 3 4 5 6 7 8 9 10 11 12 int x = 0, y = 0; void T1() { x = 1; // Store(x) printf(\u0026#34;%d\u0026#34;, y); // Load(y) } void T2() { y = 1; // Store(y) printf(\u0026#34;%d\u0026#34;, x); // Load(x) } 理论上不会出现0 0\n实际上最多出现的就是0 0\n1 2 3 4 5 $ ./a.out | head -n 1000000 |sort |uniq -c 902562 0 0 92944 0 1 4461 1 0 33 1 1 当你排除了一切不可能，不是代码，编译器的问题，只有在执行指令的时候除了问题\nstore(x) 和load(x)没有数据依赖，被重新排列了\n卧槽，这cpu，跟我玩阴的。\n当 x≠=y 时，对 x,y 的内存读写可以交换顺序\n它们甚至可以在同一个周期里完成 (只要 load/store unit 支持) 如果写 x 发生 cache miss，可以让读 y 先执行满足 “尽可能执行 μop” 的原则，最大化处理器性能.\nx86的内存模型是宽松内存模型 是你能理解的正常的内存模型\nARM/RISC-V的内存模型就很奇葩\n体系结构的不同导致跨指令集翻译变得困难，Rosstta \u0026amp;\u0026amp; Latx如何实现？谁也不知道\n多线程那么困难，为什么还要怎么做？ Proformance! 榨干性能\n所以，当我们写并发程序时，请不要相信直觉、编译器、处理器，请加锁。\n然而，人类本质上是物理世界 (宏观时间) 中的 “sequential creature”，因此我们在编程时，也 “只能” 习惯单线程的顺序/选择/循环结构，真实多处理器上的并发编程是非常具有挑战性的 “底层技术”，例如 Ad hoc synchronization 引发了很多系统软件中的 bugs。因此，我们需要并发控制技术 (之后的课程涉及)，使得程序能在不共享内存的时候并行执行，并且在需要共享内存时的行为能够 “容易理解”。\n","date":"0001-01-01T00:00:00Z","permalink":"https://junling.li/posts/os-jyy-5/","section":"posts","tags":null,"title":"操作系统-jyy-5 多处理器编程"},{"categories":null,"contents":"第8讲 调试理论与实践 本节课回答的问题：如何应对bug\n调试理论 软件的两层含义\n人类需求在信息世界的投影 计算过程的精确（数学）描述 调试困难的根本原因 因为bug的触发经历了漫长的过程。这个过程中，软件的状态发生了很多变化，而我们只能看到最后的结果。无法预知bug在哪里\n单步调试，判断每一次状态，二分查找error的状态\n调试DP题/图论算法如何判断状态呢？人脑不够用了 工具\nprintf 打印log，快速定位 gdb 精确定位，查看所有状态 看起来今天的主要内容是很工程的，讲了许多例子，都不是很懂，写完lab1再回来看吧 一切皆可调试 ssh -vvv 打印日志 gcc -v make -n\n这里推荐了musl libc\n永远假设自己不是圣人，不能一次写出对的代码\n防御性编程 加断言\n例子：\n平衡树的左旋\n加assert()判断结点旋转的结果对不对\n检查是否在堆区\nassert(IN_RAGE(heap))\nassert(0\u0026lt;=pid\u0026amp;\u0026amp;pid\u0026lt;=1000)\n并发bug死锁\nAA-Deadlock 假设你的 spinlock 不小心发生了中断\n在不该打开中断的时候开了中断 在不该切换的时候执行了 yield() 1 2 3 4 5 6 7 8 9 10 void os_run() { spin_lock(\u0026amp;list_lock); spin_lock(\u0026amp;xxx); spin_unlock(\u0026amp;xxx); // ---------+ } // | // | void on_interrupt() { // | spin_lock(\u0026amp;list_lock); // \u0026lt;--+ spin_unlock(\u0026amp;list_lock); } ABBA-Deadlock 1 2 3 4 5 6 7 8 void swap(int i, int j) { spin_lock(\u0026amp;lock[i]); spin_lock(\u0026amp;lock[j]); arr[i] = NULL; arr[j] = arr[i]; spin_unlock(\u0026amp;lock[j]); spin_unlock(\u0026amp;lock[i]); } 上锁的顺序很重要……\n1 swap 本身看起来没有问题\nswap(1, 2); swap(2, 3), swap(3, 1) → 死锁 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 endwsl@LAPTOP-U1E6STIA:~/jyy/8$ gcc -lpthread philosopher.c endwsl@LAPTOP-U1E6STIA:~/jyy/8$ ./a.out T1 Got 1 T1 Got 2 T1 Got 1 T1 Got 2 T1 Got 1 T1 Got 2 T1 Got 1 T1 Got 2 T1 Got 1 T1 Got 2 T1 Got 1 T2 Got 2 T3 Got 3 避免死锁 死锁产生的四个必要条件 (Edward G. Coffman, 1971):\n互斥：一个资源每次只能被一个进程使用 请求与保持：一个进程请求资阻塞时，不释放已获得的资源 不剥夺：进程已获得的资源不能强行剥夺 循环等待：若干进程之间形成头尾相接的循环等待资源关系 “理解了死锁的原因，尤其是产生死锁的四个必要条件，就可以最大可能地避免、预防和解除死锁。所以，在系统设计、进程调度等方面注意如何不让这四个必要条件成立，如何确定资源的合理分配算法，避免进程永久占据系统资源。此外，也要防止进程在处于等待状态的情况下占用资源。因此，对资源的分配要给予合理的规划。” ——Bullshit.\n按照规定的顺序获得锁\n数据竞争 不同的线程同时访问同一段内存，且至少有一个是写。\n两个内存访问在 “赛跑”，“跑赢” 的操作先执行\npeterson-barrier.c 内存访问都在赛跑\nMFENCE：如何留下最少的 fence，依然保证算法正确？ 数据竞争 (cont\u0026rsquo;d) Peterson 算法告诉大家：\n你们写不对无锁的并发程序 所以事情反而简单了 用互斥锁保护好共享数据 消灭一切数据竞争 数据竞争：例子 以下代码概括了你们遇到数据竞争的大部分情况\n不要笑，你们的 bug 几乎都是这两种情况的变种 1 2 3 // Case #1: 上错了锁 void thread1() { spin_lock(\u0026amp;lk1); sum++; spin_unlock(\u0026amp;lk1); } void thread2() { spin_lock(\u0026amp;lk2); sum++; spin_unlock(\u0026amp;lk2); } 1 2 3 // Case #2: 忘记上锁 void thread1() { spin_lock(\u0026amp;lk1); sum++; spin_unlock(\u0026amp;lk1); } void thread2() { sum++; } class: center, middle\n更多类型的并发 Bug 程序员：花式犯错 回顾我们实现并发控制的工具\n互斥锁 (lock/unlock) - 原子性 条件变量 (wait/signal) - 同步 忘记上锁——原子性违反 (Atomicity Violation, AV)\n忘记同步——顺序违反 (Order Violation, OV)\nEmpirical study: 在 105 个并发 bug 中 (non-deadlock/deadlock)\nMySQL (14/9), Apache (13/4), Mozilla (41/16), OpenOffice (6/2) 97% 的非死锁并发 bug 都是 AV 或 OV。 原子性违反 (AV) “ABA”\n我以为一段代码没啥事呢，但被人强势插入了 原子性违反 (cont\u0026rsquo;d) 有时候上锁也不解决问题\n“TOCTTOU” - time of check to time of use TOCTTOU vulnerabilities in UNIX-style file systems: An anatomical study (FAST'05) 顺序违反 (OV) “BA”\n怎么就没按我预想的顺序来呢？ 例子：concurrent use after free class: center, middle\n应对并发 Bug 的方法 完全一样的基本思路：否定你自己 还是得始终假设自己的代码是错的。\n然后呢？\n做好测试 检查哪里错了 再检查哪里错了 再再检查哪里错了 (把任何你认为 “不对” 的情况都检查一遍) 例如：用 lock ordering 彻底避免死锁？\n你想多了：并发那么复杂，程序员哪能充分测试啊 Lockdep: 运行时的死锁检查 Lockdep 规约 (Specification)\n为每一个锁确定唯一的 “allocation site” lock-site.c assert: 同一个 allocation site 的锁存在全局唯一的上锁顺序 检查方法：printf\n记录所有观察到的上锁顺序，例如[x,y,z]⇒x→y,x→z,y→z 检查是否存在 x⇝y∧y⇝x Lockdep 的实现\nSince Linux Kernel 2.6.17, also in OpenHarmony! ThreadSanitizer: 运行时的数据竞争检查 为所有事件建立 happens-before 关系图\nProgram-order + release-acquire\n对于发生在不同线程且至少有一个是写的\nx,y\n检查\nx≺y∨y≺x\nTime, clocks, and the ordering of events in a distributed system 更多的检查：动态程序分析 在事件发生时记录\nLockdep: lock/unlock ThreadSanitizer: 内存访问 + lock/unlock 解析记录检查问题\nLockdep: x⇝y∧y⇝x ThreadSanitizer: x⊀y∧y⊀x 付出的代价和权衡\n程序执行变慢 但更容易找到 bug (因此在测试环境中常用) 动态分析工具：Sanitizers 没用过 lint/sanitizers？\nAddressSanitizer\n(asan);\n(paper) 非法内存访问\nBuffer (heap/stack/global) overflow, use-after-free, use-after-return, double-free, \u0026hellip; Demo: uaf.c; kasan ThreadSanitizer\n(tsan): 数据竞争\nDemo: fish.c, sum.c, peterson-barrier.c; ktsan MemorySanitizer (msan): 未初始化的读取\nUBSanitizer\n(ubsan): undefined behavior\nMisaligned pointer, signed integer overflow, \u0026hellip; Kernel 会带着 -fwrapv 编译 class: center, middle\n这不就是防御性编程吗？ 只不过不需要我亲自动手把代码改得乱七八糟了……\n我们也可以！Buffer Overrun 检查 Canary (金丝雀) 对一氧化碳非常敏感\n用生命预警矿井下的瓦斯泄露 (since 1911) 计算机系统中的 canary\n“牺牲” 一些内存单元，来预警 memory error 的发生 (程序运行时没有动物受到实质的伤害) Canary 的例子：保护栈空间 (M2/L2) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #define MAGIC 0x55555555 #define BOTTOM (STK_SZ / sizeof(u32) - 1) struct stack { char data[STK_SZ]; }; void canary_init(struct stack *s) { u32 *ptr = (u32 *)s; for (int i = 0; i \u0026lt; CANARY_SZ; i++) ptr[BOTTOM - i] = ptr[i] = MAGIC; } void canary_check(struct stack *s) { u32 *ptr = (u32 *)s; for (int i = 0; i \u0026lt; CANARY_SZ; i++) { panic_on(ptr[BOTTOM - i] != MAGIC, \u0026#34;underflow\u0026#34;); panic_on(ptr[i] != MAGIC, \u0026#34;overflow\u0026#34;); } } 烫烫烫、屯屯屯和葺葺葺 msvc 中 debug mode 的 guard/fence/canary\n未初始化栈: 0xcccccccc 未初始化堆: 0xcdcdcdcd 对象头尾: 0xfdfdfdfd 已回收内存: 0xdddddddd 1 (b\u0026#39;\\xcc\u0026#39; * 80).decode(\u0026#39;gb2312\u0026#39;) 手持两把锟斤拷，口中疾呼烫烫烫\n脚踏千朵屯屯屯，笑看万物锘锘锘\n(它们一直在无形中保护你)\n防御性编程：低配版 Lockdep 不必大费周章记录什么上锁顺序\n统计当前的 spin count 如果超过某个明显不正常的数值 (1,000,000,000) 就报告 1 2 3 4 5 6 int spin_cnt = 0; while (xchg(\u0026amp;locked, 1)) { if (spin_cnt++ \u0026gt; SPIN_LIMIT) { printf(\u0026#34;Too many spin @ %s:%d\\n\u0026#34;, __FILE__, __LINE__); } } 配合调试器和线程 backtrace 一秒诊断死锁 防御性编程：低配版 Sanitizer (L1) 内存分配要求：已分配内存 S=[ℓ0,r0)∪[ℓ1,r1)∪…\nkalloc(\ns\n) 返回的\n[ℓ,r)\n必须满足\n[ℓ,r)∩S=∅\nthread-local allocation + 并发的 free 还蛮容易弄错的 1 2 3 4 5 6 7 8 9 10 11 // allocation for (int i = 0; (i + 1) * sizeof(u32) \u0026lt;= size; i++) { panic_on(((u32 *)ptr)[i] == MAGIC, \u0026#34;double-allocation\u0026#34;); arr[i] = MAGIC; } // free for (int i = 0; (i + 1) * sizeof(u32) \u0026lt;= alloc_size(ptr); i++) { panic_on(((u32 *)ptr)[i] == 0, \u0026#34;double-free\u0026#34;); arr[i] = 0; } class: center, middle\n总结 总结 本次课回答的问题\nQ: 如何拯救人类不擅长的并发编程？ Take-away message\n常见的并发 bug 死锁、数据竞争、原子性/顺序违反 不要盲目相信自己：检查、检查、检查 防御性编程：检查 动态分析：打印 + 检查 class: center, middle\nEnd. ","date":"0001-01-01T00:00:00Z","permalink":"https://junling.li/posts/os-jyy-8/","section":"posts","tags":null,"title":"操作系统-jyy-8 调试理论与实践"}]