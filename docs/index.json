[{"categories":null,"contents":"14. 最长公共前缀 编写一个函数来查找字符串数组中的最长公共前缀。\n如果不存在公共前缀，返回空字符串 \u0026quot;\u0026quot;。\n示例 1：\n输入：strs = [\u0026quot;flower\u0026quot;,\u0026quot;flow\u0026quot;,\u0026quot;flight\u0026quot;] 输出：\u0026quot;fl\u0026quot; 示例 2：\n输入：strs = [\u0026quot;dog\u0026quot;,\u0026quot;racecar\u0026quot;,\u0026quot;car\u0026quot;] 输出：\u0026quot;\u0026quot; 解释：输入不存在公共前缀。 提示：\n 0 \u0026lt;= strs.length \u0026lt;= 200 0 \u0026lt;= strs[i].length \u0026lt;= 200 strs[i] 仅由小写英文字母组成  先上我写的垃圾代码：\npublic class Test { public static String longestCommonPrefix(String strs[]) { try {//trycatch是针对输入空字符串的情况，输出空字符串  int len = strs[0].length(); for (String s : strs) {//这是一个foreach循环，算出最小的长度，这样在接下来就只要循环最小的长度了  if (s.length() \u0026lt; len) { len = s.length(); } } int count = -1;//用作计数  for (int i = 0; i \u0026lt; len; i++) { char c0 = strs[0].charAt(i); //这里将第一个字符串作为标准，将后面的字符串与第一个分别比较  for (String s : strs) {//这也是一个foreach循环  if (c0 != s.charAt(i)) {//一旦遇到不相等，就为count赋值，停止所有循环  count = i; break; } if(i+1==len){count=i+1;}//针对情况：“ab”，“a”，循环结束仍然没有为count赋值，那就手动赋值  } if ( count != -1) {//一旦count被赋值了（即不等于-1），立即break  break; } }//完成循环，开始输出结果  return strs[0].substring(0, count);//如果count==-1或者0，不用担心，exception会帮我们处理掉哦  }catch (Exception x){return \u0026#34;\u0026#34;;} } public static void main(String[] args) { String strs[] =new String[3]; strs[0]=\u0026#34;floger\u0026#34;; strs[1]= \u0026#34;flog\u0026#34;; strs[2]=\u0026#34;floght\u0026#34;; System.out.println(strs.length); System.out.println(longestCommonPrefix(strs)); } } 暴力求解，逐个循环，相信你一定没心情看我的烂代码。时隔不少天我再编辑时，发现我也看不懂了。\n下面给大家分享一个大神解法\n字典序最大和最小字符串的公共前缀 悠远的苍穹L3发布于 2020-06-1514.1kC++PythonPython3\n解题思路 先找出数组中字典序最小和最大的字符串，最长公共前缀即为这两个字符串的公共前缀 代码 下面是 C++17 的代码\nclass Solution { public: string longestCommonPrefix(vector\u0026lt;string\u0026gt;\u0026amp; strs) { if(strs.empty()) return \u0026quot;\u0026quot;; // c++17 结构化绑定 // str0, str1 分别是一个 pair\u0026lt;string, string\u0026gt; 的 first 和 second const auto [str0, str1] = minmax_element(strs.begin(), strs.end()); for(int i = 0; i \u0026lt; str0-\u0026gt;size(); ++i) if(str0-\u0026gt;at(i) != str1-\u0026gt;at(i)) return str0-\u0026gt;substr(0, i); return *str0; } }; 等同的 C++11 代码如下\nclass Solution { public: string longestCommonPrefix(vector\u0026lt;string\u0026gt;\u0026amp; strs) { if(strs.empty()) return \u0026quot;\u0026quot;; const auto p = minmax_element(strs.begin(), strs.end()); for(int i = 0; i \u0026lt; p.first-\u0026gt;size(); ++i) if(p.first-\u0026gt;at(i) != p.second-\u0026gt;at(i)) return p.first-\u0026gt;substr(0, i); return *p.first; } }; Python 代码\nclass Solution: def longestCommonPrefix(self, strs: List[str]) -\u0026gt; str: if not strs: return \u0026quot;\u0026quot; str0 = min(strs) str1 = max(strs) for i in range(len(str0)): if str0[i] != str1[i]: return str0[:i] return str0 这里关键在于minmax_elements的使用\n该函数是返回指定范围内的最大最小值的元素的迭代器组成的一个pair, 如果最值多于一个， first返回的是第一个出现的最小值的迭代器，second返回的是最后一个出现的最大值的迭代器 。\n下面是一个例子：\nvoid minmaxelement(){ vector\u0026lt;int\u0026gt; vi{3,5,4,1,3,1,9,9,5}; cout\u0026lt;\u0026lt;\u0026#34;vi=\u0026#34;; for(int i:vi) cout\u0026lt;\u0026lt;i\u0026lt;\u0026lt;\u0026#34; \u0026#34;; cout\u0026lt;\u0026lt;endl; auto it=minmax_element(vi.begin(),vi.end()); cout\u0026lt;\u0026lt;\u0026#34; auto it=minmax_element(vi.begin(),vi.end())\u0026#34;\u0026lt;\u0026lt;endl; cout\u0026lt;\u0026lt;\u0026#34;*it.first=\u0026#34;\u0026lt;\u0026lt;*it.first\u0026lt;\u0026lt;\u0026#34; ,*it.second=\u0026#34;\u0026lt;\u0026lt;*it.second\u0026lt;\u0026lt;endl; cout\u0026lt;\u0026lt;\u0026#34;*(it.first-1)=\u0026#34;\u0026lt;\u0026lt;*(it.first-1)\u0026lt;\u0026lt;\u0026#34; ,*(it.second-1)=\u0026#34;\u0026lt;\u0026lt;*(it.second-1)\u0026lt;\u0026lt;endl; } // auto it=minmax_element(vi.begin(),vi.end()) //it.first=1 it.second=9 //*(it.first-1)=4 *(it.second-1)=9 注意 string 比较采用的是 ”字典序“，a,bc,aac按照字典序比较就是：a,aac,bc.\ntemplate\u0026lt;class ForwardIt, class Compare\u0026gt; std::pair\u0026lt;ForwardIt, ForwardIt\u0026gt; minmax_element(ForwardIt first, ForwardIt last, Compare comp) { auto min = first, max = first; if (first == last || ++first == last) return {min, max}; if (comp(*first, *min)) { min = first; } else { max = first; } while (++first != last) { auto i = first; if (++first == last) { if (comp(*i, *min)) min = i; else if (!(comp(*i, *max))) max = i; break; } else { if (comp(*first, *i)) { if (comp(*first, *min)) min = first; if (!(comp(*i, *max))) max = i; } else { if (comp(*i, *min)) min = i; if (!(comp(*first, *max))) max = first; } } } return {min, max}; } https://en.cppreference.com/w/cpp/algorithm/minmax_element\n这是最初c语言第一节课的知识，strcmp的比较方法\ncomparison function object (i.e. an object that satisfies the requirements of Compare) which returns true if if *a is less than *b. The signature of the comparison function should be equivalent to the following:\nbool cmp(const Type1 \u0026amp;a, const Type2 \u0026amp;b);\nWhile the signature does not need to have const \u0026amp;, the function must not modify the objects passed to it and must be able to accept all values of type (possibly const) Type1 and Type2 regardless of value category (thus, Type1 \u0026amp; is not allowed, nor is Type1 unless for Type1 a move is equivalent to a copy (since C++11)). The types Type1 and Type2 must be such that an object of type ForwardIt can be dereferenced and then implicitly converted to both of them.\nhttps://en.cppreference.com/w/cpp/algorithm/minmax_element\n","date":"2021-04-20T16:32:05+08:00","permalink":"https://bachwv.github.io/posts/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80/","section":"posts","tags":null,"title":"最长公共前缀"},{"categories":null,"contents":"secTest ","date":"2021-04-20T16:00:12+08:00","permalink":"https://bachwv.github.io/posts/sec/","section":"posts","tags":null,"title":"Sec"}]