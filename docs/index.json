[{"categories":null,"contents":"来源https://sspai.com/post/59904\n利用github + hugo 搭建轻量化的blog ，非常有用的教程！\n1. 安装 Git 和 Go 使用Hugo前需要安装Git 和 Go 语言开发环境，点击对应网址下载安装包即可。\n2. 安装Hugo 网上存在很多用工具安装的方式，我这里讲述一个我认为最简单的方式，不用涉及太多的代码（本方法针对pc）。\n（1）在Hugo的官网中选择想要的版本下载zip，将其中的hugo.exe文件解压到想要的地方，比如 C:\\Hugo\\bin。\n（2）将Hugo添加到Windows的环境变量 PATH中。\n（3）添加完PATH后，打开Git Bash 输入 hugo version 出现hugo static site generator相关信息表示安装完成。\n3. 生成博客 （1）打开Git Bash 输入hugo new site \u0026quot;你的文件名字\u0026quot;，便可以生成一个用于存放博客的文件夹。\n（2）安装主题。\n不同于hexo，hugo没有自带主题，所以建立完文件夹后要导入主题文件。导入主题方式和hexo相似，可以用git clone 的方式，也可以到相应主题的github中下载zip文件然后解压到自己博客的themes文件夹中。\n推荐几个主题：Pure、Even、Coder\n官网主题库：Hugo Themes\n（3）配置文件\nHugo配置文件放置在源文件下，并且支持三种格式：toml，yaml，yml。这个配置文件可以直接从主题文件中的exampleSite 里copy到博客文件夹下，然后进行修改。\n 注意点1：有些主题没有提供相应的配置文件，得进行自己修改，不建议选用这类主题。 注意点2：配置文件中要确保里面的主题名字和你themes文件夹中相应的主题文件夹名字一样，比如我的主题是pure，那么配置文件里的theme = pure，并且themes 文件夹中也有一个pure的文件夹。这是为了保证工具能依据名字找到相应的主题文件。  （4）生成博文\n在 Git Bash 中输入 hugo new posts/xxxx.md，这时候就会在文件夹 content/posts形成你要的markdown文件，打开进行编辑即可。\n（5）渲染查看效果\n在博客文件夹中打开Git Bash，输入 hugo server，然后打开 http://localhost:1313/ 来查看效果。注意，markdown文件中的 front matter 部分有一个draft 参数，如果draft设置为true 则可正常渲染，如果设置为false则不予以渲染。相应的如果想查看全部效果则输入hugo server -D 表示将草稿文件也进行渲染。\n4. 代码托管 这里主要以GitHub 作为代码托管，假定你已经建立了一个xxx.github.io的一个仓库。官方提供了三四种上传方式，本文采用生成docs的方式进行部署，个人认为这种方式比较简单明了。\n（1）修改配置文件。在配置文件config.toml中添加publishDir = docs，其他格式的配置文件类似。\n（2）打开Git Bash，输入hugo，就会发现博客文件中出现了docs文件夹，这是因为hugo将网页的信息都存储在docs里，而不是public中。\n（3）在博客文件夹中，打开Git Bash，依次输入以下代码（注意 git remote add 后跟随自己github的对应地址）：\ngit remote add origin https://github.com/xxxxx/xxxx.github.io.git git add . git commit -m \u0026quot;first commit\u0026quot; git push -u origin master （4）在GitHub对应的仓库设置中，将Github Pages source改成branch/docs 。\n（5）这时候点击网址会发现内容已经成功渲染了，但是跳转连接出现问题，这是因为我们没有在配置文件中的baseURL中更新我们未来发布的网址链接。因此我们将GitHub Pages 对应的网址进行复制然后添加到配置文件的第一个 baseURL中，重新进行第二步和第三步即可。\n","date":"2021-04-27T21:50:40+08:00","permalink":"https://bachwv.github.io/posts/%E6%90%AD%E5%BB%BA%E4%B8%8E%E5%8F%91%E5%B8%83blog/","section":"posts","tags":null,"title":"搭建与发布blog"},{"categories":null,"contents":"  这种链表题一定要画图\n  头插法\n  遍历原链表+每次插入到新表最前面\n206. 反转链表 难度简单\n给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。\n示例 1：\n输入：head = [1,2,3,4,5] 输出：[5,4,3,2,1] 示例 2：\n输入：head = [1,2] 输出：[2,1] 示例 3：\n输入：head = [] 输出：[] 提示：\n 链表中节点的数目范围是 [0, 5000] -5000 \u0026lt;= Node.val \u0026lt;= 5000    package Test; class ListNode { int val; ListNode next; ListNode() {} ListNode(int val) { this.val = val; } ListNode(int val, ListNode next) { this.val = val; this.next = next; } }5t class Test { public static ListNode reverseList(ListNode head){ ListNode first= new ListNode(); ListNode copy; if(head!=null){ first.val=head.val; copy=head.next; }else return head; while (copy!=null){ ListNode temp= new ListNode(); temp.val=copy.val; temp.next=first; copy=copy.next; first=temp;//每次first指针前移，让他始终指向第一个元素  } return first; } public static void main(String[] args) { ListNode a=new ListNode(5); a.next=new ListNode(4); a.next.next=new ListNode(3); ListNode b=reverseList(a); while(b!=null){ System.out.println(b.val); b=b.next; } } } ","date":"2021-04-27T20:27:17+08:00","permalink":"https://bachwv.github.io/posts/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/","section":"posts","tags":null,"title":"反转链表"},{"categories":null,"contents":"评价手机免不了打打嘴炮，写写垃圾，以下为云评测，如有不对的地方敬请指教。\n1.K40系列\nK40系列只有标准版是比较出众的，可以说把性价比做到了极致，卢伟冰可以说很好地完成了雷军交给红米的任务：极致性价比，留下小米的学生党和性价比党用户，并与realme和iqoo相比不落下风。redmi没有品牌转型的任务，价位段封顶4000元，不需要使用最新的技术，所以小米的120W快充不会下放redmi，红米今年的充电上限还是33w。这一点和iqoo不一样，iqoo作为19年的新品牌，初期仍需要打品牌，做充分的推广。所以iqoo从20年失败的iqoo3到120w的iqoo5p，再到今年的iqoo7，努力想做高端手机。\n红米今年K40系列采用几乎相同的磨具，只在SoC和摄像头做区分，pro的升级点可以说少得可怜，3699的pro+甚至还是33w的快充，只能看做成pro的大内存版，没有充足的理由让人掏钱买pro+；这一点，是redmi头顶上有小米11的无奈，如果小米数字旗舰站稳4999价位，那么红米才会有充足的加价空间。\n采用相同的模具可以降低研发、制造、售后成本，降低售价，并且快速进行产能切换，哪款卖得好就生产哪一款，但是也造成了pro的平庸，无法增加更多的配置打动消费者，仅凭1个系列覆盖2000-4000价位段十分困难，所以才会有去年三种不同的屏幕形态的K30，ultra和s ultra\n小米一直希望极致性价比，但是性价比并不是出路。经过市场的磨练，除了小米，其他玩性价比的厂商都死了，虽然可以证明小米的牛逼，但同时也证明了性价比模式的脆弱。小米也意识到这一点，所以在19年时，将性价比的任务全部交给redmi，但是，红米的骨子里永远摆脱不了小米的基因，始终无法做切割。一是红米的独立性不足，战略受限于小米的高层。二是名字相近，红米==小米的印象已经深深刻入大众的骨子里。不像realme和oppo一加，iqoo和vivo，在绝大部分人眼里，红米就是小米的低端，小米就是中低端性价比手机品牌。而要打破这一品牌认知，没有3-5年的积累是不够的，而且需要在3-5年里在核心技术、渠道、售后超越oppo，vivo，才能做到最后的销量超越。\n（K40的顶配是3月初在小米商城用米金兑换的购买资格，日常用它来打paj，不算云评测了哈，在性能释放方面很舒服，但感觉比k30p烫点，不知道是不是开了90hz的缘故）\n2.Realme GT系列\nrealme显然没有做到iqoo的水平，在中高端旗舰产品上比友商差很多，没有特色功能和眼前一亮的点，总之还没找到感觉。\n3.IQOO neo 5\nneo5在大部分参数做到了甚至超过了k40的水平，imx598胜过k40的582，55w快充也比33w快充牛\n但同时也在价格上超越了k40，在买不到K40 的情况下，是公认的平价替代的最佳选择，最高价12+256可以2800左右拿到，仅比k40的12+256黄牛加价版高一点点。没有什么好评价的，k40的第一竞争对手足以说明实例。\n4.小米11 Pro 和 Ultra 及 MIX FOLD\n预热时说产品很多，没想到这么多，更没想到开两天的发布会。重磅消息一个接一个。小米新logo，三个旗舰手机，一个11青春版，一台屏幕素质高的轻薄笔记本，一颗澎湃芯片，最重要的是小米宣布造车。\n手机方面，最具关注的是ultra，作为小米的最高端手机，背面的副屏赚足了眼球，5999的起售价也刷新了记录，6999的顶配12+512，价格不用多说，小米的顶峰。\n67W有线+67W无线，无线刷新了记录，234g的重量也刷新了记录，小米能给你的最好的堆料，都在这里，我就不复述厂商的PPT了。\n而对小米最大的意义，是有一台手机能在7000元的价位和iPhone华为抢销量，但也有不足，就是缺少了华为苹果独有的东西。华为有麒麟芯片，2020年9月14号前生产的9000系列做到了安卓端至今最强，5G技术领先全球，标志着中国大陆芯片设计的最好水平，可见华为人熬掉了多少头发。被美国制裁，是整个中国的不幸。任正非专注研发这一点，值得尊敬。\n小米相比华为的差距，不是一般的大。而现在小米转向造车，赚钱，芯片的事小米暂时不会碰了，和ov一样打算一辈子躺着挣钱，不打算思考一些如何体面的活着的问题。\nPro同样有竞争力，但是被ultra的光芒掩盖了，补足了4000-5000的价位的短板，同样的GN2,同样的IP68，更轻的重量208g，可以说比去年的10pro竞争力大大提高，就看出货了。\nMIX FOLD：最便宜的折叠屏，搭载小米自研的isp，，加上液态镜头。适合手上有闲钱的米粉。首发5w台销量，作为探索者，这个目标达到了。但是和友商mate和galaxy相比有差距，能不能稳定迭代更新，拭目以待吧。\n暂时小米在线上还没有对手，今年的find x3系列和一加9系列不够猛，在纯硬件竞争上比不过Pro,上半年线上市场收割问题不大。但是下半年有复出的荣耀，是有华为级别实力和财力的竞争对手，一旦走上正轨，不容小觑。\n","date":"2021-04-24T20:15:28+08:00","permalink":"https://bachwv.github.io/posts/%E4%BA%91%E6%B5%8B%E8%AF%84/","section":"posts","tags":null,"title":"云测评"},{"categories":null,"contents":"14. 最长公共前缀 编写一个函数来查找字符串数组中的最长公共前缀。\n如果不存在公共前缀，返回空字符串 \u0026quot;\u0026quot;。\n示例 1：\n输入：strs = [\u0026quot;flower\u0026quot;,\u0026quot;flow\u0026quot;,\u0026quot;flight\u0026quot;] 输出：\u0026quot;fl\u0026quot; 示例 2：\n输入：strs = [\u0026quot;dog\u0026quot;,\u0026quot;racecar\u0026quot;,\u0026quot;car\u0026quot;] 输出：\u0026quot;\u0026quot; 解释：输入不存在公共前缀。 提示：\n 0 \u0026lt;= strs.length \u0026lt;= 200 0 \u0026lt;= strs[i].length \u0026lt;= 200 strs[i] 仅由小写英文字母组成  先上我写的垃圾代码：\npublic class Test { public static String longestCommonPrefix(String strs[]) { try {//trycatch是针对输入空字符串的情况，输出空字符串  int len = strs[0].length(); for (String s : strs) {//这是一个foreach循环，算出最小的长度，这样在接下来就只要循环最小的长度了  if (s.length() \u0026lt; len) { len = s.length(); } } int count = -1;//用作计数  for (int i = 0; i \u0026lt; len; i++) { char c0 = strs[0].charAt(i); //这里将第一个字符串作为标准，将后面的字符串与第一个分别比较  for (String s : strs) {//这也是一个foreach循环  if (c0 != s.charAt(i)) {//一旦遇到不相等，就为count赋值，停止所有循环  count = i; break; } if(i+1==len){count=i+1;}//针对情况：“ab”，“a”，循环结束仍然没有为count赋值，那就手动赋值  } if ( count != -1) {//一旦count被赋值了（即不等于-1），立即break  break; } }//完成循环，开始输出结果  return strs[0].substring(0, count);//如果count==-1或者0，不用担心，exception会帮我们处理掉哦  }catch (Exception x){return \u0026#34;\u0026#34;;} } public static void main(String[] args) { String strs[] =new String[3]; strs[0]=\u0026#34;floger\u0026#34;; strs[1]= \u0026#34;flog\u0026#34;; strs[2]=\u0026#34;floght\u0026#34;; System.out.println(strs.length); System.out.println(longestCommonPrefix(strs)); } } 暴力求解，逐个循环，相信你一定没心情看我的烂代码。时隔不少天我再编辑时，发现我也看不懂了。\n下面给大家分享一个大神解法\n字典序最大和最小字符串的公共前缀 悠远的苍穹L3发布于 2020-06-1514.1kC++PythonPython3\n解题思路 先找出数组中字典序最小和最大的字符串，最长公共前缀即为这两个字符串的公共前缀 代码 下面是 C++17 的代码\nclass Solution { public: string longestCommonPrefix(vector\u0026lt;string\u0026gt;\u0026amp; strs) { if(strs.empty()) return \u0026quot;\u0026quot;; // c++17 结构化绑定 // str0, str1 分别是一个 pair\u0026lt;string, string\u0026gt; 的 first 和 second const auto [str0, str1] = minmax_element(strs.begin(), strs.end()); for(int i = 0; i \u0026lt; str0-\u0026gt;size(); ++i) if(str0-\u0026gt;at(i) != str1-\u0026gt;at(i)) return str0-\u0026gt;substr(0, i); return *str0; } }; 等同的 C++11 代码如下\nclass Solution { public: string longestCommonPrefix(vector\u0026lt;string\u0026gt;\u0026amp; strs) { if(strs.empty()) return \u0026quot;\u0026quot;; const auto p = minmax_element(strs.begin(), strs.end()); for(int i = 0; i \u0026lt; p.first-\u0026gt;size(); ++i) if(p.first-\u0026gt;at(i) != p.second-\u0026gt;at(i)) return p.first-\u0026gt;substr(0, i); return *p.first; } }; Python 代码\nclass Solution: def longestCommonPrefix(self, strs: List[str]) -\u0026gt; str: if not strs: return \u0026quot;\u0026quot; str0 = min(strs) str1 = max(strs) for i in range(len(str0)): if str0[i] != str1[i]: return str0[:i] return str0 这里关键在于minmax_elements的使用\n该函数是返回指定范围内的最大最小值的元素的迭代器组成的一个pair, 如果最值多于一个， first返回的是第一个出现的最小值的迭代器，second返回的是最后一个出现的最大值的迭代器 。\n下面是一个例子：\nvoid minmaxelement(){ vector\u0026lt;int\u0026gt; vi{3,5,4,1,3,1,9,9,5}; cout\u0026lt;\u0026lt;\u0026#34;vi=\u0026#34;; for(int i:vi) cout\u0026lt;\u0026lt;i\u0026lt;\u0026lt;\u0026#34; \u0026#34;; cout\u0026lt;\u0026lt;endl; auto it=minmax_element(vi.begin(),vi.end()); cout\u0026lt;\u0026lt;\u0026#34; auto it=minmax_element(vi.begin(),vi.end())\u0026#34;\u0026lt;\u0026lt;endl; cout\u0026lt;\u0026lt;\u0026#34;*it.first=\u0026#34;\u0026lt;\u0026lt;*it.first\u0026lt;\u0026lt;\u0026#34; ,*it.second=\u0026#34;\u0026lt;\u0026lt;*it.second\u0026lt;\u0026lt;endl; cout\u0026lt;\u0026lt;\u0026#34;*(it.first-1)=\u0026#34;\u0026lt;\u0026lt;*(it.first-1)\u0026lt;\u0026lt;\u0026#34; ,*(it.second-1)=\u0026#34;\u0026lt;\u0026lt;*(it.second-1)\u0026lt;\u0026lt;endl; } // auto it=minmax_element(vi.begin(),vi.end()) //it.first=1 it.second=9 //*(it.first-1)=4 *(it.second-1)=9 注意 string 比较采用的是 ”字典序“，a,bc,aac按照字典序比较就是：a,aac,bc.\ntemplate\u0026lt;class ForwardIt, class Compare\u0026gt; std::pair\u0026lt;ForwardIt, ForwardIt\u0026gt; minmax_element(ForwardIt first, ForwardIt last, Compare comp) { auto min = first, max = first; if (first == last || ++first == last) return {min, max}; if (comp(*first, *min)) { min = first; } else { max = first; } while (++first != last) { auto i = first; if (++first == last) { if (comp(*i, *min)) min = i; else if (!(comp(*i, *max))) max = i; break; } else { if (comp(*first, *i)) { if (comp(*first, *min)) min = first; if (!(comp(*i, *max))) max = i; } else { if (comp(*i, *min)) min = i; if (!(comp(*first, *max))) max = first; } } } return {min, max}; } https://en.cppreference.com/w/cpp/algorithm/minmax_element\n这是最初c语言第一节课的知识，strcmp的比较方法\ncomparison function object (i.e. an object that satisfies the requirements of Compare) which returns true if if *a is less than *b. The signature of the comparison function should be equivalent to the following:\nbool cmp(const Type1 \u0026amp;a, const Type2 \u0026amp;b);\nWhile the signature does not need to have const \u0026amp;, the function must not modify the objects passed to it and must be able to accept all values of type (possibly const) Type1 and Type2 regardless of value category (thus, Type1 \u0026amp; is not allowed, nor is Type1 unless for Type1 a move is equivalent to a copy (since C++11)). The types Type1 and Type2 must be such that an object of type ForwardIt can be dereferenced and then implicitly converted to both of them.\nhttps://en.cppreference.com/w/cpp/algorithm/minmax_element\n","date":"2021-04-20T16:32:05+08:00","permalink":"https://bachwv.github.io/posts/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80/","section":"posts","tags":null,"title":"最长公共前缀"},{"categories":null,"contents":"secTest ","date":"2021-04-20T16:00:12+08:00","permalink":"https://bachwv.github.io/posts/sec/","section":"posts","tags":null,"title":"Sec"}]