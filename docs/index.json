[{"categories":null,"contents":"Manjaro 的一些安装经验吧\n首先进bios，解除security，然后进boot menu，把首选启动项改成uefi 进入u盘安装 然后是分区，我先在windows压缩D盘空了60G空间，在manjaro里面把这个空间给它\n软件方面是飞书，用pacman下载yay，然后yay feishu安装5.2版本的飞书 debtop实在是没有成功解包，debtop还是从github上clone了原仓库，yay也是clone原仓库下来的\n第二个是输入法\n三步走\n1sudo pacman -S fcitx-configtool 2sudo pacman -S fcitx-gtk2 fcitx-gtk3 3sudo pacman -S fcitx-qt4 fcitx-qt5 4sudo pacman -S fcitx-sogoupinyin 这样是不行的，因为fcitx-sogoupinyin在pacman上找不到，还得用yay fcitx-spigoupinyin 最后 sudo echo -e \u0026quot;export GTK_IM_MODULE=fcitx\\n export QT_IM_MODULE=fcitx\\n export XMODIFIERS=@im=fcitx\u0026quot; \u0026gt;\u0026gt;~/.xprofile 就完事，因为需要~/.xprofile配置文件，然后重启就好了\n第三个是tim，这个只能通过wine来达到最好的体验，注意要调分辨率， env WINEPREFIX=\u0026quot;$HOME/.deepinwine/Spark-TIM\u0026quot; deepin-wine5 winecfg 在弹出的窗口中改dpi，我觉得2k屏改成200dpi左右比较合适\n","date":"2022-01-13T22:57:54+08:00","permalink":"https://uest.xyz/posts/manjaro_setup/","section":"posts","tags":null,"title":"Manjaro Setup"},{"categories":null,"contents":"蔡勒(zeller)公式\n给出日期，计算星期几\n$$ {\\displaystyle w=\\left(y+\\left[{\\frac {y}{4}}\\right]+\\left[{\\frac {c}{4}}\\right]-2c+\\left[{\\frac {26(month+1)}{10}}\\right]+day-1\\right){\\bmod {7}}}$$\n$${\\displaystyle c={\\frac {year}{100}}}$$ $${\\displaystyle y= year \\bmod {100}}$$\n所得的w即为星期几，w=0为星期日，w=1为星期一，以此类推\n注意：month的取值范围为3至14，如果月份数是1、2月要看作上一年的13、14月来计算，比如2000年2月29日要看作1999年的14月29日来计算\n 1185. 一周中的第几天 给你一个日期，请你设计一个算法来判断它是对应一周中的哪一天。\n输入为三个整数：day、month 和 year，分别表示日、月、年。\n您返回的结果必须是这几个值中的一个 {\u0026quot;Sunday\u0026quot;, \u0026quot;Monday\u0026quot;, \u0026quot;Tuesday\u0026quot;, \u0026quot;Wednesday\u0026quot;, \u0026quot;Thursday\u0026quot;, \u0026quot;Friday\u0026quot;, \u0026quot;Saturday\u0026quot;}。\n示例 1：\n1输入：day = 31, month = 8, year = 2019 2输出：\u0026#34;Saturday\u0026#34; 示例 2：\n1输入：day = 18, month = 7, year = 1999 2输出：\u0026#34;Sunday\u0026#34; 示例 3：\n1输入：day = 15, month = 8, year = 1993 2输出：\u0026#34;Sunday\u0026#34;  1class Solution { 2 public String dayOfTheWeek(int day, int month, int year) { 3 String []ans={\u0026#34;Sunday\u0026#34;,\u0026#34;Monday\u0026#34;, \u0026#34;Tuesday\u0026#34;, \u0026#34;Wednesday\u0026#34;, \u0026#34;Thursday\u0026#34;, \u0026#34;Friday\u0026#34;, \u0026#34;Saturday\u0026#34;}; 4 if(month\u0026lt;=2){ 5 month+=12; 6 year--; 7 } 8 int y=year%100,c=year/100; 9 int week=y+y/4+c/4-2*c+26*(month+1)/10+day-1+70; 10 //+70是因为可能出现负数 11 return ans[week%7]; 12 } 13} ","date":"2022-01-03T00:57:54+08:00","permalink":"https://uest.xyz/posts/zeller/","section":"posts","tags":["Leetcode","Easy"],"title":"Zeller"},{"categories":null,"contents":"时间片转了一圈，2022就在几个小时之后。\n过去一年，在我的视角，过得很快。学了很多，但更多的是遗憾。\n首先就是学业了，有几次的考试都不够理想，说实话是自己不够努力，没有用力逼自己学。懒惰了，懈怠了；今年看成杰答辩，发现自己大学浪费了太多的时间，没有科研，没有竞赛，也没有努力学习。\n今年另一个感受是，自己的见识太少了，自以为自己见过很多，但是肚子里的东西还是很少的。\n年度的几大moments\n一个是室友给的生日惊喜，完全没有料到，虽然当时没有表现出很震惊吧，但我会一直记住的。\n","date":"2021-12-31T20:41:25+08:00","permalink":"https://uest.xyz/life/2022newyear/","section":"life","tags":null,"title":"2022newyear"},{"categories":null,"contents":"​\n今天大家吃苹果了没，没吃的朋友来一起吃哈，\n 1705. 吃苹果的最大数目 难度中等\n有一棵特殊的苹果树，一连 n 天，每天都可以长出若干个苹果。在第 i 天，树上会长出 apples[i] 个苹果，这些苹果将会在 days[i] 天后（也就是说，第 i + days[i] 天时）腐烂，变得无法食用。也可能有那么几天，树上不会长出新的苹果，此时用 apples[i] == 0 且 days[i] == 0 表示。\n你打算每天 最多 吃一个苹果来保证营养均衡。注意，你可以在这 n 天之后继续吃苹果。\n给你两个长度为 n 的整数数组 days 和 apples ，返回你可以吃掉的苹果的最大数目*。*\n示例 1：\n1输入：apples = [1,2,3,5,2], days = [3,2,1,4,2] 2输出：7 3解释：你可以吃掉 7 个苹果： 4- 第一天，你吃掉第一天长出来的苹果。 5- 第二天，你吃掉一个第二天长出来的苹果。 6- 第三天，你吃掉一个第二天长出来的苹果。过了这一天，第三天长出来的苹果就已经腐烂了。 7- 第四天到第七天，你吃的都是第四天长出来的苹果。 示例 2：\n1输入：apples = [3,0,0,0,0,2], days = [3,0,0,0,0,2] 2输出：5 3解释：你可以吃掉 5 个苹果： 4- 第一天到第三天，你吃的都是第一天长出来的苹果。 5- 第四天和第五天不吃苹果。 6- 第六天和第七天，你吃的都是第六天长出来的苹果。 提示：\n apples.length == n days.length == n 1 \u0026lt;= n \u0026lt;= 2 * 104 0 \u0026lt;= apples[i], days[i] \u0026lt;= 2 * 104 只有在 apples[i] = 0 时，days[i] = 0 才成立   4个月之前尝试过这一题，然后失败了，趁着圣诞节，再吃一颗苹果吧。\n本题给了两个数组，一个是每天生成的苹果数量apples[i]，另一个是那天生成苹果的腐烂日期days[i]。\n很自然地，如果某一天想吃苹果，那么苹果必定没有腐烂，如果有一个表或者其他的什么东东能告诉我苹果有没有腐烂就好了。\n这时想到键值对，对于每天生成的苹果，记录一个腐烂截止日期，再记录苹果数。再将这个键值对排序，每次取最近腐烂但是还没腐烂的苹果吃。\n这就需要小根堆了，Java中是优先队列。\n具体实现上，分为两个阶段，在小于n（n是apples数组的长度）的日子里，每天产生苹果，将其入队，并且看看有没有腐烂的苹果，将其出队，再看看有没有能吃到的苹果，把它吃掉；大于n的日子，由于不产生苹果，就只有清理腐烂的苹果和吃苹果这两件事要做了。\n1public static int eatenApples(int[] apples, int[] days) { 2 3 PriorityQueue\u0026lt;int[]\u0026gt; q = new PriorityQueue\u0026lt;\u0026gt;(new Comparator\u0026lt;int []\u0026gt;() { 4 @Override 5 public int compare(int[] o1, int[] o2) { 6 return o1[0] - o2[0]; 7 } 8 }); 9 int len=apples.length; 10 int eat=0; 11 int []nn; 12 for(int i=0;i\u0026lt;len;i++){ 13 if(apples[i]!=0) { 14 q.add(new int[]{i+days[i]-1,apples[i]}); 15 // System.out.println(\u0026#34;add\u0026#34;+q.peek()[0]+\u0026#34; \u0026#34;+q.peek()[1]); 16 } 17 18 while(!q.isEmpty()\u0026amp;\u0026amp;(q.peek()[0]\u0026lt;i||q.peek()[1]\u0026lt;=0)){ 19 System.out.println(\u0026#34;poll \u0026#34;+q.peek()[0]+\u0026#34; \u0026#34;+q.peek()[1]); 20 q.poll();//清理过期苹果and小于0的苹果数 21 } 22 //eat 23 if(!q.isEmpty()){ 24 nn=q.poll(); 25 26 nn[1]--; 27 eat++; 28 q.add(nn); 29 //System.out.println(\u0026#34;i=\u0026#34;+i+\u0026#34; eat=\u0026#34;+eat+\u0026#34; nn[0]=\u0026#34;+nn[0]+\u0026#34; nn[1]=\u0026#34;+nn[1]+\u0026#34; \u0026#34;+q); 30 } 31 } 32 for(int i=len;!q.isEmpty();i++) { 33 while(!q.isEmpty()\u0026amp;\u0026amp;(q.peek()[0]\u0026lt;i||q.peek()[1]\u0026lt;=0)){ 34 // System.out.println(\u0026#34;poll \u0026#34;+q.peek()[0]+\u0026#34; \u0026#34;+q.peek()[1]); 35 q.poll();//清理过期苹果and小于0的苹果数 36 } 37 //eat 38 if(!q.isEmpty()){ 39 nn = q.poll(); 40 nn[1]--; 41 eat++; 42 q.add(nn); 43 } 44 } 45 return eat; 46 } 47 | 遥远遥远的以后 会不会有人知道我\n| 在这个寂寞的星球 曾这样的活过\n| 遥远遥远的以后 天长和地久的尽头\n| 应该没有人能抢走 我永远的感动\n| 活着不多不少 幸福刚好够用\n| 活着其实很好 再吃一颗苹果\n","date":"2021-12-24T19:55:00+08:00","permalink":"https://uest.xyz/posts/eatenapples/","section":"posts","tags":null,"title":"Merry Christmas"},{"categories":null,"contents":"priorityQuene 优先队列，意思是呢，它能对add进去的元素排列\n可以给它一个Comparator指定排列顺序\n默认是最小堆\n常用的有peek();poll();\n1PriorityQueue\u0026lt;Integer\u0026gt; q = new PriorityQueue\u0026lt;\u0026gt;(new Comparator\u0026lt;Integer\u0026gt;() { 2 @Override 3 public int compare(Integer o1, Integer o2) { 4 return o1 - o2; 5 } 6 }); 7 q.add(4); 8 q.add(33); 9 q.add(14); 10 q.add(100); 11 System.out.println(q.toString());//[4, 33, 14, 100] 12 System.out.println(q.peek());//4 13 Comparator\u0026lt;? super Integer\u0026gt; cp = q.comparator(); 14 15 Object[] list=q.toArray(); 16 17 System.out.println(Arrays.toString(list));//[4, 33, 14, 100] 这是最简单的情况\n优先队列里也可以放其他的对象，比如int[]\n指定按照int[]的第一个从小到大排序\n1 PriorityQueue\u0026lt;int[]\u0026gt; q = new PriorityQueue\u0026lt;\u0026gt;(new Comparator\u0026lt;int []\u0026gt;() { 2 @Override 3 public int compare(int[] o1, int[] o2) { 4 return o1[0] - o2[0]; 5 } 6 }); 7//也可以用lambda表达式：(o1,o2) o1[0]-o2[0]; 8 q.add(new int[]{4,19}); 9 q.add(new int[]{33,20}); 10 q.add(new int[]{14,22}); 11 q.add(new int[]{100,23}); 12 13 int []nn=q.poll(); 14 System.out.println(Arrays.toString(nn));//[4, 19] 15 nn=q.poll(); 16 System.out.println(Arrays.toString(nn));//[14, 22] 17 nn=q.poll(); 18 System.out.println(Arrays.toString(nn));//[33, 20] 19 nn=q.poll(); 20 System.out.println(Arrays.toString(nn));//[100, 23] ref:\n PriorityQueue的API文档说明：\n   构造方法摘要     **PriorityQueue**() 使用默认的初始容量（11）创建一个 PriorityQueue，并根据其自然顺序对元素进行排序。   **PriorityQueue**(Collection\u0026lt;? extends E\u0026gt; c) 创建包含指定 collection 中元素的 PriorityQueue。   **PriorityQueue**(int initialCapacity) 使用指定的初始容量创建一个 PriorityQueue，并根据其自然顺序对元素进行排序。   **PriorityQueue**(int initialCapacity, Comparator\u0026lt;? super E\u0026gt; comparator) 使用指定的初始容量创建一个 PriorityQueue，并根据指定的比较器对元素进行排序。   **PriorityQueue**(PriorityQueue\u0026lt;? extends E\u0026gt; c) 创建包含指定优先级队列元素的 PriorityQueue。   **PriorityQueue**(SortedSet\u0026lt;? extends E\u0026gt; c) 创建包含指定有序 set 元素的 PriorityQueue。       方法摘要       boolean **add**(E e) 将指定的元素插入此优先级队列。    void **clear**() 从此优先级队列中移除所有元素。    Comparator\u0026lt;? super E\u0026gt; **comparator**() 返回用来对此队列中的元素进行排序的比较器；如果此队列根据其元素的自然顺序进行排序，则返回 null。    boolean **contains**(Object o) 如果此队列包含指定的元素，则返回 true。    Iterator\u0026lt;E\u0026gt; **iterator**() 返回在此队列中的元素上进行迭代的迭代器。    boolean **offer**(E e) 将指定的元素插入此优先级队列。    E **peek**() 获取但不移除此队列的头；如果此队列为空，则返回 null。    E **poll**() 获取并移除此队列的头，如果此队列为空，则返回 null。    boolean **remove**(Object o) 从此队列中移除指定元素的单个实例（如果存在）。    int **size**() 返回此 collection 中的元素数。    Object[] **toArray**() 返回一个包含此队列所有元素的数组。   \u0026lt;T\u0026gt; T[] **toArray**(T[] a) 返回一个包含此队列所有元素的数组；返回数组的运行时类型是指定数组的类型。       从类 java.util.AbstractQueue 继承的方法     addAll, element, remove       从类 java.util.AbstractCollection 继承的方法     containsAll, isEmpty, removeAll, retainAll, toString       从类 java.lang.Object 继承的方法     clone, equals, finalize, getClass, hashCode, notify, notifyAll, wait, wait, wait       从接口 java.util.Collection 继承的方法     containsAll, equals, hashCode, isEmpty, removeAll, retainAll     ","date":"2021-12-24T19:45:00+08:00","permalink":"https://uest.xyz/posts/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/","section":"posts","tags":null,"title":"Java 优先队列"},{"categories":null,"contents":"在2021年的末尾，某人做了一件年度最傻的事。本来都不想发，毕竟这实在是太傻了，巨丑的事怎么能让你们知道。但由于傻到离谱了，以至于不得不记录，然后你们就有了嘲笑我的机会。放在blog上反正没人看。 今天是12月18日，也是大学生考四六级的日子。呆岭还有4份实验报告要写，昨晚帮别人配Pytorch的环境到3点，由于太冷到4点才睡着。今天9点半起床，飞奔到画室，准备了半个小时调颜料下去写生，冬日暖阳，正是好天气。找好位置，基础实验大楼旁边，摆好画架。 发现没带画纸，一定是某位同学错拿了我的装备。 回去画室，画室关门，无路可去了我。 机智的我决定干饭\n干完饭收了画架回画室 以为要以翘六级结束这个悲惨的一天\n惊讶的发现，画板的另一面，是有纸的。刹那间，我以为自己在另一个平行世界。怎么会有纸的?为什么我在外面没注意到画板有两个面啊。\n","date":"2021-12-18T12:36:31+08:00","permalink":"https://uest.xyz/life/%E5%A4%A9%E6%B0%94%E6%99%B4%E5%BF%83%E6%83%85%E6%9A%B4%E9%9B%A8/","section":"life","tags":null,"title":"天气晴，心情阴"},{"categories":null,"contents":"汇编考完了，总的来说，有点迷糊。当然上课的体验很好，还算行。\n乘着记忆力的顶峰，回忆下汇编学了啥。\n核心就是成就嘤特尔的8086系列CPU，和围绕CPU的存储器，外设。严格遵照冯诺依曼架构，采用存取程序的方式设计。构架了x86体系，尽管牙膏厂裹足不前，但直到今天，x86系列的老大还是嘤特尔。众多外设厂还得围绕牙膏厂和农厂转，比如今天被拉出来批判的联想，不是不想造cpu，而是壁垒太高了，差了几十年的发展，已经无法再构建一套新体系了\n而古董8086，现在只存在于模拟器中了，当然还有8259a，8255，8253这些东西。\n汇编是一门语言，是在机器码和高级语言的一个桥梁，串成一起，才是完整的计算机系统。\n其中的核心，我觉得是数据的移动过程。\n通过汇编语言操作硬件，完成数据在寄存器，总线，存储器中的移动。核心就是一个词，规则。\n纷乱的数据流动有着严格的规则。由此就引申出一些问题：\n流动过程中被打断了怎么办？我放一个数据，怎么找到它？要不要放一个全局的索引(GDT/LDT)?总线上两个数据会不会冲突？要不要有时钟周期同步?\n围绕这一系列问题，解决这些问题才是这门课的本质。\n学到最后才发现，这门课的名字，应该叫计算机的组成结构。或者说深入了解计算机系统。\n前几天看到一个回答，《超级马里奥3》使用了什么样的技术可以在128KB中写进这么多东西？\n128KB兄弟们，1MB是8086的寻址空间，除去接口，中断向量的地址，128KB能不能放得下还说不定呢。\n 声音部分: FC有两路方波生成器，一路三角波生成器，一路随机噪声，一路PCM。PCM采样可以实现很好的效果，但数据量巨大，所以大多数游戏没用。用方波/三角波来发声就类似最简单的MIDI音乐，数据量很小。\n 一看到方波生成器就来劲了，这不就可以通过8253的方式3来生成方波。\n 图形部分: 这是主要占卡带容量的部分，下面简单说一下\n FC的图形处理单元以sprite的方式组织图像，程序能控制的最小显示单位不是一个点，而是8x8的sprite。 “那整个画面卷动的时候不是应该一块一块（8像素）的跳动吗？”——PPU另外有卷轴寄存器，可以按像素级指定卷动的量。也就是说sprite虽然是8x8的，但在屏幕上不见得总是对齐到8x8的格子里。 sprite里具体每个点的颜色也不像现在是豪华的16位或32位RGB直接指定，而是一个2bit的索引，从一个16色的调色板里选。 既然是2bit的索引值，最多就只能指定4色。而且因为00固定代表透明，所以实际上最多只有3色。 那为啥要用到16色的调色板？实际上是4个4色的调色板。每4个相邻的sprite（16x16）可以从这4个调色板里指定一个。所以你去数，FC的一个16x16 sprite里最多只能显示4种颜色，因此会有那种经典的单调感。 16色的调色板有两个，一个背景层用，一个角色层用。调色板从FC PPU固定死的64种颜色中选取颜色。因为这64个颜色里黑色/透明重复了多次，所以实际不同的颜色只有54种。 不管你看没看晕，上面的重点是，FC游戏里面一个像素只占用2bit的卡带空间。 并且因为所有显示内容都按sprite组织，大大方便重复使用。要显示形状一模一样的两朵云，或者几十个砖块，只需要在显存里重复写下这些sprite的编号，而不是重复sprite的数据（8x8x2/8=16byte) 因为调色板的存在，形状一样而颜色不同的图案也不需要占额外的空间，只要设置一下调色板就行了，包括变色的效果也是这样做的。红色的Mario和绿色的Luigi就是同一套Sprite。 透明、滚动、前后景叠加、碰撞检测都是PPU完成，不需要另外写程序。 sprite的数据也不存在由CPU从卡带读入到RAM的过程（除了后期的磁碟机），而是直接由卡带映射到FC的64KB地址空间进行访问。不同的卡带硬件（所谓的mapper）支持由程序控制将卡带上的不同地址映射到FC的同一地址空间，所以尽管8位的FC只有64KB寻址能力，但卡带容量可以做到256KB甚至更大。   2bit图像，你们见过吗？\n今天OPPO发布的NPU，MariSilicon X的影像处理单元最高支持20bit处理位宽，20 bit Ultra HDR\n可以想象Computer的基石是怎么打下的，现在回看当时都不能叫做程序员，应该叫做Creator。我们算什么，一群调包者罢了，没什么自己创造的东西。不过是站在前人的肩膀上罢了，用别人的框架实现别人的idea了，就能当作自己的成果了。\n如果大家都用层层封装的Python，在装着Windows的mac上用Linux虚拟机写作业。计网看那个ppt就写个实验报告，啥都不干。\n我现在非常想弄清楚的一个问题，在浏览器中输入www.baidu.com究竟会经历什么，能不能详细说说。键盘就怎么输入进去的，操作系统起了什么作用，baidu.com怎么相应这么大规模的请求的，ip层究竟发生了什么，能不能换一条路到达，我需要北京的百度服务器对我相应，然后走上海的路最后到成都能不能做到？有没有人偷看我的包，怎么防止他偷看？作为一个计算机网络的小弱鸡，真的想搞明白这些问题。\n1 微型计算机基础概论\n2.微处理器8086和8088\n","date":"2021-12-14T20:05:28+08:00","permalink":"https://uest.xyz/posts/%E6%B1%87%E7%BC%96%E5%A4%8D%E4%B9%A0/","section":"posts","tags":null,"title":"汇编不会编"},{"categories":null,"contents":"CentOS部署pdd\n1.CentOS安装jdk\n1yum install java-1.8.0-openjdk.x86_64 会自动配置环境变量\n2.安装tomcat\n安装目录/usr/local/tomcat\n和win下配置一模一样，i了i了\n3.安装mysql 有点复杂 https://www.cnblogs.com/zhulei2/p/13912167.html 关于密码要改一下策略\n1SHOW VARIABLES LIKE \u0026#39;validate_password%\u0026#39;; 2 3set global validate_password.length=1; 4grant all privileges on *.* to \u0026#39;user02\u0026#39;@\u0026#39;%\u0026#39; with grant option; 5create user user02@\u0026#39;%\u0026#39; identified by \u0026#39;2077\u0026#39;; 远程连接：  GRANT ALL PRIVILEGES ON *.*TO 'root'@'%';\n4.打war包 idea中build-\u0026gt;build artifacts https://blog.csdn.net/money_yao/article/details/91435188 移到webapp试了可以 注意\\conf\\Catalina\\localhost中加入命名为shopimage.xml完成虚拟文件夹创建\n1\u0026lt;Context docBase=\u0026#34;C:\\Program Files\\Apache Software Foundation\\Tomcat 9.0\\webapps\\shopimage\u0026#34;/\u0026gt; 注意在tomcat运行过程中，webapps下面的war文件是热部署的，不需要重启tomcat，并且.war文件不能删除，否则项目无法打开。\n目前已知问题：用户登录以后的订单list的sql语句有问题，目测是CentOS下Mysql8.0的锅 查询用户表很慢，不知道什么原因\n","date":"2021-12-12T23:56:31+08:00","permalink":"https://uest.xyz/posts/pdd_on_centos/","section":"posts","tags":null,"title":"CentOS上部署tomcat项目"},{"categories":null,"contents":"ASCII 打印字符：**数字 32–126 分配给了能在键盘上找到的字符，当您查看或打印文档时就会出现。注：十进制32代表空格 ，十进制数字 127 代表 DELETE 命令。下面是ASCII码和相应数字的对照表\n   ASCII 码 字符  ASCII 码 字符  ASCII 码 字符  ASCII 码 字符         十进位 十六进位  十进位 十六进位  十进位 十六进位  十进位 十六进位       032 20   056 38 8  080 50 P  104 68 h   033 21 !  057 39 9  081 51 Q  105 69 i   034 22 \u0026quot;  058 3A :  082 52 R  106 6A j   035 23 #  059 3B ;  083 53 S  107 6B k   036 24 $  060 3C \u0026lt;  084 54 T  108 6C l   037 25 %  061 3D =  085 55 U  109 6D m   038 26 \u0026amp;  062 3E \u0026gt;  086 56 V  110 6E n   039 27 '  063 3F ?  087 57 W  111 6F o   040 28 (  064 40 @  088 58 X  112 70 p   041 29 )  065 41 A  089 59 Y  113 71 q   042 2A *  066 42 B  090 5A Z  114 72 r   043 2B +  067 43 C  091 5B [  115 73 s   044 2C ,  068 44 D  092 5C \\  116 74 t   045 2D -  069 45 E  093 5D ]  117 75 u   046 2E .  070 46 F  094 5E ^  118 76 v   047 2F /  071 47 G  095 5F _  119 77 w   048 30 0  072 48 H  096 60 `  120 78 x   049 31 1  073 49 I  097 61 a  121 79 y   050 32 2  074 4A J  098 62 b  122 7A z   051 33 3  075 4B K  099 63 c  123 7B {   052 34 4  076 4C L  100 64 d  124 7C |   053 35 5  077 4D M  101 65 e  125 7D }   054 36 6  078 4E N  102 66 f  126 7E ~   055 37 7  079 4F O  103 67 g  127 7F DEL    ","date":"2021-12-10T23:23:40+08:00","permalink":"https://uest.xyz/posts/ascii/","section":"posts","tags":null,"title":"Ascii"},{"categories":null,"contents":" 383. 赎金信 难度简单202\n为了不在赎金信中暴露字迹，从杂志上搜索各个需要的字母，组成单词来表达意思。\n给你一个赎金信 (ransomNote) 字符串和一个杂志(magazine)字符串，判断 ransomNote 能不能由 magazines 里面的字符构成。\n如果可以构成，返回 true ；否则返回 false 。\nmagazine 中的每个字符只能在 ransomNote 中使用一次。\n示例 1：\n1输入：ransomNote = \u0026#34;a\u0026#34;, magazine = \u0026#34;b\u0026#34; 2输出：false 示例 2：\n1输入：ransomNote = \u0026#34;aa\u0026#34;, magazine = \u0026#34;ab\u0026#34; 2输出：false 示例 3：\n1输入：ransomNote = \u0026#34;aa\u0026#34;, magazine = \u0026#34;aab\u0026#34; 2输出：true 提示：\n 1 \u0026lt;= ransomNote.length, magazine.length \u0026lt;= 105 ransomNote 和 magazine 由小写英文字母组成   1class Solution { 2 public boolean canConstruct(String ransomNote, String magazine) { 3 char a[]=new char[26]; 4 for(int i=0;i\u0026lt;magazine.length();i++){ 5 a[magazine.charAt(i)-\u0026#39;a\u0026#39;]++; 6 7 } 8 for(int i=0;i\u0026lt;ransomNote.length();i++){ 9 if(a[ransomNote.charAt(i)-\u0026#39;a\u0026#39;]\u0026gt;0) 10 a[ransomNote.charAt(i)-\u0026#39;a\u0026#39;]--; 11 else return false; 12 } 13 return true; 14 15 } 16} ","date":"2021-12-04T00:28:37+08:00","permalink":"https://uest.xyz/leetcode/383.%E8%B5%8E%E9%87%91%E4%BF%A1/","section":"LeetCode","tags":null,"title":"383.赎金信"},{"categories":null,"contents":"11月的力扣打卡有点懈怠了，今天看到某些人全站排名7000，竞赛排名2400，表示再\n 400. 第 N 位数字 难度中等277\n给你一个整数 n ，请你在无限的整数序列 [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, ...] 中找出并返回第 n 位上的数字。\n示例 1：\n1输入：n = 3 2输出：3 示例 2：\n1输入：n = 11 2输出：0 3解释：第 11 位数字在序列 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, ... 里是 0 ，它是 10 的一部分。 提示：\n 1 \u0026lt;= n \u0026lt;= 231 - 1 第 n 位上的数字是按计数单位（digit）从前往后数的第 n 个数，参见 示例 2 。  通过次数41,651\n提交次数91,695\n 这一题的思路不难，对于N=1-9来说\n1 2class Solution { 3 public int findNthDigit(int n) { 4 if(n\u0026lt;10) return n; 5 int i=2; 6 long maxnum=9; 7 long temp=0; 8 int mod=0; 9 while(true){ 10 if(n\u0026lt;maxnum+9*(long)Math.pow(10,i-1)*i){ 11 long before=0; 12 for(int j=0;j\u0026lt;i;j++)before+=(long)9*Math.pow(10,j-1); 13 temp=(n-maxnum+1)/i+before;//这里的加1是因为往数轴正方向再数一个值 14 mod=(int)(n-maxnum-1)%i;//这里的减1是为了让mod=0对准最高位 15 // 346 347 348 349 350 351 16 //152：1 5 2 1 5 3 17 // System.out.println(\u0026#34;temp=\u0026#34;+temp+\u0026#34; mod=\u0026#34;+mod+\u0026#34; i=\u0026#34;+i); 18 //System.out.println(\u0026#34;maxnum=\u0026#34;+maxnum); 19 String s=String.valueOf(temp); 20 return s.charAt(mod)-48; 21 }else{ 22 maxnum=maxnum+9*(long)Math.pow(10,i-1)*i; 23 i++; 24 } 25 } 26 } 27} ","date":"2021-12-04T00:19:37+08:00","permalink":"https://uest.xyz/leetcode/400.%E7%AC%ACn%E4%BD%8D%E6%95%B0%E5%AD%97/","section":"LeetCode","tags":null,"title":"400.第N位数字"},{"categories":null,"contents":" 1. 两数之和 难度简单\n给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那 两个 整数，并返回它们的数组下标。\n你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。\n你可以按任意顺序返回答案。\n示例 1：\n1输入：nums = [2,7,11,15], target = 9 2输出：[0,1] 3解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。 示例 2：\n1输入：nums = [3,2,4], target = 6 2输出：[1,2] 示例 3：\n1输入：nums = [3,3], target = 6 2输出：[0,1] 提示：\n 2 \u0026lt;= nums.length \u0026lt;= 104 -109 \u0026lt;= nums[i] \u0026lt;= 109 -109 \u0026lt;= target \u0026lt;= 109 只会存在一个有效答案  **进阶：**你可以想出一个时间复杂度小于 O(n2) 的算法吗？\n 1 2class Solution { 3 public static int[] twoSum(int[] nums, int target) { 4 int []solution=new int[2]; 5 HashMap\u0026lt;Integer,Integer\u0026gt; hashMap=new HashMap\u0026lt;Integer, Integer\u0026gt;(); 6 for (int j0=0;j0\u0026lt;nums.length;j0++) { 7 if(hashMap.containsKey(target-nums[j0])){ 8 solution[0]=hashMap.get(target-nums[j0]); 9 solution[1]=j0; 10 return solution; 11 }else { 12 hashMap.put(nums[j0],j0); 13 } 14 } 15 return solution; 16 } 17} ","date":"2021-12-03T16:49:37+08:00","permalink":"https://uest.xyz/leetcode/1.%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/","section":"LeetCode","tags":null,"title":"1.两数之和"},{"categories":null,"contents":"1.两数之和\n2\n19.删除链表的倒数第N个结点\n48.旋转图像\n383.赎金信\n400.第N位数字\n1# 建议使用绝对路径（根目录为content目录），而非相对路径，否则容易出错 2ref绝对路径： 3[19.删除链表的倒数第N个结点](https://uest.xyz/posts/19%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACn%E4%B8%AA%E7%BB%93%E7%82%B9/) 4relref相对路径： 5[19.删除链表的倒数第N个结点](/posts/19%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACn%E4%B8%AA%E7%BB%93%E7%82%B9/) 6 7# 只有所引用的文件与当前文件在同一文件夹下时可以使用 相对路径的方式（只写文件名） 为了实现左侧有LeetCode的效果，对Hugo来说，配置十分简单，\n在taxonomies中添加leetcode标签，这是为了根据leetcode文件夹生成http://localhost:1313/leetcode/，里面是leetcode文件夹中的文章\nTaxonomies are classifications of logical relationships between content.\n而方框中[[menu.main]，决定了leetcode标签是否显示在左侧侧边栏\nhttps://gohugo.io/content-management/taxonomies/\nHugo代码增加显示行号功能 今天看Hugo文档的时候，发现hugo已经有显示行号的功能了\nhugo的版本需要v0.60.0以上\n实现的方式很简单，只要修改配置文件即可\n修改配置文件 修改主配置文件config.toml,在配置文件中增加\n1 pygmentsUseClasses = true 2 [markup] 3 [markup.highlight] 4 codeFences = true 5 guessSyntax = true 6 hl_Lines = \u0026#34;\u0026#34; 7 lineNoStart = 1 8 lineNos = true 9 lineNumbersInTable = false 10 noClasses = true 11 12 tabWidth = 4 添加阅读次数 在themes/hugo-theme-tokiwa/layouts/patrials/page-asids.html中添加\n1\u0026lt;!-- 不蒜子 21/12/4 ljl引入站长统计--\u0026gt; 2\u0026lt;script async src=\u0026#34;//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; 以上是必须引用的脚本\n下面在Built with Hugo and theme后面加入\n1\u0026lt;span id=\u0026#34;busuanzi_container_page_pv\u0026#34;\u0026gt; 2 本文总阅读量\u0026lt;span id=\u0026#34;busuanzi_value_page_pv\u0026#34;\u0026gt;\u0026lt;/span\u0026gt;次 3\u0026lt;/span\u0026gt; ","date":"2021-12-03T16:35:57+08:00","permalink":"https://uest.xyz/posts/%E8%B7%B3%E8%BD%AC%E6%B5%8B%E8%AF%95/","section":"posts","tags":null,"title":"跳转测试"},{"categories":["tech"],"contents":"前几天被群晖官方从阿尔及利亚区强制迁回中国，导致需要手机号验证，验证完了以后会显示序列号冲突，得拍视频提交工单才能解除冲突，才能使用easyconnect，这令我十分不爽。一怒之下注销了群晖的号，打算自己弄。\n由于我没有公网ip，又不想弄花生壳，teamviewer，所以我得想办法解决公网访问的问题。\n下面介绍借助frp实现内网穿透。\nfrp分为客户端和服务端两个部分，服务器上使用的是frps，群晖上使用的是frpc。\n在客户端开端口，然后群晖的frpc连接上服务器上的frps就可以了。\n下面是手把手教学：\n服务器端 如果你有一台闲置的Linux服务器，而且有公网ip，在打开防火墙以后，按照一下方法操作 如果你没有，也可以使用免费的一些frp服务器https://frp.wlphp.com/，这样你就可以跳过服务器配置的过程了。直接 跳转到群晖上操作\n下载 在https://github.com/fatedier/frp/releases中找到需要下载的文件,比如我想下载0.37.0的linux的x86平台的frp，就可以这么写：\n1# wget -O frp https://github.com/fatedier/frp/releases/download/v0.37.0/frp_0.37.0_linux_amd64.tar.gz 解压：\n1# tar -xvzf frp 可以看到这些文件：\n1# ls 2frpc frpc.ini frps frps.ini systemd 3frpc_full.ini frpc.log frps_full.ini LICENSE 接下来就是配置服务器端文件frps.ini\n1[common] 2bind_port = 7000 3#通讯端口，用于和客户端内网穿透传输数据的端口，可自定义 4bind_udp_port = 7001 5#UDP通讯端口，用于点对点内网穿透 6kcp_bind_port = 7000 7#用于KCP协议UDP通讯端口，在弱网环境下传输效率提升明显，但是会有一些额外的流量消耗。设置后frpc客户端须设置protocol = kcp 8vhost_http_port = 80 9#http监听端口，注意可能和服务器上其他服务用的80冲突，比如centos有些默认有Apache，可自定义 10vhost_https_port = 443 11#https监听端口，可自定义 12dashboard_port = 7500 13#通过浏览器查看 frp 的状态以及代理统计信息展示端口，可自定义 14dashboard_user = admin 15#信息展示面板用户名 16dashboard_pwd = admin 17#信息展示面板密码 18log_max_days = 7 19#最多保存多少天日志 20token = xxxxxx 21#这就是与客户端连接的token啦 22privilege_allow_ports = 1-65535 23#端口白名单，为了防止端口被滥用，可以手动指定允许哪些端口被使用 24max_pool_count = 100 25#每个内网穿透服务限制最大连接池上限，避免大量资源占用，可自定义 26authentication_timeout = 0 27#frpc 所在机器和 frps 所在机器的时间相差不能超过 15 分钟，因为时间戳会被用于加密验证中，防止报文被劫持后被其他人利用,单位为秒，默认值为 900，即 15 分钟。如果修改为 0，则 frps 将不对身份验证报文的时间戳进行超时校验。国外服务器由于时区的不同，时间会相差非常大，这里需要注意同步时间或者设置此值为0 28log_file = frps.log 29log_level = info 实际上没有必要配置这么多，bind_port = 7000和token就够了。 下一步运行就可以了，这里用后台运行的指令\n1# nohup ./frps -c frps.ini \u0026amp; 可以在服务器ip:7500端口看到frps的运行状态，至此，服务器端的配置就完成了。\n客户端 首先，得用ssh登录群晖。如果你没有用过ssh登录过，可以进入群晖控制面板，找到终端机和SNMP，点击启动SSH功能，设定你的端口（默认22） 点击应用。\n接下来使用你顺手的ssh登录就可以了。利用admin账号和密码登录（注意admin账号登录进去以后还要用sudo -i，不然没有权限） 找到一个顺手的 目录，比如home，利用同样的命令 下载\n这时，我们关注的是frpc.ini这个配置文件\n1[common] 2server_addr = xxx.xxx.xxx.xxx 3#frps服务端地址 4server_port = 7000 5#frps服务端通讯端口，客户端连接到服务端内网穿透传输数据的端口 6token = xxxxxxx 7#特权模式密钥，客户端连接到FRPS服务端的验证密钥 8log_file = frpc.log 9#日志存放路径 10log_level = info 11#日志记录类别,可选：trace, debug, info, warn, error 12log_max_days = 7 13#日志保存天数 14login_fail_exit = false 15#设置为false，frpc连接frps失败后重连，默认为true不重连 16protocol = kcp 17#KCP协议在弱网环境下传输效率提升明显，但是对frps会有一些额外的流量消耗。服务端须先设置kcp_bind_port = 7000，www.yourdomain.com服务端已设置支持 18 19[nas] 20#穿透服务名称,可以随便起,不能和其他已建立的相同 21type = tcp 22#穿透协议类型，可选：tcp，udp，http，https，stcp，xtcp，这个设置之前必须自行搞清楚应该是什么 23local_ip = 127.0.0.1 24#本地监听IP，可以是本机IP，也可以是本地的局域网内某IP，例如你的局域网是互通的，你可以在路由器上安装frpc，然后local_ip填的内网其他机器ip，这样也可以把内网其他机器穿透出去 25local_port = 5000 26#本地监听端口，通常有ssh端口22，远程桌面3389等等,就是把本机的多少端口转发出去 27use_compression = true 28#对传输内容进行压缩，可以有效减小 frpc 与 frps 之间的网络流量，加快流量转发速度，但是会额外消耗一些 cpu 资源 29use_encryption = true 30#将 frpc 与 frps 之间的通信内容加密传输 31remote_port = 5009 32#即远程对应你客户端的端口，不能和别的重合 33 下一步在frp目录下新建一个启动脚本start.sh，让群晖每次开机时运行这一个脚本\n1nohup /home/frp/frpc -c /home/frp/frpc.ini \u0026gt;/dev/null 2\u0026gt;\u0026amp;1 \u0026amp; 解释一下为什么要这么写：\n /dev/null 这条命令的作用是将标准输出1重定向到/dev/null中。 /dev/null代表linux的空设备文件，所有往这个文件里面写入的内容都会丢失，俗称“黑洞”。那么执行了\u0026gt;/dev/null之后，标准输出就会不再存在，没有任何地方能够找到输出的内容。\n 2\u0026gt;\u0026amp;1 这条命令用到了重定向绑定，采用\u0026amp;可以将两个输出绑定在一起。这条命令的作用是错误输出将和标准输出同用一个文件描述符，说人话就是错误输出将会和标准输出输出到同一个地方。\nlinux在执行shell命令之前，就会确定好所有的输入输出位置，并且从左到右依次执行重定向的命令，所以\u0026gt;/dev/null 2\u0026gt;\u0026amp;1的作用就是让标准输出重定向到/dev/null中（丢弃标准输出），然后错误输出由于重用了标准输出的描述符，所以错误输出也被定向到了/dev/null中，错误输出同样也被丢弃了。执行了这条命令之后，该条shell命令将不会输出任何信息到控制台，也不会有任何信息输出到文件中。\n接下来，回到群晖的控制台，在控制面板的计划任务中 新建任务,事件为开机 在任务设置中填写： bash /home/frp/start.sh 重启群晖 就可以在服务器的7500看到刚刚登录进来的群晖。\n输入服务器ip:端口（在frpc.ini中设置的remote端口），即可看到你的设备啦。 如果你不嫌烦+不怕死，你也可以把群晖的22端口映射出去。\n当然，如果你有远程桌面，tomcat，nginx的需求都可以用这种方法，对我来说frp取代teamviewer和花生壳是完全可以的。\n","date":"2021-11-10T16:58:12+08:00","permalink":"https://uest.xyz/posts/%E7%BE%A4%E6%99%96frp/","section":"posts","tags":null,"title":"frp内网穿透"},{"categories":null,"contents":"深夜emo\nemoemoemoemoemoemoemoemoemoemoemoemoemoemoemoemoemoemoemoemoemoemoemoemoemoemoemoemoemoemoemoemo\n无意间翻到大佬的博客，发现自己真的错失了许多机会，做错了不少选择。\n以上是在为自己的失败找理由，失败的结局无法避免，从高中就如此，早已看到结局，却又不接受结局，只能编造理由掩盖失败。\n可是时间不能再重来，希望以后能够把握住机会，真心投入做好一些事吧。\n至少不像现在一样一事无成吧。\n一定会的\nSeize the day\n","date":"2021-11-05T00:01:16+08:00","permalink":"https://uest.xyz/posts/%E4%B8%A7/","section":"posts","tags":null,"title":"丧"},{"categories":null,"contents":" 869. 重新排序得到 2 的幂 难度中等\n给定正整数 N ，我们按任何顺序（包括原始顺序）将数字重新排序，注意其前导数字不能为零。\n如果我们可以通过上述方式得到 2 的幂，返回 true；否则，返回 false。\n示例 1：\n1输入：1 2输出：true 示例 2：\n1输入：10 2输出：false 示例 3：\n1输入：16 2输出：true 示例 4：\n1输入：24 2输出：false 3  又是一个常规的dfs回溯\n1class Solution { 2 int flag=0; 3 public boolean reorderedPowerOf2(int n) { 4 5 int list[]=new int [10]; 6 int i=0; 7 while(n\u0026gt;0){ 8 list[i]=n % 10; 9 n/=10; 10 i++; 11 } 12 System.out.println(i); 13 dfs(list,0,i); 14 return flag==1; 15 16 } 17 void dfs(int list[],int start,int len){ 18 if(start==len){ 19 20 int ans=0; 21 for(int j=0;j\u0026lt;len;j++){ 22 if(ans==0\u0026amp;\u0026amp;list[j]==0) return;//先导0 23 else if(ans==0) ans=list[j]; 24 else ans=10*ans+list[j]; 25 26 } 27 if(isPowerOfTwo(ans)) flag=1; 28 return; 29 30 } 31 32 for(int i=start;i\u0026lt;len;i++){ 33 swap(list,start,i); 34 dfs(list,start+1,len); 35 swap(list,i,start); 36 } 37 return ; 38 39 } 40 void swap(int list[],int s,int d){ 41 int temp=list[s]; 42 list[s]=list[d]; 43 list[d]=temp; 44 } 45 boolean isPowerOfTwo(int n) { 46 //参考2的幂那一题 47 if(n==0) return false; 48 if(n==1) return true; 49 while(((n\u0026gt;\u0026gt;1)\u0026lt;\u0026lt;1)==n){ 50 n=n\u0026gt;\u0026gt;1; 51 if(n==1) return true; 52 } 53 return false; 54 } 55} ","date":"2021-10-28T00:39:21+08:00","permalink":"https://uest.xyz/posts/869.%E9%87%8D%E6%96%B0%E6%8E%92%E5%BA%8F%E5%BE%97%E5%88%B02%E7%9A%84%E5%B9%82/","section":"posts","tags":["Leetcode","Medium"],"title":"869.重新排序得到 2 的幂"},{"categories":null,"contents":" 301. 删除无效的括号 难度困难\n给你一个由若干括号和字母组成的字符串 s ，删除最小数量的无效括号，使得输入的字符串有效。\n返回所有可能的结果。答案可以按 任意顺序 返回。\n示例 1：\n1输入：s = \u0026#34;()())()\u0026#34; 2输出：[\u0026#34;(())()\u0026#34;,\u0026#34;()()()\u0026#34;] 示例 2：\n1输入：s = \u0026#34;(a)())()\u0026#34; 2输出：[\u0026#34;(a())()\u0026#34;,\u0026#34;(a)()()\u0026#34;] 示例 3：\n1输入：s = \u0026#34;)(\u0026#34; 2输出：[\u0026#34;\u0026#34;] 提示：\n 1 \u0026lt;= s.length \u0026lt;= 25 s 由小写英文字母以及括号 '(' 和 ')' 组成 s 中至多含 20 个括号   今天也是一个dfs，暴力搜索，照着模板写就可以了，需要注意\n剪枝技巧\n  一旦检测到不满足有效的括号，即可退出，注意先跳出for循环，别直接return\n  当没有处理的lrm和rrm大于剩下的字符串长度时，即可退出（我没写）\n  （去重技巧）检测到连续的左括号或者右括号，只用取第一个就可以了\n  1class Solution { 2 HashSet\u0026lt;String\u0026gt; ans=new HashSet\u0026lt;\u0026gt;(); 3 public List\u0026lt;String\u0026gt; removeInvalidParentheses(String s) { 4 5 int lrm=0,rrm=0; 6 7 for(int i=0;i\u0026lt;s.length();i++){ 8 if(s.charAt(i)==\u0026#39;(\u0026#39;){ 9 lrm++; 10 }else if(s.charAt(i)==\u0026#39;)\u0026#39;){ 11 if(lrm==0){ 12 rrm++; 13 }else lrm--; 14 } 15 } 16 17 dfs(s,lrm,rrm,0,0,0); 18 List\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;String\u0026gt;(ans); 19 return list; 20 21 } 22 void dfs(String s,int lrm,int rrm,int donel,int doner,int start){ 23 //必须要加上start因为前面的搜索过了后面就不需要搜索了 24 // System.out.println(\u0026#34;dfs\u0026#34;+s); 25 if(lrm==0\u0026amp;\u0026amp;rrm==0){ 26 if(isVaild(s)) ans.add(s); 27 return; 28 } 29 if(lrm\u0026lt;0||rrm\u0026lt;0) return; 30 31 for(int i=start;i\u0026lt;s.length();i++){ 32 if(s.charAt(i)==\u0026#39;(\u0026#39;){ 33 34 if(lrm\u0026gt;0){ 35 dfs(s.substring(0,i)+s.substring(i+1,s.length()),lrm-1,rrm,donel,doner,i); 36 } 37 donel++; 38 } 39 if(s.charAt(i)==\u0026#39;)\u0026#39;){ 40 41 if(rrm\u0026gt;0){ 42 43 dfs(s.substring(0,i)+s.substring(i+1,s.length()),lrm,rrm-1,donel,doner,i); 44 } 45 doner++; 46 } 47 int rm=lrm+rrm; 48 if(doner\u0026gt;donel){ 49 break; 50 } 51 52 } 53 54 } 55 Boolean isVaild(String s){ 56 int l=0,r=0; 57 58 for(int i=0;i\u0026lt;s.length();i++){ 59 if(s.charAt(i)==\u0026#39;(\u0026#39;)l++; 60 else if(s.charAt(i)==\u0026#39;)\u0026#39;){ 61 if(l\u0026gt;0) l--; 62 else if(l==0) return false; 63 } 64 } 65 return true; 66 } 67} ","date":"2021-10-27T22:49:20+08:00","permalink":"https://uest.xyz/posts/301.%E5%88%A0%E9%99%A4%E6%97%A0%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/","section":"posts","tags":["Leetcode","Difficult"],"title":"301. 删除无效的括号"},{"categories":null,"contents":"dfs回溯\n如何将1-9个数字排序？\n我们拿123来举例，\n可以设置一个函数，通过递归调用的方式完成排序功能\n将数组divide两半，排序过的和没排序过的。\n第一子树取1 没排序的是2 3 接下来调用自身对2 3进行排序，\n第二子树取2 没排序的是1 3 接下来调用自身对1 3进行排序，\n第二子树取3 没排序的是2 3 接下来调用自身对2 3进行排序，\n那么会有一个问题，取了2以后，我怎么知道没取的是2？可以将2移到已取的序列中，即移到本次递归的已排序序列的最后一个。我们用first来区隔已取和未取。\n递归退出的条件是所有的数都在已排序的序列中。\n1 2output=[1,2,3,4,5,6,7,8,9]; 3dfs(1,9,output) 4 5function dfs(first,n,output) 6if(output(5)==1||output(1)\u0026gt;4||output(4)==1||output(9)==1) 7 %%分析容易得知，第二个乘数不可能为1，并且第一个乘数的千位不可能大于等于5 8 %%需要做一些预处理工作才能达到剪枝的目的。预处理工作虽然也消耗时间，但能够剪枝节约的时间更多； 9 return 10end 11%%从这里开始都是剪枝 12firstnum=output(1)*1000+output(2)*100+output(3)*10+output(4); 13z=firstnum*output(5); 14if z \u0026gt; 9876 15 return; 16else 17 a6=fix(z/1000); 18 a7=fix((z-a6*1000)/100); 19 a8=fix((z-a6*1000-a7*100)/10); 20 a9=fix(z-a6*1000-a7*100-a8*10); 21 if a6==a7||a6==a8||a6==a9||a7==a8||a7==a9||a8==a9 22 return 23 end 24 25 end 26%%以上是剪枝 27if(first+1==n) 28 isAns(output) 29 return 30end 31for i=first:n 32 temp=output(i); 33 output(i)=output(first); 34 output(first)=temp; 35 %用来交换output数组中索引first和i元素，移到本次递归的已排序序列的最后一个 36 dfs(first+1,9,output); 37 38 temp=output(i); 39 output(i)=output(first); 40 output(first)=temp; 41 %用来交换output数组中索引first和i元素，这一步为回溯的关键！ 42end 43 44end 45function isAns(output) 46%用来判断是否找到结果 47%即output的前4位乘第五位是否等于后4位 48first=output(1)*1000+output(2)*100+output(3)*10+output(4); 49last=output(6)*1000+output(7)*100+output(8)*10+output(9); 50 51if first*output(5)==last 52 fprintf(\u0026#39;%d * %d = %d\\n\u0026#39;,first,output(5),last) 53end 54end 一些优化，回溯，用于对空间进行优化\n搜索问题的状态空间一般很大，如果每一个状态都去创建新的变量，时间复杂度是 O(N)O(N)。在候选数比较多的时候，在非叶子结点上创建新的状态变量的性能消耗就很严重。\n","date":"2021-10-23T21:05:28+08:00","permalink":"https://uest.xyz/posts/%E5%85%A8%E6%8E%92%E5%88%97matlab/","section":"posts","tags":null,"title":"全排列"},{"categories":null,"contents":"邮箱i@nb.ph岂不是很牛逼，如果主站和邮箱的域名都相同也方便记忆。\n虽然我不像某些人对邮箱域名非常敏感，特别是怎么有人会反感QQ邮箱啊，我觉得QQ邮箱绑定微信的推送很好啊，实时推送不香吗？非要Gmail有逼格上都上不去，非要超长的edu邮箱记不住，虽然腾讯可能活不到100年，但是哪家邮箱能存在100年呢，说不定被其他的通讯工具取代了呢。“越过长城，走向世界”这句话也仅仅发送了34年呐。根据邮箱来识人不可取，这也算是生活中的逻辑错误吧。\n言归正传，如何才能有i@xx.xxx的邮箱捏？首先，你得有个域名，这个可以去godaddy或者阿里云，腾讯云上申请，.xyz .top .moe价格也不贵,5-10￥/year。然后去dns解析商为你的邮箱服务器添加一条的MX记录就行了。\n邮箱服务器自己搭好像也行，但我没试过，哪天试试水一篇博客（等我啥时候有公网ip再说）。\n俺使用的是腾讯的域名邮箱，也就是QQ企业邮箱。\n(netease似乎也有http://app.ym.163.com/ym/reg/view/index)虽然没有企业，但也可以白嫖一个基础款。还要注册一个企业微信，然后设立一个公司（组织），这里你只需起一个名字就行，并不要你真的建个公司，做完以后，你就可以使用企业微信的所有服务了，管理1-50人的小团队了。（不知不觉中为企业微信引流）\n我已经注册就不演示了（借一张截图）最重要的一步当然是为你的域名邮箱添加mx解析了（这样别人才能根据你的域名找到邮箱服务器的ip地址）\n由于我一直用的是dnspods的解析，都是腾讯家的一键就完成了，dns记录秒生效。\n其他域名服务商需要手动设置\n 腾讯企业邮箱要求设置的MX记录如下： 邮件服务器名：mxbiz1.qq.com 优先级：5 邮件服务器名：mxbiz2.qq.com 优先级：10\n 之后就能自由地管理域名下的邮箱了。\n","date":"2021-10-14T09:05:28+08:00","permalink":"https://uest.xyz/posts/%E5%9F%9F%E5%90%8D%E9%82%AE%E7%AE%B1/","section":"posts","tags":null,"title":"如何拥有一个域名邮箱？"},{"categories":null,"contents":"今天尝试使用gdb调试，相比ide的调试没那么容易好上手\n对于一个cpp文件\n1g++ test.cpp -o test -g 记得一定要在编译时带-g参数，编译完成以后，使用gdb+生成可执行文件进行调试\nl可以查看需要 调试的文件\nb 4表示在第4行设置断点\nr程序就会运行到断点处\ndisplay i表示显示变量i的值\nn表示运行下一行\n基本的就到这里，剩下的就慢慢探索吧\n list/l 命令 可以使用list/l命令查看程序，方便我们添加断点时查看信息。  list+lineNumber(中间有空格) list 打印函数名称为Function的函数上下文的源程序 list 输出当前行后面的代码 list -显示当前行前面的代码\n run/r命令 在gdb中运行程序使用run命令.也可以设置程序运行参数。pwd命令用于显示当前所在目录。 break/b命令 break \u0026lt; function \u0026gt; 在进入指定的函数function时既停止运行，C++中可以使用class::function或function(type, type)格式来指定函数名称 break \u0026lt; lineNumber\u0026gt; 在指定的代码行打断点 break +offset/break -offset 在当前行的前面或后面的offset行打断点，offset为自然数 break filename:lineNumber 在名称为filename的文件中的第lineNumber行打断点 break filename:function 在名称为filename的文件中的function函数入口处打断点 break *address 在程序运行的内存地址处打断点 break 在下一条命令处停止运行 break … if \u0026lt; condition\u0026gt; 在处理某些循环体中可使用此方法进行调试，其中…可以是上述的break lineNumber、break +offset/break -offset中的参数，其中condition表示条件，在条件成立时程序即停止运行，如设置break if i=100表示当i为100时程序停止运行。 查看断点时，也可以使用info命令如info breakpoints [n]、info break [n]其中n 表示断点号来查看断点信息。 逐步调试命令 next \u0026lt; count\u0026gt;。单步跟踪，如果有函数调用不会进入函数，如果后面不加count表示一条一条的执行，加count表示执行后面的count条指令， step \u0026lt; count\u0026gt;。单步跟踪，如果有函数调用则进入该函数（进入该函数前提是此函数编译有Debug信息）,与next类似，其不加count表示一条一条执行，加上count表示自当前行开始执行count条代码指令 set step-mode.set step-mode on用于打开step-mode模式，这样在进行单步跟踪时，程序不会因为没有debug信息而不停止运行，这很有利于查看机器码，可以通过set step-mode off关闭step-mode模式 finish。运行程序直到当前函数完成并打印函数返回时的堆栈地址和返回值及参数值等信息。 until。运行程序直到退出循环体 stepi(缩写si)和nexti(缩写ni)。stepi和nexti用于单步跟踪一条及其指令，一条程序代码有可能由数条机器指令完成，stepi和nexi可以单步执行机器指令。 continue/c命令 当程序遇到断点停止运行后可以使用continue命令恢复程序的运行到下一个断点或直到程序结束。 print命令 请查看：https://blog.csdn.net/linuxheik/article/details/17380767 watch命令 watch命令一般来观察某个表达式(变量也可视为一种表达式)的值是否发生了变化，如果由变化则程序立即停止运行，其具体用法如下：  watch \u0026lt; expr\u0026gt; 为表达式(变量)expr设置一个观察点一旦其数值由变化，程序立即停止运行 rwatch \u0026lt; expr\u0026gt; 当表达式expr被读时，程序立即停止运行 awatch \u0026lt; expr\u0026gt; 当表达式expr的值被读或被写时程序立即停止运行 info watchpoints 列出当前所设置的所有观察点\n return命令 如果在函数中设置了调试断点，在断点后还有语句没有执行完，这个时候我们可以使用return命令强制函数忽略还没有执行的语句并返回。可以直接使用return命令用于取消当前函数的执行并立即返回函数值，也可以指定表达式如 return \u0026lt; expression\u0026gt;那么该表达式的值会被作为函数的返回值。 info命令 info命令可以用来在调试时查看寄存器、断点、观察点和信号等信息。其用法如下：  info registers:查看除了浮点寄存器以外的寄存器 info all-registers: 查看所有的寄存器包括浮点寄存器 info registers \u0026lt; registersName\u0026gt;:查看指定寄存器 info break: 查看所有断点信息 info watchpoints: 查看当前设置的所有观察点 info signals info handle: 查看有哪些信号正在被gdb检测 info line: 查看源代码在内存中的地址 info threads: 可以查看多线程\n finish命令 执行完当前的函数。  run(缩写r)和quit(缩写q)分别可以开始运行程序和退出gdb调试\nwhatis或ptype显示变量的类型\nbt显示函数调用路径 ———————————————— 版权声明：本文为CSDN博主「lyz_cs」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。 原文链接：https://blog.csdn.net/qq_26399665/article/details/81165684\n","date":"2021-09-28T15:35:49+08:00","permalink":"https://uest.xyz/posts/gdb%E8%B0%83%E8%AF%95/","section":"posts","tags":["gdb","C++"],"title":"Gdb调试"},{"categories":null,"contents":"  103. 二叉树的锯齿形层序遍历  难度中等525\n给定一个二叉树，返回其节点值的锯齿形层序遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。\n例如： 给定二叉树 [3,9,20,null,null,15,7],\n1 3 2 / \\ 3 9 20 4 / \\ 5 15 7 返回锯齿形层序遍历如下：\n1[ 2 [3], 3 [20,9], 4 [15,7] 5] 通过次数173,983\n提交次数304,411\n 这一题的坑还是非常多的，没有那么容易。最初想法是改一改层序遍历的代码就行了，想用一个队列完成，根据flag决定出队列的顺序。发现不行，因为队列是一遍增加一遍移出的。入上图当队列是[9 20]，从尾部移出得到20，9.看起来没错，但是在移出9时，又像队列的尾部增加了15和7，队列变成了[9 15 7]再移出尾部就错了。\n这是想通过双队列的方式，增加到新的队列中，在移出9时，[15 7]在下一个队列。看起来比较完美，一试又不对。试想移出9时插入[15 7] 再移出20时，插入了20的子节点（这里假设它有2个子节点 1 2），会发现倒序的里面，是左节点，右节点的顺序，很奇怪。此时又想过根据flag实现从右到左，但是这似乎让顺序直接变成倒叙的队列，下一行就不必改变出队列的顺序，一直倒序出就可以了。\n但是这种太麻烦，我最后还是用了顺序的bfs，但是根据flag的值，让输出的值取反，实现不对bfs的过程做出任何改变，较为简易。\n1class Solution { 2 public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; zigzagLevelOrder(TreeNode root) { 3 ArrayList\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; ans=new ArrayList\u0026lt;\u0026gt;(); 4 5 if(root==null) return ans; 6 LinkedList\u0026lt;TreeNode\u0026gt; queue=new LinkedList\u0026lt;\u0026gt;(); 7 LinkedList\u0026lt;TreeNode\u0026gt; queueNext=new LinkedList\u0026lt;\u0026gt;(); 8 LinkedList\u0026lt;TreeNode\u0026gt; queueCopy=new LinkedList\u0026lt;\u0026gt;(); 9 ArrayList\u0026lt;Integer\u0026gt; zigzag=new ArrayList\u0026lt;\u0026gt;(); 10 11 queue.add(root); 12 queueCopy.add(root); 13 int flag=1; 14 int cur=1; 15 int next=0; 16 17 18 zigzag=new ArrayList\u0026lt;\u0026gt;(); 19 while(!queue.isEmpty()\u0026amp;\u0026amp;!queueCopy.isEmpty()){ 20 TreeNode t=null; 21 TreeNode tcopy=null; 22 if(flag==1){t=queue.removeFirst();} 23 else if(flag==-1){t=queue.removeLast();} 24 tcopy=queueCopy.poll(); 25 zigzag.add(t.val); 26 27 28 29 cur--; 30 31 if(tcopy.left!=null){ 32 queueNext.add(tcopy.left); 33 next++; 34 } 35 if(tcopy.right!=null){ 36 queueNext.add(tcopy.right); 37 next++; 38 } 39 40 41 42 if(cur==0){ 43 ans.add(zigzag); 44 // System.out.println(queueNext); 45 zigzag=new ArrayList\u0026lt;\u0026gt;(); 46 flag=-flag; 47 queue=new LinkedList(queueNext); 48 queueCopy=new LinkedList(queueNext); 49 // 注意不能传地址：queue=queueNext 这样会使queue 和queueNext指向的是同一个地址 50 queueNext.clear(); 51 52 53 cur=next; 54 next=0; 55 56 } 57 } 58 59 return ans; 60 61 62 } 63} ","date":"2021-09-28T09:49:20+08:00","permalink":"https://uest.xyz/posts/103.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%94%AF%E9%BD%BF%E5%BD%A2%E9%81%8D%E5%8E%86/","section":"posts","tags":["Leetcode","Medium"],"title":"103. 二叉树的锯齿形层序遍历"},{"categories":null,"contents":"今天是辛丑年中秋节，古人选择每年月亮最圆的日子，作为节日来庆祝，并期冀着这一天假日能够团圆，吃月饼，赏明月，在我看来，中秋的节日氛围是仅次于春节的。\n苏东坡的《水调歌头》，算是中秋诗词的顶峰。我没多少文化，只能祝大家中秋节快乐。不像大师能写就\n“但愿人长久，千里共婵娟”这样的流传千古的名句。\n今天去了大熊猫基地，见到被关在一座山上的十几只大熊猫，享受着高于人类平均水平的生活条件。虽然大熊猫的算是萌物，也确实憨态可掬，确实珍贵。但却失去了自由。用自由换取活着的代价，然而被圈养的熊猫，还是原来的熊猫吗？随着人类居住生产范围的扩张和改造自然的能力的增强，野生动物生存环境逐步缩小。圈起来保护确实是最好的办法了。但是除了熊猫的其他野生动物就没有这么好的条件了。人类也没法对所有野生动物一视同仁，算是一种“偏见”吧。\n大熊猫基地的体验良好，没有特别地商业化，从地铁站到熊猫基地有专门的大巴接送，一路上都有人提醒戴好口罩，也没有多少坑钱的项目，两个小时就能全部逛完。总体上我是给好评的，是成都几个值得一去的好地方。\n没有长焦的手机拍不了月亮，所以今天晚上只能朋友圈赏月了。虽然月亮几乎天天能见到“何夜无月，何处无竹柏”，但是今天的月亮还是有些许特殊的。大家一同赏月，不是同一个地点 ，但是同一个世界，都希望能借助这轮明月，将自己的思念之情传达到远方。\n","date":"2021-09-21T23:35:19+08:00","permalink":"https://uest.xyz/posts/%E8%BE%9B%E4%B8%91%E4%B8%AD%E7%A7%8B%E8%8A%82/","section":"posts","tags":null,"title":"辛丑中秋节"},{"categories":null,"contents":"很久以前发现在浏览器里直接粘贴url就能自动下载码图提交的文件。而且是没有权限的，意味着你能下载到所有码图提交。而且对于请求次数也是没有限制的。\n比如在已经登录码图的浏览器中复制这个url：http://matu.uestc.edu.cn/aptat/file/downloadassignmentfile?assignmentid=1038358\n浏览器就会自动下载这个文件。\n这时候就有人好奇了，把assignmentid改成1038357会怎么样？会下载到另一个人的提交，这一个提交是在你之前的最近一个提交。\n最早的提交我看到id=72650，是2015年9月10号的提交，来自学号20140601xxxx的学长，题目是20_生成前n个自然数的一个随机置换。\n那么能不能把所有的码图提交都下载下来呢？只要借助一个叫Open multiple url at one click的chrome插件，将你所想要下载的码图文件url贴进去，chrome就会给你下载了。\n那么，假如我没有登录matu怎么办，或者我没有浏览器怎么办，又或是我能不能把码图的所有提交下载下来呢？\n那应该怎么做呢，码图会拦截没有登录的请求，这时就要用cookies骗过matu了，借助代理软件，可以看到\nget请求会带header，其中有cookie字段\n1Cookie:\tJSESSIONID=ADCFAD008D39D46910DB82255253AD2E; III_EXPT_FILE=aa48738; III_SESSION_ID=d55956838bd4bf7c44eae6dbedc5d20a; SESSION_LANGUAGE=eng; zg_did=%7B%22did%22%3A%20%221784dfce5e2433-04d99af797b1f2-5771133-fa000-1784dfce5e3d03%22%7D; zg_=%7B%22sid%22%3A%201625496021694%2C%22updated%22%3A%201625496021698%2C%22info%22%3A%201625496021697%2C%22superProperty%22%3A%20%22%7B%7D%22%2C%22platform%22%3A%20%22%7B%7D%22%2C%22utm%22%3A%20%22%7B%7D%22%2C%22referrerDomain%22%3A%20%22eportal.uestc.edu.cn%22%2C%22cuid%22%3A%20%222019081305013%22%2C%22zs%22%3A%200%2C%22sc%22%3A%200%2C%22firstScreen%22%3A%201625496021694%7D; iPlanetDirectoryPro=tH0Ds91VHf5CpQJkwG4p3v 只要在请求头加上这个字段，就可以骗过拦截器了。\n写了一个java程序\n1package matudownload; 2 3import com.sun.net.httpserver.Headers; 4import org.jsoup.Connection; 5import org.jsoup.Jsoup; 6import org.jsoup.nodes.Document; 7import org.jsoup.nodes.Element; 8 9import java.io.*; 10 11public class downLoad { 12 public static void download(String url,String filepath,String cookie)throws Exception { 13 14 Connection con=Jsoup.connect(url); 15 con.header(\u0026#34;Cookie\u0026#34;,cookie); 16 Connection.Response res=con.method(Connection.Method.GET).execute(); 17 18 String head=res.header(\u0026#34;content-disposition\u0026#34;); 19 String str=new String(head1.getBytes(\u0026#34;ISO-8859-1\u0026#34;),\u0026#34;GBK\u0026#34;); 20 //注意http请求的header要求其中文必须为iso8859-1编码，此时需要转化成gbk编码 21 str=str.toString().substring(21,str.length()-1); 22 23 BufferedWriter bw = new BufferedWriter 24 (new OutputStreamWriter(new FileOutputStream(filepath))); 25 bw.write(new String(res.body().toString())); 26 bw.flush(); 27 bw.close(); 28 } 29 30 public static void main(String[] args) { 31 try { 32 String cookie=\u0026#34;\u0026#34;; 33 //cookie需要你从已登陆matu的浏览器中获取 34 download(\u0026#34;http://matu.uestc.edu.cn/aptat/file/downloadassignmentfile?assignmentid=1038000\u0026#34;,\u0026#34;D:/download\u0026#34;,cookie); 35 } catch (Exception e) { 36 e.printStackTrace(); 37 } 38 } 39} 40 我在github仓库上传了1038000-1038530的530个提交，大家可以参考别人的matu提交代码互相学习。\nhttps://github.com/BachWV/matu/tree/main/allMatuCommit\n至于部分码图考试能不能用这种方法抄到别人的提交，我不知道，也希望码图早日把这个漏洞给补上。\n","date":"2021-09-20T15:57:28+08:00","permalink":"https://uest.xyz/posts/%E6%80%8E%E4%B9%88%E6%9C%89%E4%BA%BA%E7%94%A8%E7%A0%81%E5%9B%BE%E5%95%8A/","section":"posts","tags":null,"title":"怎么有人用码图啊"},{"categories":["算法"],"contents":"一个二进制数中有多少个1 我只能想到用移位消去最小的1的方法\n时间复杂度为i中1的个数的做法 1 public int hammingWeight(int n) { 2int ans=0; 3 while(n!=0){ 4 5 ans++; 6 n=n\u0026amp;(n-1); 7 8 } 9 return ans; 10 } java 本身也提供了这个方法，所以就来看看底层的源码。 这个方法非常有意思，我已经被迷住了，源码的分析部分来自于\nhttps://blog.csdn.net/weixin_42092787/article/details/106607426\n1public static int bitCount(int i) { 2 // HD, Figure 5-2 3 i = i - ((i \u0026gt;\u0026gt;\u0026gt; 1) \u0026amp; 0x55555555); 4 i = (i \u0026amp; 0x33333333) + ((i \u0026gt;\u0026gt;\u0026gt; 2) \u0026amp; 0x33333333); 5 i = (i + (i \u0026gt;\u0026gt;\u0026gt; 4)) \u0026amp; 0x0f0f0f0f; 6 i = i + (i \u0026gt;\u0026gt;\u0026gt; 8); 7 i = i + (i \u0026gt;\u0026gt;\u0026gt; 16); 8 return i \u0026amp; 0x3f; 9} 简单来说，源码非常非常巧妙的利用了 位运算的性质，大概我这辈子也想不到吧。\n我们从最后的落脚点出发，或许更能理解这种思路：\nreturn i \u0026amp; 0x3f; 0x3f 十六进制转为二进制是：\n十六进制\t二进制 0x3f\t00 00 00 00 00 00 00 00 00 00 00 00 00 11 11 11 这时候我们想一下这行代码，对于 0x3f 来说，它和变量 i 做 与 运算，得到的最大结果也就是 0x3f 本身，也就是二进制 111111 ，对应 十进制是 63。\n这是什么意思呢？\n对于 输入 n ，即使这个数字的二进制表达占满了 32 位比特 且全都是 1，那么这条语句的功能，数 1 的个数，结果最多也就是 32 ，对应二进制表达是 100 000，长度为 6 位。\n所以这一点上，这种方法的计算过程保证了有效位足够，另一方面保证，最终返回的是 前面计算结果的最后六位的值，去掉了高位上面的干扰。\n而这整个代码也都是基于这种思想的，逐渐缩小有效位的范围\n我们先总结一下代码中的十六进制数：\n十六进制\t二进制 0x55555555\t01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 0x33333333\t00 11 00 11 00 11 00 11 00 11 00 11 00 11 00 11 0x0f0f0f0f\t00 00 11 11 00 00 11 11 00 00 11 11 00 00 11 11 接着一行一行来看代码。\n第一行代码 i = i - ((i \u0026gt;\u0026gt;\u0026gt; 1) \u0026amp; 0x55555555); 我直接告诉你，它完成的功能叫做，每两位进行一次统计，统计 1 的个数，并把结果放在对应的原来位置上。\n1. i \u0026raquo;\u0026gt; 1 是将 i 无符号右移一位 2. 0x55555555 是 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 3. 右移后 和 0x55555555 进行按位与操作 4.再用 i 减去 “3” 的结果 上面的 “1” 想一想：对于一个 32 位的数 i ，右移一位之后，第 2、4、6、……、32位的数字，分别跑到了第 1、3、5、……、31位上，也就对应到了 0x55555555 的 所有 1 的位置。\n上面的 “2” 和 “3” i 在右移之后和 0x55555555 进行 与 操作，就会得到原来 i 的第 2、4、6、……、32 位上的所有真实的值；同时，第 1、3、5、……、31位上的值都和 0 进行与操作之后变成了0。（到这里还看不出这么做的意义，别着急，看下一步）\n上面的 “3” 重点来了，接着用 i - （2 和 3 的结果）会发生什么事？\n一个二进制两位的数字，可能的形式有：00,01,10,11. 右移之后分别和 01 进行与运算，得到： 00,00,01,01. 用原来的数减去右移后的，就能够得到： 00,01,01,10.\n观察一下结果可以发现：每两位的数值 就表示了以前这两位上 有 1 的个数\n（这里可以回头想一想，先和0x55555555 进行 与 操作是非常必要的，因为如果仅仅右移，第 3 位如果有 1，右移之后会占用第二位，会影响统计结果，因此必须把这些位都通过和 0 的与操作清零。）\n第二行代码 i = (i \u0026amp; 0x33333333) + ((i \u0026gt;\u0026gt;\u0026gt; 2) \u0026amp; 0x33333333); 第二行和第一行的本质思路是一样的，进一步扩大范围，统计原始 i 每 4 位上 1 的个数。\n1. 0x33333333 是 00 11 00 11 00 11 00 11 00 11 00 11 00 11 00 11 2. i 和 0x33333333 进行按位与操作 3. i 右移两位，再和 0x33333333 进行按位与操作 4.将 “ 2 ” 和 “ 3 ” 的结果相加 上面的 “1” 和 “2” 和 0x33333333 进行 与 操作，就会得到第一行代码运行之后 的第 1 2、5 6、9 10、……、29 30 位上的所有真实的值；同时，第 3 4、7 8、11 12、……、31 32位上的值都和 00 与之后变成了00。\n上面的 “3” 和只有 两位 的二进制数的减法性质不同，所以这里不能再使用减法。 那么丢掉的那一半位置的数字还是需要找回来的。怎么办呢\ni 右移两位，第 3 4、7 8、11 12、……、 31 32 位上的值跑到了 第 1 2、5 6、9 10、……、 29 30位上。此时再做了一边和 “2” 一样的事情，这就得到了第一行代码运行之后的第 3 4、7 8、11 12、……、 31 32 位上的真实的值。\n上面的 “4” 简单相加，功能完成。（直接相加不用考虑进位吗？答案是不用，原来的数字 每四位上面 1 的个数最多是 4 个，对应成二进制是 100 ，只会占用 3 个二进制位。）\n可以回头想想。源数字 i 的 每四位上面 1 的个数，已经被统计出来了，替换在了对应的位置上。\n第三行代码  i = (i + (i \u0026gt;\u0026gt;\u0026gt; 4)) \u0026amp; 0x0f0f0f0f; 这一步，要开始统计 原始数字 i 每 8 位上面 1 的个数。我们可以看到代码的方式又变了。 （和第二行写法不一样，但其实第三行可以写成和第二行一样的格式；第二行却不能写成第三行这样的形式，大家可以想想为什么）\n1. 将 i 右移四位，再与 i 相加 2.0x0f0f0f0f 的二进制表达是 0000 1111 0000 1111 0000 1111 0000 1111 3.将第一步的结果 和 0x0f0f0f0f 进行与操作 上面的 “1” 对其相加个数的时候，显然要以低位为准，所以第 5 6 7 8 、13 14 15 16、20 21 23 24、29 30 31 32 位的数字，挪到了 1 2 3 4 、 9 10 11 12、17 18 19 20 、25 26 27 28 位上，对应相加。\n这里的加和，最多不会超过 8 ，对应二进制是 1000，（因为源数字 i 每 8 位上面 1 个数不会超过 8）所以直接加也不会产生错误。\n上面的 “2” 和“3” 和 0x0f0f0f0f 进行 与 操作，就会得到源数字 i 每 8 位上面 1 的个数，存储在了第 1 2 3 4 、 9 10 11 12、17 18 19 20 、25 26 27 28位上。而第 5 6 7 8 、13 14 15 16、20 21 23 24、29 30 31 32 位一定是 0.\n第四行和第五行代码\n1i = i + (i \u0026gt;\u0026gt;\u0026gt; 8); 2i = i + (i \u0026gt;\u0026gt;\u0026gt; 16); 这两行，完成的是一个功能，也就是把源数字 i 每 16 位上面 1 的个数，存储在了 1~16位上。（此时没有做第17~32位的清零）\n当然，如果按照前几步的思路，你当然可以把这两行代码替换成：\ni = i + (i \u0026gt;\u0026gt;\u0026gt; 8) \u0026amp; ‭FF00FF‬; 这行是我想的，但经过验证可以达到一样的效果，因为 ‭FF00FF‬ 的二进制表达是： ‭0000 0000 1111 1111 0000 0000 1111 1111‬\n不过显然原作者的做法更巧妙，毕竟直接右移16位就能达到效果。\n第六行代码 return i \u0026amp; 0x3f; 回到最开始我们对这一步的分析，源数字 i 作为32位二进制数字，1 的个数就最多 32 而已。\n那么代码的意义显而意见。 最终就会返回 原始输入 i 的二进制形式上 1 的个数。\n总结一下，如果这道题交给我们来做，即使是位运算，按位与 和 用了 n\u0026amp;(n-1) 这两种方法，最差的情况下都是要运行 32 次位运算的，但是底层源码的方法，却是恒定只进行 6 次计算。不得不说真实优秀。\n相信我讲的很清楚了，希望对大家有帮助。（苦心成果，转载请标明出处 ———————————————— 版权声明：本文为CSDN博主「JohnArchie」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。 原文链接：https://blog.csdn.net/weixin_42092787/article/details/106607426\n我的理解 第一行代码：将每两位的 1 的个数统计，并把结果每两位保存，例如1101一个有3个1，高2位(11)中1的个数为2(01)，低2位(01)的个数为1(01),最后保存的结果为0101 i=0010010100101011\n0001001010010101 (i\u0026raquo;\u0026gt;1)\n0001000000010101(i\u0026raquo;\u0026gt;1\u0026amp;0x5555555)\n0001010100010110\n第二行代码：将将每4位的 1 的个数统计，并把结果每4位保存\n0001010100010110(i)\n0000010101000101(i\u0026raquo;\u0026gt;2)\n0011001100110011\n0000000100000001(i\u0026raquo;\u0026gt;2\u0026amp;0x3333333333)\n0001000100010010(i\u0026amp;0x333333333)\n0001001000010011\n相当于对i=0001010100010110每隔两位提出来：\n0001000100010010(i\u0026amp;0x333333333)\n0001001000010011\n每4位得到四位 的1的值\n第三行代码：将将每8位的 1 的个数统计，并把结果每8位保存\n0000111100001111\n0000001100000100\n每8位表示8位 的1的数量\n0000000000000011(i\u0026raquo;\u0026gt;8)\n0000000000000100\n0000000000000111\n这样就得到一共有7个1.\n异或的性质： 110=100^10\n观察这三个数110 100 10\n任意两个异或的结果是另外一个数：\n110^100=10\n110^10=100\n 1720. 解码异或后的数组 难度简单80\n未知 整数数组 arr 由 n 个非负整数组成。\n经编码后变为长度为 n - 1 的另一个整数数组 encoded ，其中 encoded[i] = arr[i] XOR arr[i + 1] 。例如，arr = [1,0,2,1] 经编码后得到 encoded = [1,2,3] 。\n给你编码后的数组 encoded 和原数组 arr 的第一个元素 first（arr[0]）。\n请解码返回原数组 arr 。可以证明答案存在并且是唯一的。\n示例 1：\n1输入：encoded = [1,2,3], first = 1 2输出：[1,0,2,1] 3解释：若 arr = [1,0,2,1] ，那么 first = 1 且 encoded = [1 XOR 0, 0 XOR 2, 2 XOR 1] = [1,2,3] 示例 2：\n1输入：encoded = [6,2,7,3], first = 4 2输出：[4,2,0,7,4] 提示：\n 2 \u0026lt;= n \u0026lt;= 104 encoded.length == n - 1 0 \u0026lt;= encoded[i] \u0026lt;= 105 0 \u0026lt;= first \u0026lt;= 105   1class Solution { 2 public int[] decode(int[] encoded, int first) { 3 int n=encoded.length; 4 int []ans=new int[n+1]; 5 ans[0]=first; 6 for(int i=1;i\u0026lt;n+1;i++){ 7 ans[i]=encoded[i-1]^ans[i-1]; 8 9 } 10 11return ans; 12 } 13} 还有一题：\n 371. 两整数之和 难度中等425\n不使用运算符 + 和 - ，计算两整数 a 、b 之和。\n示例 1:\n1输入: a = 1, b = 2 2输出: 3 示例 2:\n1输入: a = -2, b = 3 2输出: 1 通过次数54,177\n提交次数93,386\n 1class Solution { 2 public int getSum(int a, int b) { 3 System.out.println(a+\u0026#34; b=\u0026#34;+b); 4 int xor=a^b; 5 int and=(a\u0026amp;b)\u0026lt;\u0026lt;1; 6 System.out.println(and); 7 if(and!=0) xor=getSum(xor,and); 8 9 return xor; 10 11 12 } 13} ","date":"2021-09-13T20:56:00+08:00","permalink":"https://uest.xyz/posts/%E5%A4%9A%E5%B0%91%E4%B8%AA1/","section":"posts","tags":null,"title":"多少个1"},{"categories":null,"contents":"11. 盛最多水的容器  给你 n 个非负整数 a1，a2，...，a``n，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0) 。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。\n**说明：**你不能倾斜容器。\n示例 1：\n1输入：[1,8,6,2,5,4,8,3,7] 2输出：49 3解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。 示例 2：\n1输入：height = [1,1] 2输出：1 示例 3：\n1输入：height = [4,3,2,1,4] 2输出：16 示例 4：\n1输入：height = [1,2,1] 2输出：2 提示：\n n == height.length 2 \u0026lt;= n \u0026lt;= 105 0 \u0026lt;= height[i] \u0026lt;= 104   这一题的证明还不是特别理解。给出的题解使用了双指针法。\n核心思想是两个指针向中间缩小，规则是只缩小水桶的最小的板。\n1class Solution { 2 public int maxArea(int[] height) { 3 int l=0,r=height.length-1,ans=0; 4 while(l\u0026lt;r){ 5 int temp=0; 6 if(height[l]\u0026gt;height[r]){ 7 8 temp=(r-l)*height[r]; 9 r--; 10 }else{ 11 12 temp=(r-l)*height[l]; 13 l++; 14 } 15 System.out.println(temp); 16 ans=Math.max(temp,ans); 17 } 18 return ans; 19 } 20} 证明过程没怎么看懂：\n 若暴力枚举，水槽两板围成面积 S(i, j)S(i,j) 的状态总数为 C(n, 2)C(n,2) 。\n假设状态 S(i, j)S(i,j) 下 h[i] \u0026lt; h[j]h[i]\u0026lt;h[j] ，在向内移动短板至 S(i + 1, j)S(i+1,j) ，则相当于消去了 {S(i, j - 1), S(i, j - 2), \u0026hellip; , S(i, i + 1)}S(i,j−1),S(i,j−2),\u0026hellip;,S(i,i+1) 状态集合。而所有消去状态的面积一定都小于当前面积（即 \u0026lt; S(i, j)\u0026lt;S(i,j)），因为这些状态：\n短板高度：相比 S(i, j)S(i,j) 相同或更短（即 ≤h[i] ）； 底边宽度：相比 S(i, j)S(i,j) 更短； 因此，每轮向内移动短板，所有消去的状态都 不会导致面积最大值丢失 ，证毕。\n作者：jyd 链接：https://leetcode-cn.com/problems/container-with-most-water/solution/container-with-most-water-shuang-zhi-zhen-fa-yi-do/ 来源：力扣（LeetCode） 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n 我的理解是，只比较S(i,j)的大的，然后证明舍去的状态比ans里面存的要小。\n","date":"2021-09-10T18:06:12+08:00","permalink":"https://uest.xyz/posts/11/","section":"posts","tags":["Leetcode","Medium"],"title":"11.盛水最多的容器"},{"categories":null,"contents":"UESTC 大三狗，爱好各种手机，果吹，MIUI喷，雷军粉，嘉心糖\n日常逛B站，逛河畔，水群，睡大觉\n不会数学，不会编程，不会java，不会c++，不会python，不会go，不会kotlin，不会pascal，不会汇编，不会开关机\n别问，问就是不会\n人生目标是环游中国，看雪山\n酷安潜水id 立人楼的挖掘机\nGithub: https://github.com/BachWV\nbilibili: https://space.bilibili.com/36175480\n微信公众号: 一行瑠璃 ","date":"2021-09-09T22:12:07+08:00","permalink":"https://uest.xyz/about/","section":"","tags":null,"title":"About"},{"categories":["tech"],"contents":"弄了快半年的黑群晖，感觉太难受了，处处受限，想来一个花生壳内网穿透都不行，zerotie没效果，放在docker里也不行，索性放弃，直接咸鱼15块洗白。\n速速开始改sn/mac吧\n1 开放SSH端口 在群晖上操作：控制面板里面——\u0026gt;终端机和SNMP 下，启动SSH功能。端口为22\n2 SSH连接 随便用一个ssh软件连接你的群晖，我一般使用bitvise\nip就是你的群晖的局域网ip，我的是192.168.31.95\n用户名密码就是平时登录的密码(我用admin账户登录的)\n3 cli修改sn/mac   提权 sudo -i ：再次输入当前账号的密码\n  在/tmp 目录下创建临时目录 名字随便起 比如boot mkdir -p /tmp/boot\n  切换到dev目录，挂载引导分区到boot mount -t vfat synoboot1 /tmp/boot/\n  挂载成功以后，切换到/tmp/boot目录，ls以后发现有一个文件夹叫grub\n我们需要修改的就是grub.cfg文件\n看到那个sn和mac了吗，这就是我们目的要改的东西，改成洗白以后的号码，:wq完成！\n  4 重启 最后一步：reboot 然后耐心等待即可！\n使用Sysnology assistant重新搜索，即可看到改成了刚才的sn和mac，一般来说不要重新搜索也能用\n之后就可以愉快使用群晖官方服务的了，建议用非国区的账号哦\n参考资料：\nhttps://shimo.im/docs/KwwyWvkqJTrQvhvg/read\n","date":"2021-09-09T21:58:12+08:00","permalink":"https://uest.xyz/posts/%E4%BB%8E%E9%BB%91%E7%BE%A4%E6%99%96%E8%B5%B0%E5%90%91%E7%99%BD/","section":"posts","tags":null,"title":"从黑群晖走向白"},{"categories":["随笔"],"contents":"不安全感 今天出门，终于不要检查寝室门是否锁上了。很奇怪，我一直有个强迫症，就是出门一定要检查门是否关好，几乎每次出门不自然地来回检查几次，有时候下了楼，不放心，还跑上去检查一遍。有时候出门半天才想起来是不是还没检查我门关没关，而次次检查的结果是，门，它确实关好了。在我的印象中，没有一次检查出门没关。但是不检查，门就处于薛定谔状态，关和没关的叠加态。只有当我回去观察，才是确定的状态。\n门，是个防君子不防小人的物件。小偷真的盯上你，门根本没用，我家在5楼都曾经有小偷翻窗进入。而当小偷遇上一扇没关的门，它想尝试还得掂量掂量，万一家里有人怎么办，万一有摄像头，万一里面人躲着专门针对小偷。再说小偷根本不知道你家门没关，小偷又不会扫楼。所以在门没关的状态下，只有邻居熟人作案，而且只有比我高的邻居6楼邻居和对门，一共3户，东西丢了也好找，邻居冒着这么大的风险作案也不值得。\n所以，当没关门的概率乘上3户邻居敢进入我加偷东西的概率，是一个很小很小很小的数，这还没算上找回没损失的概率。\n但我还是担心没关上门，就好像一个诅咒，一直把我圈在里面。\n我会想到小学5、6年级的时候，那时候我出门一定会检查我书包会不会有书没带。快到学校了，把书包放地上打开看看书在不在，和课程表对一下，有没有没带的。\n没带又怎么样呢，回家拿就是喽，5年级的时候，从小学回个家也就5分钟，课间时间足够了，就算课上没书，还可以找隔壁班同学借啊，最坏的结果就是和同桌一起看呗，没有老师闲的会因为没书喊我家长让我罚站吧。最坏最坏的结果，不就是罚站嘛，谁还没站过捏。\n这一切现象，我给自己定义为缺少安全感。有的时候做事我会思考一切可能的结果，包括最坏的，即使是一件很简单的事情，最近我一直担心我晚上会嗝屁，担心熬夜心梗猝死，担心狂犬病。怎么说呢，总结的话就是不安全感，害怕事情变得糟糕，恐惧悲惨的结果。感觉现在的不安全感稍微少点了，但是又有点害怕自己得各种奇怪的病，看来是走不出这个诅咒了。\n","date":"2021-08-31T20:06:45+08:00","permalink":"https://uest.xyz/posts/%E4%B8%8D%E5%AE%89%E5%85%A8%E6%84%9F/","section":"posts","tags":null,"title":"不安全感"},{"categories":null,"contents":"1567. 乘积为正数的最长子数组长度\n 难度中等\n给你一个整数数组 nums ，请你求出乘积为正数的最长子数组的长度。\n一个数组的子数组是由原数组中零个或者更多个连续数字组成的数组。\n请你返回乘积为正数的最长子数组长度。\n示例 1：\n1输入：nums = [1,-2,-3,4] 2输出：4 3解释：数组本身乘积就是正数，值为 24 。 示例 2：\n1输入：nums = [0,1,-2,-3,-4] 2输出：3 3解释：最长乘积为正数的子数组为 [1,-2,-3] ，乘积为 6 。 4注意，我们不能把 0 也包括到子数组中，因为这样乘积为 0 ，不是正数。 示例 3：\n1输入：nums = [-1,-2,-3,0,1] 2输出：2 3解释：乘积为正数的最长子数组是 [-1,-2] 或者 [-2,-3] 。 示例 4：\n1输入：nums = [-1,2] 2输出：1 示例 5：\n1输入：nums = [1,2,3,5,-6,4,0,10] 2输出：4 提示：\n 1 \u0026lt;= nums.length \u0026lt;= 10^5 -10^9 \u0026lt;= nums[i] \u0026lt;= 10^9   把数组想成1，0，-1三个数组成的，0是分隔数组的标志，\n比如1 1 1 -1 0 1 1 1 0 1 1，可以分成3块，1 1 1 -1；1 1 1；1 1\n下面在每一块中套圈，规定圈中的-1的个数为偶数；\n从第一个数开始套，遇到-1将flag取反，每前进一步length加1，将flag为正的length记录下来，遇到0重置。\n有人可能会问为什么总是从第一个数开始套，万一第一个数字是负数-1 1 1 1怎么办呢？用我的算法会计算成0，可是实际上是3，结果根本不对。\n没事，咱们从后往前遍历一次就行了，-1 1 1 1从后往前数，最大子数组长度不就是3了嘛。\n这样能覆盖所有情况吗？\n对于每块来说，只有偶数个-1 ，奇数个-1两种情况；偶数个-1自然是皆大欢喜，这一块全部算上；奇数个-1就得想一想了：\n1 1 1 -1 1 1 1 1 一眼看出，-1把数组分成两半，左边数组最长为3，右边为4；如果从左边第一个开始遍历答案为3，从右边遍历最大为4，取两次遍历的最大值4即可。\n1 1 1 1 1 -1 1 1 1 -2 1 1 -3 1 1 1对于3 个负数来说的来说，最长的子数组会取-3左边所有数字，或者-1右边的所有数字，是不是从左向右遍历和从右向左遍历两遍就行了呢？\n代码：\n1 public int getMaxLen(int[] nums) { 2 int ans=0,lenth=0,flag=1; 3 for(int i=0;i\u0026lt;nums.length;i++){//从左向右遍历 4 if(nums[i]\u0026lt;0){ 5 lenth++; 6 flag*=-1; 7 }else if(nums[i]==0){ 8 lenth=0; 9 flag=1; 10 }else lenth++; 11 if(flag==1) ans=Math.max(ans,lenth); 12 } 13 int anstemp=ans; 14 ans=0;lenth=0;flag=1; 15 for(int i=nums.length-1;i\u0026gt;=0;i--){//从右向左遍历 16 if(nums[i]\u0026lt;0){ 17 lenth++; 18 flag*=-1; 19 }else if(nums[i]==0){ 20 lenth=0; 21 flag=1; 22 }else lenth++; 23 if(flag==1){ans=Math.max(ans,lenth);} 24 } 25 return Math.max(anstemp,ans); 26 } ","date":"2021-08-24T21:03:42+08:00","permalink":"https://uest.xyz/posts/1567%E4%B9%98%E7%A7%AF%E4%B8%BA%E6%AD%A3%E6%95%B0%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E6%95%B0%E7%BB%84/","section":"posts","tags":["Leetcode","Medium"],"title":"1567.乘积为正数的最长子数组"},{"categories":null,"contents":"740. 删除并获得点数\n 给你一个整数数组 nums ，你可以对它进行一些操作。\n每次操作中，选择任意一个 nums[i] ，删除它并获得 nums[i] 的点数。之后，你必须删除 所有 等于 nums[i] - 1 和 nums[i] + 1 的元素。\n开始你拥有 0 个点数。返回你能通过这些操作获得的最大点数。\n示例 1：\n1输入：nums = [3,4,2] 2输出：6 3解释： 4删除 4 获得 4 个点数，因此 3 也被删除。 5之后，删除 2 获得 2 个点数。总共获得 6 个点数。 示例 2：\n1输入：nums = [2,2,3,3,3,4] 2输出：9 3解释： 4删除 3 获得 3 个点数，接着要删除两个 2 和 4 。 5之后，再次删除 3 获得 3 个点数，再次删除 3 获得 3 个点数。 6总共获得 9 个点数。 提示：\n 1 \u0026lt;= nums.length \u0026lt;= 2 * 104 1 \u0026lt;= nums[i] \u0026lt;= 104   这一题很迷惑人，什么“每次操作中，选择任意一个 nums[i] ，删除它并获得 nums[i] 的点数。之后，你必须删除 所有 等于 nums[i] - 1 和 nums[i] + 1 的元素。”这都是些什么鬼操作。绕了我那么久，实际上就是打家劫舍。\n不能连着获得两个挨着的点数。\n打家劫舍中，挨着的是数组，nums[1]和nums[2]不能同时存在；这一题中，nums[x]+1和nums[x]不能同时存在，怎么办呢？\n可以把点数映射到另一个数组中，比如 1 1 3 3 3 4 6 8 8 10这9个数，稍微处理一下\n   值 1 2 3 4 5 6 7 8 9 10     个数 2 0 3 1 0 1 0 2 0 1    这样就变成了打家劫舍的题目了，不能同时存在相邻的值\ndp[i]=Math.max(dp[i-2]+a[i]*i,dp[i-3]+a[i]*i);\n1 public static int deleteAndEarn(int[] nums) { 2 if (nums == null || nums.length == 0) { 3 return 0; 4 } else if (nums.length == 1) { 5 return nums[0]; 6 }else if(nums.length==2){ 7 if(nums[1]==nums[0]){ 8 return 2*nums[0]; 9 }else if(nums[0]-nums[1]==1||nums[0]-nums[1]==-1){ 10 return Math.max(nums[1],nums[0]); 11 } 12 return nums[1]+nums[0]; 13 14 } 15 Arrays.sort(nums); 16 int n=nums.length; 17 int maxnum=nums[n-1]; 18 int []a=new int[maxnum+1]; 19 20 21 for(int i=0;i\u0026lt;n;i++){ 22 23 24 a[nums[i]]++; 25 } 26 int []dp=new int[maxnum+1]; 27 System.out.println(Arrays.toString(a)); 28 dp[1]=a[1]*1; 29 dp[2]=a[2]*2; 30 dp[3]=a[3]*3+dp[1]; 31 for(int i=3;i\u0026lt;=maxnum;i++){ 32 33 dp[i]=Math.max(dp[i-2]+a[i]*i,dp[i-3]+a[i]*i); 34 35 } 36 System.out.println(Arrays.toString(dp)); 37 return Math.max(dp[maxnum-1],dp[maxnum]); 38 39 } ","date":"2021-08-23T19:39:21+08:00","permalink":"https://uest.xyz/posts/740.%E5%88%A0%E9%99%A4%E5%B9%B6%E8%8E%B7%E5%BE%97%E7%82%B9%E6%95%B0/","section":"posts","tags":["Leetcode","Medium"],"title":"740.删除并获得点数"},{"categories":null,"contents":"1329. 将矩阵按对角线排序 矩阵对角线 是一条从矩阵最上面行或者最左侧列中的某个元素开始的对角线，沿右下方向一直到矩阵末尾的元素。例如，矩阵 mat 有 6 行 3 列，从 mat[2][0] 开始的 矩阵对角线 将会经过 mat[2][0]、mat[3][1] 和 mat[4][2] 。\n给你一个 m * n 的整数矩阵 mat ，请你将同一条 矩阵对角线 上的元素按升序排序后，返回排好序的矩阵。\n示例 1：\n1输入：mat = [[3,3,1,1],[2,2,1,2],[1,1,1,2]] 2输出：[[1,1,1,1],[1,2,2,2],[1,2,3,3]] 示例 2：\n1输入：mat = [[11,25,66,1,69,7],[23,55,17,45,15,52],[75,31,36,44,58,8],[22,27,33,25,68,4],[84,28,14,11,5,50]] 2输出：[[5,17,4,1,52,7],[11,11,25,45,8,69],[14,23,25,44,58,15],[22,27,31,36,50,66],[84,28,75,33,55,68]] 提示：\n m == mat.length n == mat[i].length 1 \u0026lt;= m, n \u0026lt;= 100 1 \u0026lt;= mat[i][j] \u0026lt;= 100  普通题，但是耗时太久.\n思路就是按照提示找到同一斜边的元素，arraylist排序，写回去。\n问题在于找到同一斜边的元素，注意边界。我将遍历过程分成两段，分别是下三角和上三角，利用mat[i][j]的条件i\u0026lt;m\u0026amp;\u0026amp;j\u0026lt;n来控制边界。\n1 public static int[][] diagonalSort(int[][] mat) { 2 int m=mat.length; 3 // System.out.println(m); 4 int n=mat[0].length; 5 //System.out.println(n); 6 if(m==1|n==1) return mat; 7 for(int i=m-1;i\u0026gt;=0;i--){ 8 ArrayList\u0026lt;Integer\u0026gt; s=new ArrayList\u0026lt;Integer\u0026gt;(); 9 for(int j=0;i+j\u0026lt;m\u0026amp;\u0026amp;j\u0026lt;n;j++){ 10 s.add(mat[i+j][j]); 11 } 12 // System.out.println(s); 13 s.sort(Comparator.naturalOrder()); 14 //System.out.println(s); 15 for(int j=0;i+j\u0026lt;m\u0026amp;\u0026amp;j\u0026lt;n;j++){ 16 mat[i+j][j]=s.get(j); 17 } 18 } 19 System.out.println(\u0026#34;-----------------\u0026#34;); 20 for(int i=0;i\u0026lt;n+1;i++){ 21 ArrayList\u0026lt;Integer\u0026gt; s=new ArrayList\u0026lt;Integer\u0026gt;(); 22 int i2=0; 23 for(int j=i+1;(j\u0026lt;n)\u0026amp;\u0026amp;(i2\u0026lt;m);j++,i2++){ 24 // System.out.println(\u0026#34;i2=\u0026#34;+i2+\u0026#34; j=\u0026#34;+j); 25 s.add(mat[i2][j]); 26 27 } 28 // System.out.println(s); 29 s.sort(Comparator.naturalOrder()); 30 // System.out.println(s); 31 i2=0; 32 for(int j=i+1;(j\u0026lt;n)\u0026amp;\u0026amp;(i2\u0026lt;m);j++,i2++){ 33 //System.out.println(\u0026#34;i2=\u0026#34;+i2+\u0026#34; j=\u0026#34;+j); 34 mat[i2][j]=s.get(i2); 35 36 } 37 } 38 39 return mat; 40 } 看了题解，所有的同一斜边的元素有一个共同特征：i和j的差为定值，也就是说，给定i，j唯一确定是哪一条对角线，一共m+n-1个对角线，创建m+n-1个arraylist。\n对每一条对角线上的元素进行排序。\n填回去的操作：按照从左到右，从上往下遍历时，每次都是最小的在前，可以另外用一个数组保存，或者也可以将arraylist转成栈，按次序填回去的数一定是从小到大的。\n别人的code:\n1public int[][] diagonalSort(int[][] mat) { 2 // 行数 3 int m = mat.length; 4 // 列数 5 int n = mat[0].length; 6 // 主对角线的条数 7 int dLen = m + n - 1; 8 9 // 每一条对角线都创建一个动态数组 10 ArrayList\u0026lt;Integer\u0026gt;[] diagonal = new ArrayList[dLen]; 11 for (int i = 0; i \u0026lt; dLen; i++) { 12 diagonal[i] = new ArrayList\u0026lt;\u0026gt;(m); 13 } 14 15 // 遍历原始矩阵，把原始矩阵中的元素放进对应的动态数组中 16 // 主对角线上元素的特点是：纵坐标 - 横坐标 = 定值 17 // 加上偏移 m - 1 是为了能够放进数组中 18 for (int i = 0; i \u0026lt; m; i++) { 19 for (int j = 0; j \u0026lt; n; j++) { 20 diagonal[j - i + (m - 1)].add(mat[i][j]); 21 } 22 } 23 24 // 对每一个对角线上的动态数组分别进行升序排序 25 for (int i = 0; i \u0026lt; dLen; i++) { 26 Collections.sort(diagonal[i]); 27 } 28 29 int[][] res = new int[m][n]; 30 31 // 对角线数组上还未取出的元素的下标，初始化的时候均为 0 32 int[] next = new int[dLen]; 33 for (int i = 0; i \u0026lt; m; i++) { 34 for (int j = 0; j \u0026lt; n; j++) { 35 // 对角线的坐标 36 int index = j - i + (m - 1); 37 // 记录结果 38 res[i][j] = diagonal[index].get(next[index]); 39 // 维护 next 数组的值 40 next[index]++; 41 } 42 } 43 return res; 44 } 45 46作者：Code_respect 47链接：https://leetcode-cn.com/problems/sort-the-matrix-diagonally/solution/javati-jie-by-code_respect-66zw/ 48来源：力扣（LeetCode） 49著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 ","date":"2021-08-12T16:19:27+08:00","permalink":"https://uest.xyz/posts/1329%E5%B0%86%E7%9F%A9%E9%98%B5%E6%8C%89%E5%AF%B9%E8%A7%92%E7%BA%BF%E6%8E%92%E5%BA%8F/","section":"posts","tags":["Leetcode","Medium"],"title":"1329.将矩阵按对角线排序"},{"categories":null,"contents":"东哥 首先是东哥，一个啥手机都有的神，从经典iPhone SE 到机皇 Samsung Galaxy Note 10+ ,再到爵士Huawei Mate 30 Pro ，还有守门员小米10 ，大清亡了的一加7Pro, 以及东哥新宠 iPhone 13 mini。无论是配备M1的iPad Pro Cellular 256GB with 2 years Apple Care+，还是Pixel C。数不清的数码产品东哥这里应有尽有。\nAlexhhh 这个真的是大佬\n 女子 高中生 某个看起来很牛逼实际上是带专的大学的学生 全盘Arch Linux的忠实教徒 会在10行代码里隐藏100个bug的优秀开发者 以上说的bug是能报错的 酷安Linux交流群最大绒布球 minecraft lover（虽然不太适应电脑版） 不高兴就打音游然后就更不高兴的屑 类原生爱好者 gay里gay气但不是gay  Abi-ku 一位年轻的大学生，有热情，有理想，热爱生活\n","date":"2021-08-07T23:41:56+08:00","permalink":"https://uest.xyz/links/","section":"","tags":null,"title":"Links"},{"categories":null,"contents":"41. 缺失的第一个正数 给你一个未排序的整数数组 nums ，请你找出其中没有出现的最小的正整数。\n请你实现时间复杂度为 O(n) 并且只使用常数级别额外空间的解决方案。\n示例 1：\n1输入：nums = [1,2,0] 2输出：3 示例 2：\n1输入：nums = [3,4,-1,1] 2输出：2 示例 3：\n1输入：nums = [7,8,9,11,12] 2输出：1 这一题也是我没想到的解法，只知道用哈希，没想到原地哈希，直接操作原数组：\n 最早知道这个思路是在《剑指 Offer》这本书上看到的，感兴趣的朋友不妨做一下这道问题：剑指 Offer 03. 数组中重复的数字。下面简要叙述：\n由于题目要求我们「只能使用常数级别的空间」，而要找的数一定在 [1, N + 1] 左闭右闭（这里 N 是数组的长度）这个区间里。因此，我们可以就把原始的数组当做哈希表来使用。事实上，哈希表其实本身也是一个数组； 我们要找的数就在 [1, N + 1] 里，最后 N + 1 这个元素我们不用找。因为在前面的 N 个元素都找不到的情况下，我们才返回 N + 1； 那么，我们可以采取这样的思路：就把 11 这个数放到下标为 00 的位置， 22 这个数放到下标为 11 的位置，按照这种思路整理一遍数组。然后我们再遍历一次数组，第 11 个遇到的它的值不等于下标的那个数，就是我们要找的缺失的第一个正数。 这个思想就相当于我们自己编写哈希函数，这个哈希函数的规则特别简单，那就是数值为 i 的数映射到下标为 i - 1 的位置。\n作者：liweiwei1419 链接：https://leetcode-cn.com/problems/first-missing-positive/solution/tong-pai-xu-python-dai-ma-by-liweiwei1419/ 来源：力扣（LeetCode） 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n 1public static int firstMissingPositive(int[] nums) { 2 3 int n=nums.length; 4 for(int i=0;i\u0026lt;n;i++){ 5 while(nums[i]\u0026gt;0\u0026amp;\u0026amp;nums[i]\u0026lt;=n\u0026amp;\u0026amp;nums[i]!=i+1\u0026amp;\u0026amp;nums[nums[i]-1]!=nums[i]){ 6 //替代以后还要不断判断这一个数，因为新的数来了,所以用while 7 //nums[nums[i]-1]!=nums[i]这个条件必须要用上，不仅可以简化运算，还要针对这种【1，1】无限循环的情况 8 swap(nums,i,nums[i]-1); 9 } 10 11 } 12 for(int i=0;i\u0026lt;n;i++){ 13 if(nums[i]!=i+1) 14 return i+1; 15 } 16 return n+1;//针对只有【1】的数组 17} 相似的一题，剑指offer3：\n剑指 Offer 03. 数组中重复的数字 找出数组中重复的数字。\n在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。\n示例 1：\n1输入： 2[2, 3, 1, 0, 2, 5, 3] 3输出：2 或 3 这一题给了明示，所有数字都在 0～n-1 的范围内，也是同样的方法,原地hash\n可以看作成为一种排序占位，值为i的占到下标为i的位置，如果有人占到位子，说明重复了，最终达到O(n)的时间复杂度\n1public static int findRepeatNumber(int[] nums) { 2 3 int n=nums.length; 4 for(int i=0;i\u0026lt;n;i++){ 5 6 while(nums[i]!=i){ 7 if(nums[i]==nums[nums[i]]) return nums[i]; 8 swap(nums,i,nums[i]); 9 } 10 } 11 12 return 1; 13} ","date":"2021-08-07T21:49:20+08:00","permalink":"https://uest.xyz/posts/41%E7%BC%BA%E5%A4%B1%E7%9A%84%E7%AC%ACn%E4%B8%AA%E6%AD%A3%E6%95%B4%E6%95%B0/","section":"posts","tags":["Leetcode","Difficult"],"title":"41缺失的第n个正整数"},{"categories":null,"contents":"二叉树的前中后序遍历 前序：\n1public static List\u0026lt;Integer\u0026gt; preorderTraversal(TreeNode root) { 2 List\u0026lt;Integer\u0026gt; ans=new ArrayList() ; 3 if(root!=null){ 4 ans.add(root.val); 5 if(root.left!=null){ 6 ans.addAll(preorderTraversal(root.left)); 7 } 8 9 if(root.right!=null){ 10 ans.addAll(preorderTraversal(root.right)); 11 } 12 13 14 } 15 return ans; 16 17 } 中序：\n1public static List\u0026lt;Integer\u0026gt; inorderTraversal(TreeNode root) { 2 List\u0026lt;Integer\u0026gt; ans=new ArrayList() ; 3 if(root!=null){ 4 if(root.left!=null){ 5 ans.addAll(inorderTraversal(root.left)); 6 } 7 ans.add(root.val); 8 if(root.right!=null){ 9 ans.addAll(inorderTraversal(root.right)); 10 } 11 12 13 } 14 return ans; 15 16 17 } 后序：\n1public List\u0026lt;Integer\u0026gt; postorderTraversal(TreeNode root) { 2 List\u0026lt;Integer\u0026gt; ans=new ArrayList() ; 3 if(root!=null){ 4 5 if(root.left!=null){ 6 ans.addAll(postorderTraversal(root.left)); 7 } 8 9 if(root.right!=null){ 10 ans.addAll(postorderTraversal(root.right)); 11 } 12 13 ans.add(root.val); 14 15 } 16 return ans; 17 18 } ","date":"2021-07-29T22:56:00+08:00","permalink":"https://uest.xyz/posts/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E4%B8%AD%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/","section":"posts","tags":["Leetcode","Easy"],"title":"二叉树的前中后序遍历"},{"categories":null,"contents":"Z字型变换  6. Z 字形变换 将一个给定字符串 s 根据给定的行数 numRows ，以从上往下、从左到右进行 Z 字形排列。\n比如输入字符串为 \u0026quot;PAYPALISHIRING\u0026quot; 行数为 3 时，排列如下：\n1P A H N 2A P L S I I G 3Y I R 之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：\u0026quot;PAHNAPLSIIGYIR\u0026quot;。\n请你实现这个将字符串进行指定行数变换的函数：\n1string convert(string s, int numRows); 示例 1：\n1输入：s = \u0026#34;PAYPALISHIRING\u0026#34;, numRows = 3 2输出：\u0026#34;PAHNAPLSIIGYIR\u0026#34; 示例 2：\n1输入：s = \u0026#34;PAYPALISHIRING\u0026#34;, numRows = 4 2输出：\u0026#34;PINALSIGYAHRPI\u0026#34; 3解释： 4P I N 5A L S I G 6Y A H R 7P I 示例 3：\n1输入：s = \u0026#34;A\u0026#34;, numRows = 1 2输出：\u0026#34;A\u0026#34; 提示：\n 1 \u0026lt;= s.length \u0026lt;= 1000 s 由英文字母（小写和大写）、',' 和 '.' 组成 1 \u0026lt;= numRows \u0026lt;= 1000   解法1： 写出每一个字母的坐标，然后找出规律\n比如(P点是原点，向下是x轴，向右是y轴)\n1s = \u0026#34;PAYPALISHIRING\u0026#34;, numRows = 3 2//P0,0 A1,0 Y2,0 P1,1 3//A0,2 L1,2 I2,2 S1,3 4 5// P A H N 6// A P L S I I G 7// Y I R 注意到，每4次出现循环，将字母填入坐标系中。\n最后按顺序遍历坐标系，即可获得变换后的顺序。\n1public static String convert(String s, int numRows) { 2 if(numRows==1){ 3 return s; 4 } 5 int n_temp=s.length(); 6 char bb[][]=new char[numRows][n_temp]; 7 String ans=\u0026#34;\u0026#34;; 8 int cir=0; 9 int x=0,y=0; 10 int flag=0; 11 for(int i0=0;i0\u0026lt;n_temp;i0++){ 12 cir=i0%(2*numRows-2); 13 if(cir\u0026gt;=numRows|cir==0\u0026amp;i0\u0026gt;0){ 14 y++; 15 } 16 17 if(cir\u0026gt;=numRows) x--; 18 else x=cir; 19 bb[x][y]=s.charAt(i0); 20 } 21 for(int i=0;i\u0026lt;bb.length;i++){ 22 23 for(int j=0;j\u0026lt;bb[i].length;j++){ 24//char的默认值是0 25if(bb[i][j]!=0) ans=ans+bb[i][j]; 26 } 27 } 28 return ans; 29 } 这样时间和空间效率都不高。给出每一个字母的索引就能得到位置。反过来通过位置找到字母行不行呢？\n解法2： 比如变换后的第一个字母是P（拿以上的例子），索引是0；第二个字母是A，对应的原来的索引是4；然后8，12，16\u0026hellip;\u0026hellip;取0，4，8，12，16个字母即可获得第一行。\n第二行同样的方法，A(1),P(3),L(5),S(7),I(9)\n第三行：Y(2),I(6),R(10)\n对于示例 2：\n1输入：s = \u0026#34;PAYPALISHIRING\u0026#34;, numRows = 4 2输出：\u0026#34;PINALSIGYAHRPI\u0026#34; 3解释： 4P I N 5A L S I G 6Y A H R 7P I 第一行：0，6，12\n第二行：1，5，7，11，13（其实是0，6，12的前一个和后一个）\n第三行：2，4，8，10（其实是3，9的前一个和后一个）\n第四行：3，9\n思路好像没问题？\n但是看了下其他人的解法，我还是弱爆了。\n解法3： 简单易懂空间小，膜！\n注意flag的巧妙用法。\nhttps://leetcode-cn.com/problems/zigzag-conversion/solution/zzi-xing-bian-huan-by-jyd/\n","date":"2021-07-20T15:27:36+08:00","permalink":"https://uest.xyz/posts/6.z%E5%AD%97%E5%9E%8B%E5%8F%98%E6%8D%A2/","section":"posts","tags":["Leetcode","Medium"],"title":"6.Z字型变换"},{"categories":null,"contents":"415. 字符串相加  给定两个字符串形式的非负整数 num1 和num2 ，计算它们的和。\n提示：\n num1 和num2 的长度都小于 5100 num1 和num2 都只包含数字 0-9 num1 和num2 都不包含任何前导零 你不能使用任何內建 BigInteger 库， 也不能直接将输入的字符串转换为整数形式   根据朴素的加法思想，关键在于模拟竖式计算，用一个字符串存储进位，每一列超过十进位。\n注意要对齐，在短的字符串首部补零。字符串的生成使用拼接的方法。\n1 public static String addStrings(String num1, String num2) { 2 3 String numjinwei=\u0026#34;0\u0026#34;; 4 String addsum=\u0026#34;\u0026#34;; 5 int n1=num1.length(); 6 int n2=num2.length(); 7 8 9 if(n1\u0026gt;n2) for(int i=0;i\u0026lt;n1-n2;i++) num2=\u0026#34;0\u0026#34;+num2; 10 else for(int i=0;i\u0026lt;n2-n1;i++) num1=\u0026#34;0\u0026#34;+num1; 11//对齐 12 int n_max=Integer.max(n1,n2); 13 14 int jinwei=0; 15 for(int i=0;i\u0026lt;n_max;i++){ 16 int temp_lenthof_numjinwei=numjinwei.length(); 17 int t1=num1.charAt(n_max-1-i)-48; 18 19 int t2=num2.charAt(n_max-1-i)-48; 20 int t3=numjinwei.charAt(temp_lenthof_numjinwei-1-i)-48; 21 int temp=t1+t2+t3; 22 jinwei=temp/10; 23 int val=temp%10; 24 numjinwei=jinwei+numjinwei; 25 26 addsum=val+addsum; 27 } 28 if(jinwei==1){ 29 addsum=jinwei+addsum; 30 } 31 return addsum; 32 } ","date":"2021-07-18T19:39:21+08:00","permalink":"https://uest.xyz/posts/415%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E5%8A%A0/","section":"posts","tags":["Leetcode","Easy"],"title":"415.字符串相加"},{"categories":null,"contents":"48. 旋转图像  48. 旋转图像 难度中等933收藏分享切换为英文接收动态反馈\n给定一个 n × n 的二维矩阵 matrix 表示一个图像。请你将图像顺时针旋转 90 度。\n你必须在**原地** 旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要 使用另一个矩阵来旋转图像。\n示例 1：\n1输入：matrix = [[1,2,3],[4,5,6],[7,8,9]] 2输出：[[7,4,1],[8,5,2],[9,6,3]] 示例 2：\n1输入：matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]] 2输出：[[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]] 示例 3：\n1输入：matrix = [[1]] 2输出：[[1]] 示例 4：\n1输入：matrix = [[1,2],[3,4]] 2输出：[[3,1],[4,2]] 提示：\n matrix.length == n matrix[i].length == n 1 \u0026lt;= n \u0026lt;= 20 -1000 \u0026lt;= matrix[i][j] \u0026lt;= 1000  通过次数192,922\n提交次数263,618\n 一个很久就看到的题目，一直没写，不过上手发现思路不难。\n观察旋转过程中坐标的变化,以3*3矩阵来举例：\n(1,1)-\u0026gt; (1,3)\n(1,2)-\u0026gt;(2,3)\n(1,3)-\u0026gt;(3,3)\n(2,1)-\u0026gt;(1,2)\n(2,2)-\u0026gt;(2,2)\n(2,3)-\u0026gt;(3,2)\n多写几个就可以发现规律了：(i,j)-\u0026gt;(j,n+1-i)，这就意味着，将所有(i,j)位置上的值移到(j,n+1-i)位置上就行了，为了方便，可以另起一个矩阵，填入新值，就完成了。\n注意下标是从0开始的，坐标转化应该是(i,j)-\u0026gt;(j,n-1-i)\n1public static void rotate(int[][] matrix) { 2 int n_temp=matrix.length; 3 int bb[][]=new int[n_temp][n_temp]; 4 // System.out.println(matrix.length); 5 for( int i=0;i\u0026lt;matrix.length;i++){ 6 for(int j=0;j\u0026lt;n_temp;j++){ 7 8 bb[i][j]=matrix[i][j]; 9 }} 10 11 for( int i=0;i\u0026lt;matrix.length;i++){ 12 for(int j=0;j\u0026lt;n_temp;j++){ 13 matrix[j][n_temp-1-i]=bb[i][j]; 14 } 15 } 16 这就是一个最简单的旋转移动的思路了。可以拿一个图像试验一下，这里使用matlab\n原始图片是这样，\n使用matlab获得rgb值，进行旋转变换：\n1tu = imread(\u0026#39;image2022.png\u0026#39;); 2 3tu1=tu(:,:,1); 4s=size(tu1) 5tu2=zeros(s(2),s(1)); 6 7for i=1:s(1) 8 for j=1:s(2) 9 tu2(j,s(1)+1-i)=tu1(i,j); 10 end 11end 12image(tu2) 得到的结果：\n注意matlab中数组下标是从1开始的。\n回到题目中来，题目要求请不要 使用另一个矩阵来旋转图像，怎么办？\n观察(i,j)-\u0026gt;(j,n+1-i)，能不能看成两步(i,j)-\u0026gt;(n+1-i,j)，(n+1-i,j)-\u0026gt;(j,n+1-i)\n第一步是左右颠倒，(1,3)移到了(3,3);(3,3)移到了(1,3)，这样就可以交换了。\n第二步是对称交换，根据对角线对称。\n这样不需要使用另外一个矩阵进行保存数据了。\n1class Solution { 2 public void rotate(int[][] matrix) { 3 int n = matrix.length; 4 // 水平翻转 5 for (int i = 0; i \u0026lt; n / 2; ++i) { 6 for (int j = 0; j \u0026lt; n; ++j) { 7 int temp = matrix[i][j]; 8 matrix[i][j] = matrix[n - i - 1][j]; 9 matrix[n - i - 1][j] = temp; 10 } 11 } 12 // 主对角线翻转 13 for (int i = 0; i \u0026lt; n; ++i) { 14 for (int j = 0; j \u0026lt; i; ++j) { 15 int temp = matrix[i][j]; 16 matrix[i][j] = matrix[j][i]; 17 matrix[j][i] = temp; 18 } 19 } 20 } 21} 22//官方题解 第三种方法：\n一次性移动4格，详见官方题解。（公式的复制出现问题了，不然我就粘贴在这里了）\n1 public void rotate(int[][] matrix) { 2 int n = matrix.length; 3 for (int i = 0; i \u0026lt; n / 2; ++i) { 4 for (int j = 0; j \u0026lt; (n + 1) / 2; ++j) { 5 int temp = matrix[i][j]; 6 matrix[i][j] = matrix[n - j - 1][i]; 7 matrix[n - j - 1][i] = matrix[n - i - 1][n - j - 1]; 8 matrix[n - i - 1][n - j - 1] = matrix[j][n - i - 1]; 9 matrix[j][n - i - 1] = temp; 10 } 11 } 12 } 13  作者：LeetCode-Solution 链接：https://leetcode-cn.com/problems/rotate-image/solution/xuan-zhuan-tu-xiang-by-leetcode-solution-vu3m/ 来源：力扣（LeetCode） 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n ","date":"2021-07-17T19:56:17+08:00","permalink":"https://uest.xyz/posts/48%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F/","section":"posts","tags":["Leetcode","Medium"],"title":"48.旋转图像"},{"categories":null,"contents":"UNIX 读书笔记 第2章：UNIX 发展历史以及系统架构 发展历史：\n1965年 MULTICS ( Multiplexed Information and Computing Service) 的开发 1970年 Ken Thompson 和 Dennis Ritchie 在PDP7上用汇编语言开发出UNICS 1971年 在PDP-11上用汇编开发出UNIX v.1 1972年 增加管道功能后开发出UNIX v.2 1973年 Dennis Ritchie 在B language基础上发明了C language 并用C重写UNIX, 形成v.5 \u0026mdash;- 当时第一个高级语言OS\n1975年 发表UNIX v.6 并广泛扩散到大学和科研单位, 为后期发展奠定了良好的基础 1978年 优化后发布UNIX v.7 \u0026mdash;- UNIX的第一个商业版本 \u0026mdash;- 我国开始研究应用的最早版本 1981年 AT\u0026amp;T发布UNIX System III, 完全转向为社会提供的商品软件 1983年 AT\u0026amp;T发布UNIX System V, 系统功能已趋于稳定和完善. 此后System V又有一系列的公布号:1.0/2.0/2.3/3.5/4.0/4.2 等, 现在最后版本为 System V Release 4 (SVR4)\n有代表性的版本：\nAIX IBM公司 XENIX/OpenServer Microsoft、SCO公司 HP-UX HP公司 BSD 加州大学伯克利分校 Solaris SUN公司 IRIX SGI公司 Ultrix DEC公司 Linux 开放源代码\n系统结构： 内核：负责管理所有与硬件相关的功能，这些功能由UNIX内核中的各个模块实现。内核包括直接控制硬件的各个模块，这样能够极大程度上保护这些硬件，以避免应用程序直接操作而导致混乱。用户不能直接访问内核。\n 注意：系统工具和UNIX命令不是内核组件。\n用户应用程序得到保护，避免被其他用户的无意写操作破坏。\n 常驻模块层：提供执行用户请求服务的例程，包括IO控制服务，文件/磁盘访问服务，以及进程创建和终止服务。\n工具层：是UNIX的用户接口，通常成为shell在后面会详细讲到shell\n虚拟计算机：UNIX操作系统向系统中的每个用户指定一个执行环境，这个环境成为虚拟计算机，包括一个用户终端和共享的其他的计算机资源。而UNIX上可以存在多个用户，所以每一个用户都有自己的专用虚拟计算机。不同的用户的虚拟计算机共享CPU和其他计算机资源，所以虚拟计算机比真实的计算机要慢。\n进程：一个重要的概念。一般面试时都会问进程和线程 的区别。UNIX系统通过进程向用户和程序分配资源（这句话不怎么懂）。每个进程都有一个进程号pid和一组与之相关的资源。进程在虚拟计算机环境下运行，就好像在一个专用CPU上执行一样。\n第3章 UNIX入门 3.1登录与退出 1.登录\n输入用户名，密码\n2.修改密码：passwd和一般的修改要验证旧密码并两次重新输入新密码，具体操作不再赘述\n3.退出系统：[ctrl+d] 或是exit，即可退出\n3.2 简单的UNIX命令 命令行格式：[命令] [选项] [参数]\n字段间要用一个或多个空格隔开。选项的前面一般会有连字符-，一个命令同时也可以有多个，例如下列著名的命令：\nrm表示删除，-rf表示两个选项：r和f，/*表示的磁盘路径就是参数，告诉系统在哪里要删除什么文件\n下面介绍一些简单的命令：\n1.date：显示日期和时间\n2.who：列出登录系统的所有用户的用户名，终端号，和登录时间。这里wsl没有这个命令，原因如下\n who程序跟Linux内核无关，只是读取Unix里约定俗成的utmp,wtmp登录文件。你第一次打开wsl2的终端，或者通过其他方式运行wsl2的这个系统，就是第一次登录。但是wsl2子系统不会用utmp/wtmp记录这些，没有任何意义\n但在wsl里/init does not create /var/run/utmp\n解决方案： Use \u0026lsquo;touch /var/run/utmp\u0026rsquo; in some \u0026ldquo;system startup script\u0026rdquo;\n来源：https://github.com/Microsoft/WSL/issues/573\n who还有一些的选项：-q -H -b。\n3.显示日历：cal\n3.3 获取帮助信息 learn和help，使用时需要安装\n比如我不知道exit的用法\n3.3.3 man手册： 学习新命令时使用，可以得到该man(manual)命令的详细说明，当然\n在简洁的wsl中也是没有man的，需要先sudo apt install man-db manpages manpages-dev,之后才能愉快地使用man\n3.4 更正键盘输入错误 中断程序的执行，在大多数系统中，del或者ctrl-c就是中断键，比如不小心按了rm -rf /，这是就要猛敲[ctrl-c]\n3.5 使用shell 命令的处理是位于用户和操作系统的其他部分之间的shell完成的，每输入一个命令以后，命令被传到shell，先进行分析，然后执行。\nbulitin命令：包含的是一些比较简单的linux系统命令，这些命令由shell程序识别并在shell程序内部完成运行，通常在linux系统加载运行时shell就被加载并驻留在系统内存中。内部命令是写在bashy源码里面的，其执行速度比外部命令快，因为解析内部命令shell不需要创建子进程。比如：exit，history，cd，echo等。\n外部命令是linux系统中的实用程序部分，因为实用程序的功能通常都比较强大，所以其包含的程序量也会很大，在系统加载时并不随系统一起被加载到内存中，而是在需要时才将其调用内存。通常外部命令的实体并不包含在shell中，但是其命令执行过程是由shell程序控制的。shell程序管理外部命令执行的路径查找、加载存放，并控制命令的执行。外部命令是在bash之外额外安装的，通常放在/bin，/usr/bin，/sbin，/usr/sbin\u0026hellip;\u0026hellip;等等。可通过“echo $PATH”命令查看外部命令的存储路径，比如：ls、vi等。\n用type命令可以分辨内部命令与外部命令\n关于内部命令和外部命令执行顺序的问题：\n pwd命令用于显示当前工作目录，是Linux系统下最常用的命令之一。在不太能确定当前位置时，可以使用pwd命令来判断目录在文件系统内的确切位置。而涉及pwd指令，就不得不提及三个环境变量：PATH、OLDPWD、PWD。\nPATH：执行文件路径的变量；\u0026ldquo;echo $PATH\u0026rdquo;（PATH前面加$表示后面接的是变量）\nOLDPWD：表示前一次的工作目录；\nPWD：表示当前的工作目录。\n问题缘由：当输入“man pwd”时可以查看pwd的帮助文档，而输入“pwd \u0026ndash;help”就提示有错误bash: pwd: \u0026ndash;: invalid option；若输入“ /bin/pwd \u0026ndash;help”就能正常显示pwd的帮助文档。\n从网上查找原因并经过整合可知，这主要是由于内部命令和外部命令的区别，pwd是内部命令，而/bin/pwd就是外部命令。在显示当前目录时，/bin/pwd能显示当前工作目录的完整文件路径，能更准确些。在多人共享同一台Linux机器时，经常会发现当前目录被别人删除后，pwd命令仍然会显示那个目录。\n后续试验：切换至root权限下，将/bin目录下的执行文件ls移动到非正规目录中去，mv /bin/ls /root（#mv为移动，可将文件在不同的目录间进行移动操作），然后不管在哪个目录底下输入任何与ls相关的指令，都不能顺利执行ls了（因为/root这个目录并不在PATH指定的目录中，外部命令ls是没法通过PATH路径找到执行文件ls），除非用/root/ls 才行。\n如果想要让root在任何目录下均可执行/root底下的ls，那么可以将/root加入到PATH当中，该命令PATH=\u0026quot;$PATH\u0026quot;:/root即可。若有两个ls指令在不同的目录中，例如/usr/local/bin/ls 和/bin/ls ，那么当我下达 ls命令时，是根据PATH里面哪个目录先被查询到，则那个目录下的指令就先被执行。\n而即使采用相同的方法移动/bin目录下的执行文件pwd，仍可以输入pwd命令执行，因为这时仍是调用内部命令pwd指令。\n故shell命令解释器在执行命令时，是应先执行内部指令，若要执行的指令不是内部指令，则应是调用的外部指令。 ———————————————— 版权声明：本文为CSDN博主「JustDo-IT」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。 原文链接：https://blog.csdn.net/taohuaxinmu123/article/details/10845001\n 3.5.2 更改用户shell 可以在 /etc/passwd里查看用户登录的shell\n例如第一行：root:x:0:0:root:/root:/bin/bash 用户名：密码：UID：GID：描述性信息：用户主目录：Shell　具体shell的内容将在第9章中详细说明\n第4章 vi 编辑器入门 vi 文件名启动vi 编辑器，进入的是shell的命令模式,如果你要输入文本，可以按i进入文本输入模式，退出vi：先esc，再输入:wq，即可保存或退出。\n以上就是最最基础的用法。下面介绍高级用法：\n4.1模式： 从命令模式进入文本输入模式：\n   文本输入模式        i  在光标左侧加入文本    I  在光标所在行首插入文本    a  在光标右侧加入文本    A  在光标所在行尾加入文本    o  在光标所在行下面新加一行    O  在光标所在行上面新加一行    ESC  退出文本输入模式     4.2 命令模式： 光标移动：\n   光标移动        h j k l  左下上右移动    ^  行首    $  行尾    +  下一行的行首    _  上一行的行首    Space  右移    Backspace  左移    w  下一个字    b  前一个字    e  当前字的末尾     文本修改：\n   文本修改       x  删除光标所在字符   dw  删除光标所在词的从光标开始到该词结尾   D  删除从光标到行尾   dd  删除光标所在行   u  撤销上一次修改   r  把当前光标所在字符替换为紧跟在r后的一个字    x,dw,dd前都可加上数字，表示同时删除多个单位\n.可以重复最近一次对文本的修改操作\n搜索文本\n   搜索      / 输入搜索词并回车，向尾部查找下一个词   ? 与/相同，查找方向相反    4.3 退出 在命令模式时，\n   退出      :wq 保存文本，退出vi，返回shell   :w 保存文本，不退出   :w file 把文本保存到文件file中，不退出   :q 退出vi，返回shell   ZZ 快速保存文件并退出    4.4 存储缓冲区 vi编辑器为用户所要创建或修改的文件建立了一个临时工作区，用户编辑的过程中只作用于工作区的文件副本而不是源文件。如果用户需要保存，必须用命令将修改的文件替换原文件。\n4.5 高级操作 希望能在vim中完成大多数工作，而不是频繁的退出vim 首先:tabnew创建一个标签 然后:e 文件名打开一个文件 :tabnext在窗口上打开下一个tab :tabprevious在窗口上打开前一个tab :q或者:tabclose关闭tab 更多的高级用法将在第6章讲到\n第5章 UNIX 文件系统介绍 5.1 磁盘组织 UNIX允许用户将硬盘分为很多单元（称为目录）和子单元（子目录），这样可以在目录里嵌套子目录。UNIX提供命令，可以在磁盘上创建、组织、和查找目录和文件。\n文件系统原理\nUnix有三大抽象\n 进程、线程对执行过程 文件对io 地址空间对内存  Unix有四种io：文件系统、块设备、字符设备、socket\n 块设备和字符设备出现在文件系统的名字空间 Socket仅表现为文件  考虑到磁盘的空间组织，主要有边长的堆、定长的记录、索引\nUnix文件系统选择：堆 + 索引\n5.2 UNIX中的文件类型 普通文件：包含字节序列，如程序代码、数据、文本。\n目录文件：目录文件和其他文件一样，用户可以像命名其他文件一样来命名目录文件。区别在于不是标准的ascii文本文件，包含的是关于其他文件的信息。\n特殊文件：包含与外部设备，如打印机、磁盘等相联系的的特定信息。unix的一大抽象就是将io设备视同文件对待，系统中的每个设备都分别对应一个文件。\n5.3 目录详述 目录结构以层次形式组织，称为层次结构（其实可以理解为树）。最高层目录为根目录。\n5.3.1 重要的目录： /usr 用户主目录，当用户在系统中登录时，会自动进入用户主目录，它在/usr/[username]下。\n/bin 可执行文件\n/dev设备文件，代表物理设备的抽象，如终端是/dev/tty文件。/dev/null是一个特殊设备，即空设备，所有发给空设备的信息都被删除。\n/sbin 存放系统文件，在3.5章讲到：\n 外部命令是在bash之外额外安装的，通常放在/bin，/usr/bin，/sbin，/usr/sbin\u0026hellip;\u0026hellip;等等\n /etc 存放unix配置文件，通常是文本，只要特权用户才有权限编辑。\n5.3.2 路径 绝对路径名：从根目录到该文件的路径，以/开始\n相对路径名：从当前路径到目的文件，开头没有/\n5.4 目录命令 1.打印工作目录 pwd(print working directory)\n2.改变工作目录 cd \n   cd命令      cd 返回用户主目录，缺省值   cd $HOME 返回用户主目录   cd .. 返回上一级目录    3.创建目录 mkdir\n选项有-p\nmkdir -p xx/yy/zz 创建xx目录，在xx下创建yy目录，在yy下创建zz目录\n4.删除目录 rmdir\n注意只能删除空目录，即除了本目录（.）和父目录（..）外，该目录不包含其他任何子目录和文件。\n5.目录列表 ls\n显示指定目录的信息，如果没有指定目录，则列出当前目录。\n   UNIX选项 linux选项 功能     -a \u0026ndash;all 列出所有文件，包括隐藏文件   -C \u0026ndash;format=vertical \u0026ndash;format=horizontal 用多列方式列出文件，按列排列   -F \u0026ndash;classify 将子目录与普通文件类型分开，子目录加/，可执行文件加*   -l \u0026ndash;format=single-column 详细列出文件的属性，每行一个文件   -m \u0026ndash;format=commas 按页宽列出文件，用逗号隔开   -p  在目录文件名后加斜杠 /   -r \u0026ndash;reverse 以反字母顺序列出文件   -R \u0026ndash;recursive 递归列出子目录的内容   -s \u0026ndash;size 以block为单位列出文件大小   -x \u0026ndash;format=horizontal \u0026ndash;format=across 以多列方式列出文件，按行排列    \u0026ndash;help 显示帮助信息    例如：\ndrwxr-xr-x 为属性字段\n文件属性字段总共有10个字母组成；第一个字符代表文件的类型。\n字母**“-”**表示该文件是一个普通文件\n字母**“d”**表示该文件是一个目录，字母\u0026quot;d\u0026quot;，是dirtectory(目录)的缩写\n**注意：**目录或者是特殊文件，这个特殊文件存放其他文件或目录的相关信息\n字母**“l”**表示该文件是一个链接文件。字母\u0026quot;l\u0026quot;是link(链接)的缩写，类似于windows下的快捷方式\n字母**“b”**的表示块设备文件(block)，一般置于/dev目录下，设备文件是普通文件和程序访问硬件设备的入口，是很特殊的文件。没有文件大小，只有一个主设备号和一个辅设备号。一次传输数据为一整块的被称为块设备，如硬盘、光盘等。最小数据传输单位为一个数据块(通常一个数据块的大小为512字节)\n字母**“c”**表示该文件是一个字符设备文件(character)，一般置于/dev目录下，一次传输一个字节的设备被称为字符设备，如键盘、字符终端等，传输数据的最小单位为一个字节。\n字母**“p”**表示该文件为命令管道文件。与shell编程有关的文件。\n字母**“s”**表示该文件为sock文件。与shell编程有关的文件。\n后面的是文件访问模式：rwx分别为read，write，执行的权限。分为3组，第一组rwx是文件所有者，第二组r-x是同组用户权限，第三组r-x是其他用户权限。\n第2列是链接数，第3列是文件所有者，第4列是文件组，第5列是文件大小，第6列是上次修改的日期和时间，第7列是文件名。\n6.隐藏文件\n文件名以点开始的文件，不可见。\nchmod命令 chmod命令可以使用八进制数来指定权限。文件或目录的权限位是由9个权限位来控制，每三位为一组，它们分别是文件所有者（User）的读、写、执行，用户组（Group）的读、写、执行以及其它用户（Other）的读、写、执行。历史上，文件权限被放在一个比特掩码中，掩码中指定的比特位设为1，用来说明一个类具有相应的优先级。\n   # 权限 rwx 二进制     7 读 + 写 + 执行 rwx 111   6 读 + 写 rw- 110   5 读 + 执行 r-x 101   4 只读 r\u0026ndash; 100   3 写 + 执行 -wx 011   2 只写 -w- 010   1 只执行 \u0026ndash;x 001   0 无 \u0026mdash; 000    .和. .目录项\n本目录（.）和父目录（..）mkdir命令自动将两项放到创建的每个目录中。分别代表当前目录和上一级目录。\n5.5 显示文件 cat concatenate命令 可以显示一个、多个、创建文件、连接文件。\n5.6 打印文件内容 lp 将文件发送给打印机\nLinux中的打印请求 lpr命令\n取消打印命令cancel\n获取打印机状态lpstat\n5.7 删除文件 rm可以删除指定的文件\n   选项 功能     -i 删除文件前，给出确认信息   -r 删除指定的目录及目录下的所有文件和子目录   -rf 无提示地强制递归删除文件    如果想无提示删除所有文件，可以作死尝试sudo rm -rf /*\n第6章 vi编辑器的高级用法 6.1 更多vi知识 6.1.1 启动vi编辑器 以不依靠文件的方式启动vi，可以最后用:w filename保存（如果有同名文件会提示）\n启动选项：\n-R 只读，如果希望保存的话，必须用!强制执行写选项\nview filename同样可以以只读模式打开\n6.1.2 编辑多个文件 :n 启动下一个编辑文件，此时用下一个文件替换工作缓冲区的内容（源文件要保存）。我觉得唯一作用就是可以省略退出的操作。\n:e编辑另一个文件，感觉这种方法和:n一样啊\n:r读另一个文件，将指定文件的副本放到缓冲区中光标位置之后，指定文件成为当前文件的一部分。保存到源文件。\n:w将正在编辑的文件写入另一个文件中，就相当于6.1.1中最后的保存操作\n6.2 重排文本 vi提供了删除，复制，剪贴操作。就是命令有点复杂。\n书中讲了几个例子：\n1.剪贴行（使用删除和put操作符）\n在某一行按dd，会发现这一行消失了，但并没有完全消失，只是保存到临时缓冲区中，在合适的地方按p，这时刚才被删除的行就被放在当前行下。\n2.复制行（使用复制和put操作符）\n在某一行按yy，这一行保存到临时缓冲区中，在合适的地方按p，粘贴。\n当然先要精细化粘贴怎么办呢？\n6.3 操作符的域 命令=操作符+域\n确定操作域后，可以使用户更好地控制编辑任务。\n   键 功能说明     $ 标识域为从光标位置后到当前行尾   0 标识域为从光标位置前到当前行首   e/w 标识域为从光标位置后到当前字尾   b 标识域为从光标位置前到当前字首    比如要复制从光标到行尾的所有，可以按d$，这就实现了复制，再按p粘贴。\n删除2行，d2d\n6.4 使用缓冲区 6.4.1 数字编号缓冲区 编号1-9，每次删除或复制的文本就会放在这些地方。使用\u0026quot;1p就可以把1号缓冲区粘贴到下一行。\n6.4.2 字母编号缓冲区 编号a-z，用户可以保存指定文本到某字母编号缓冲区。\n比如\u0026quot;wdd将当前行删除，删除的副本保存在w号缓冲区\n\u0026quot;z7yy，复制7行内容到z缓冲区\n6.5 光标定位键    键 功能说明     Ctrl-d 将光标向下移动到文件尾，通常每次移动12行   Ctrl-u 将光标向下移动到文件头，通常每次移动12行   Ctrl-f 将光标向下移动到文件尾，通常每次移动24行   Ctrl-b 将光标向下移动到文件头，通常每次移动24行    6.6 定制vi 用户可以调整vi编辑器的设置\n可以看到有众多选项可以自定义。\n下面介绍一些常用选项：\n   选项 缩写 功能     autoindent ai 将新行与前一行的行首对齐   ignorecase ic 在搜索选项中忽略大小写   magic  允许在搜索时使用特殊字符   number nu 显示行号   report  通知用户上一个命令影响的行号   scroll  设定Ctrl-d命令翻动的行数   shiftwidth sw 设置缩进的空格数，与autoindent选项一起使用   showmode smd 在屏幕的右角显示vi编辑器的模式   terse  缩短错误信息   wrapmargin wm 设置距屏幕右边界为指定的字符数    6.6.4 缩写ab 在命令模式输入:ab hos harmony OS，进入文本模式，在任何地方输入hos，注意前后要有空格，vi就会把hos替换为harmony OS。\n:ab [return]可以查看所有的缩写\n宏操作符map：可以指定单个键代表键序列。例如：想要用q代替删除5行5dd，可以在命令模式输入:map q 5dd\n以上取消可以按:unab hos和:unmap q\n6.6.5 .exrc文件 用户的设置都是临时的，如果想要永久保存对vi的设置，可以在.exrc文件保存设置\n6.7 其他命令 当你想在vi编辑时运行shell命令，为了在vi中编辑文件不被打断，可以:! 执行shell命令\n第7章 正则表达式 Regular Expressions RE分为BRE和ERE\nBasic RE：\n   字 符 BRE/ERE 含义     \\ Both 转义   . Both 匹配单个字符   * Both 匹配任意次，可以是0次。a*表示匹配任意多次a，.*表示任意字符串   ^ Both 锚定匹配位置，从一行的行首开始   $ Both 锚定匹配位置，到一行的行尾   […] Both 匹配中括号内的某个字符。x-y表示一个范围；[^…]表示不匹配中括号中的任意字符。[开括号后跟-或]，-]转义为普通字符   \\{n,m\\} BRE 匹配次数为[n,m]，{n}匹配n次，{n,}最小匹配次数为n   \\ (\\ ) BRE 定义一个匹配位置，在后部可以引用该位置。例如，\\(ab\\).*\\1表示ab字符串包夹了一个任意字符串。   \\n BRE 引用已经定义的位置，可以从\\1到\\9    下面是一些例子：\na*g$ 匹配到行尾\n^a*g 匹配到行首（*表示0-任意次）\na[a-z]g可以匹配aag，abg，\u0026hellip;,azg都可以\na[^0-9]g不匹配a9g\n []中也可以加[[:alnum:]]表示字符+数字\n[[:alpha:]]表示字符\n[[:digit:]]表示数字\n[[:lower:]]表示小写字符\n[[:upper:]]大写字符\n[[:space:]]空字符：空格、tab\n a{3}匹配aaa,aaaaaa\na{3,}匹配aaa，aaaa，aaaaaa\n例子 在leetcode上有shell分类，随便点开一题，发现是正则表达式的题目\n 给定一个包含电话号码列表（一行一个电话号码）的文本文件 file.txt，写一个单行 bash 脚本输出所有有效的电话号码。\n你可以假设一个有效的电话号码必须满足以下两种格式： (xxx) xxx-xxxx 或 xxx-xxx-xxxx。（x 表示一个数字）\n你也可以假设每行前后没有多余的空格字符。\n示例：\n假设 file.txt 内容如下：\n987-123-4567 123 456 7890 (123) 456-7890 你的脚本应当输出下列有效的电话号码：\n987-123-4567 (123) 456-7890\n来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/valid-phone-numbers\n 首先当然是匹配行首到行尾，^和$不能少\n三位数字怎么弄：[0-9]{3}\n^[0-9]{3}-[0-9]{3}-[0-9]{4}$|^(\\([0-9]{3}\\) [0-9]{3}-[0-9]{4})$ 当然也可以不同，下面截取一个leetcode网友的题解\n1cat file.txt | grep -P \u0026#34;^(\\([0-9]{3}\\)\\s|[0-9]{3}-)[0-9]{3}-[0-9]{4}$\u0026#34; 简单修改一下在支持re的idea中搜索(\\([0-9]{3}\\)\\s|[0-9]{3}-)[0-9]{3}-[0-9]{4}$成功匹配到了正确的电话号码\n第8章 UNIX文件系统的高级操作 8.1 重定向   C语言程序一般会打开三个缺省文件，stdin、stdout、stderr，文件描述符分别是0,1,2。\n  在Unix系统中，文件是io的基本抽象。标准输入、标准输出、错误输出可以替换为其它文件。\n  输出重定向\ncommand \u0026gt; file\ncommand \u0026gt;\u0026gt; file 追加\n标准输入重定向\ncommand \u0026lt; file\ncommand \u0026lt;\u0026lt; EOF 标准输入，当碰到EOF字符串时，输入结束\n标准错误输出重定向\ncommand 2\u0026gt; file 将command的错误输出重定向到file文件\ncommand 2\u0026gt;\u0026gt; file 追加重定向\n1ls \u0026gt; mydir.list 2cat mydir.list //显示mydir.list 3 4此时再 5ls .. \u0026gt;\u0026gt; mydir.list 6//将新的内容追加到mydir.list 7 8rmdir ggg \u0026amp;\u0026gt;\u0026gt; mydir.list//将报错消息追加到mydir.list 9 10cat mydir.list 11! 12anaconda3 13CLionProjects 14Downloads 15examples.desktop 16mydir.list 17myfirst 18snap 19 20rmdir: 删除 \u0026#39;ggg\u0026#39; 失败: 没有那个文件或目录 21 为了提高效率，可以直接使用cat和\u0026gt;创建文件：cat file1\ncat file1 file2\u0026gt; file3可以将file1和file2文件内容复制到file3中。\ncat file3 \u0026gt;\u0026gt; file4 将file3追加到file4的末尾。\n8.2 管道 shell将一个程序的标准输出作为另一个程序的标准输入，形成管道（pipeline）\ncommand A | command B\n注意两条命令之间是以一个匿名文件传输\n单向通过，没有格式，以流的形式进行通信\n例如，我想在查找ls -l的结果中以正则表达式搜索s.*h，可以执行\nls -l|grep -e\u0026quot;s.*h\u0026quot;\n8.2.1 Shell如何实现管道？ 1.pipe()函数创建一个管道，两个文件描述符，一个输入，一个输出\n2.fork()创建子进程\n3.父进程关闭管道的输出端。\n4.子进程dup2，将标准输入替换为管道输入。\n5.子进程进一步关闭管道输入和输出。\n6.父进程写完数据后，关闭管道输出。\n7.子进程从父进程收到EOF，输入数据完毕。\n8.3 文件操作 cp拷贝源文件成目标文件\n   短选项 长选项 功能     -b \u0026ndash;backup 如果目标文件存在，创建备份   -i \u0026ndash;interactive 如果目标文件存在，要求确认   -r \u0026ndash;recursive 将目录复制到新的目录    \u0026ndash;verbose 解释操作    \u0026ndash;help 显示帮助页并退出    mv移动文件\n   短选项 长选项 功能     -b \u0026ndash;backup 如果目标文件存在，创建备份   -i \u0026ndash;interactive 如果目标文件存在，要求确认   -f \u0026ndash;force 强制移动，不要求确认   -v \u0026ndash;verbose 解释操作    \u0026ndash;help 显示帮助页并退出    \u0026ndash;version 显示版本信息并退出    8.4 ln链接文件 用于为已存在的文件创建另外的名字（链接）。\n假设有一个a.txt文件，想给他另一个名字b.txt\n输入$ sudo ln a.txt b.txt\n再查看一下目录$ ls -li\n110878 -rw-r--r-- 2 endwsl endwsl 0 Apr 12 20:08 a.txt 210878 -rw-r--r-- 2 endwsl endwsl 0 Apr 12 20:08 b.txt 1endwsl@LAPTOP-U1E6STIA:/home$ cat \u0026gt;\u0026gt;a.txt 2atxt 3//修改一下a.txt的内容 4endwsl@LAPTOP-U1E6STIA:/home$ cat b.txt //再去看b.txt的内容 5atxt //发现竟然也是atxt 甚至ln命令不会创建新的i-node，而是引用已有i-node，增加引用计数。\nln –s符号链接，分配一个新的inode，内部记录指向原有文件。\n8.5 其他wc,head,tail wc统计字数\n   短选项 长选项 功能     -l \u0026ndash;lines 统计行数   -w \u0026ndash;words 统计单词数量   -c \u0026ndash;chars 统计字符数量    \u0026ndash;help 帮助    1(base) minatoxeon@OMEN:~$ wc -l mydir.list 219 mydir.list 3(base) minatoxeon@OMEN:~$ wc -w mydir.list 423 mydir.list 5(base) minatoxeon@OMEN:~$ wc -c mydir.list 6215 mydir.list 7(base) minatoxeon@OMEN:~$ 8 head显示文件头部，缺省显示头部10行。\n   短选项 长选项 功能     -n \u0026ndash;lines=n 显示头部n行   -c \u0026ndash;chars=n 显示头部n个字符    \u0026ndash;help 显示帮助页并退出    \u0026ndash;version 显示版本信息并退出    tail显示文件尾部，缺省是尾部10行，与head类似就不再列举出。\npaste命令横向连接两个文件。缺省分隔符为TAB制表符。\n   短选项 长选项 功能     -d x \u0026ndash;delimiters=x 指定域分隔符    \u0026ndash;help 显示帮助页并退出    \u0026ndash;version 显示版本信息并退出    8.6 sed替换    选项 含义     -e 脚本命令 该选项会将其后跟的脚本命令添加到已有的命令中。   -f 脚本命令文件 该选项会将其后文件中的脚本命令添加到已有的命令中。   -n 默认情况下，sed 会在所有的脚本指定执行完毕后，会自动输出处理后的内容，而该选项会屏蔽启动输出，需使用 print 命令来完成输出。   -i 此选项会直接修改源文件，要慎用。    一个使用的例子：\n我在使用群晖时发现：一旦ssd温度升高到61度就会引起自动关机,由于我的群晖没有风扇，对于ssd达到这个温度轻而易举，一个24小时工作的设备肯定不希望它经常关机，根据教程查看群晖的配置文件发现\n1admin@DiskStation:/usr/syno/etc.defaults$ cat scemd.xml | grep -E \u0026#34;61\u0026#34; 2 \u0026lt;disk_temperature fan_speed=\u0026#34;FULL\u0026#34; action=\u0026#34;SHUTDOWN\u0026#34;\u0026gt;61\u0026lt;/disk_temperature\u0026gt; 3 \u0026lt;disk_temperature fan_speed=\u0026#34;FULL\u0026#34; action=\u0026#34;SHUTDOWN\u0026#34;\u0026gt;61\u0026lt;/disk_temperature\u0026gt; 4 \u0026lt;disk_temperature fan_speed=\u0026#34;FULL\u0026#34; action=\u0026#34;SHUTDOWN\u0026#34;\u0026gt;61\u0026lt;/disk_temperature\u0026gt; 5 \u0026lt;disk_temperature fan_speed=\u0026#34;FULL\u0026#34; 群晖的温度墙为61度，此时使用sed替换所有的61为70\nsudo sed -i\u0026quot;s/61/70/g\u0026quot; scemd.xml\n1admin@DiskStation:/usr/syno/etc.defaults$ cat scemd.xml | grep -E \u0026#34;70\u0026#34; 2action=\u0026#34;SHUTDOWN\u0026#34;\u0026gt;70\u0026lt;/disk_temperature\u0026gt; 3 \u0026lt;disk_temperature fan_speed=\u0026#34;FULL\u0026#34; action=\u0026#34;SHUTDOWN\u0026#34;\u0026gt;70\u0026lt;/disk_temperature\u0026gt; 4 \u0026lt;disk_temperature fan_speed=\u0026#34;FULL\u0026#34; action=\u0026#34;SHUTDOWN\u0026#34;\u0026gt;70\u0026lt;/disk_temperature\u0026gt; 5 \u0026lt;disk_temperature fan_speed=\u0026#34;FULL\u0026#34; action=\u0026#34;SHUTDOWN\u0026#34;\u0026gt;70\u0026lt;/disk_temperature\u0026gt; 这样就让温度墙设定为70度\n（由于群晖基于的是freebsd，因此在群晖的控制面板打开ssh即可使用ssh client登陆，注意：SSH 仅支持属于 local administrators 群组的帐户登录系统。默认端口为22）\n（尴尬的是改完温度墙以后，使用一段时间温度就会达到70°，只好去加了个风扇）\n不过使用s///g对替换里面字符里面要是有路径的话就会很难受,所以可以用s:::g来表示同样的意思。\n8.7 打开文件：grep命令 grep命令打开文件，在文件中以RE方式搜索字符串\n   短选项 长选项 功能     -c \u0026ndash;count 只显示匹配的行数   -i \u0026ndash;ignore-case 忽略大小写匹配   -G \u0026ndash;basic-regexp BRE，grep缺省   -E \u0026ndash;extended-regexp ERE，egrep缺省   -e PATTERNS \u0026ndash;regexp=PATTERNS 指定一个或多个RE   -v \u0026ndash;invert-match 显示不匹配的行   -n \u0026ndash;line-number 输出行号   -o \u0026ndash;only-matching 只输出匹配的部分    8.8 find查找文件    选项 功能     -name filename 根据给定的filename查找文件。   -size ± n 查找文件大小为n的文件   -type file type 查找指定类型的文件   -atime ± n 查找n天以前访问的文件   -mtime ± n 查找n天以前修改的文件   -newer filename 查找比filename更近期更新的文件   -print 显示找到的每个文件的路径名   -exec command\\； 对找到的文件执行command   -ok command\\； 在执行command之前要求确认      -name选项实例：\n  -find.-name first.c-print[Return] 查找文件名为first.c的文件。\n  $find.-name \u0026ldquo;*.？\u0026quot;-print[Return] 查找文件名为点和单个字符结尾的文件。\n    -size ± n选项：+表示大于，-表示小于。\n  -type选项：\n -b : 块特殊文件（如磁盘） -c ：字符特殊文件（如终端） -d ： 目录文件 -f ： 普通文件    -emax\n  统计/usr/include/sys目录下的所有目录及子目录个数\n1find /usr/include/sys -type d|wc -l 查找epoll_wait函数在那个文件： find /usr/include –name “*.h” -type f | xargs grep ‘epoll_wait’\n搜索/usr/include目录中，引用EPOLLIN常数的头文件\n1find -name \u0026#34;*.h\u0026#34; -type f|xargs grep \u0026#34;EPOLLIN\u0026#34;./linux/eventpoll.h:#define EPOLLIN\t0x00000001./x86_64-linux-gnu/sys/epoll.h: EPOLLIN = 0x001,./x86_64-linux-gnu/sys/epoll.h:#define EPOLLIN EPOLLIN 在usr/include中查找文件名以.h结尾的所有普通文件。\n1find /usr/include -name \u0026#34;*.h\u0026#34; 8.9 文件系统 unix文件系统将每一个文件名与一个数字(inode)连接起来，并用文件的inode来标识每一个文件。\n磁盘结构：\n在unix先，磁盘是标准的块设备，unix的磁盘分为4个块\n  引导块\n  超级块 包含有关磁盘自身的信息\n 磁盘的总块数 空闲块数 块的大小 已使用的块数    inode列表块\n保存inode列表，列表中的每一个表项是一个inode，有64字节存储空间。普通文件或者目录文件的inode包含文件在磁盘块的位置。特殊文件的inode包含标识外部设备的信息。除了以上，还有：\n 文件访问权限（读写执行） 文件属主和组id 文件链接数 文件最后修改时间 文件最后访问时间 每个普通文件和目录文件的块位置 特殊文件的设备标识号    文件和目录块\n第二个inode包含根目录所在块的位置。创建目录时，系统自动创建两个表项：.（表示子目录）和..（表示父目录）\n  第9章 探索Shell unix由内核和系统工具组成。内核是核心，所有直接与硬件通信的常规程序都集中在内核中。\nshell是用户和系统交流的工具，自身是一个应用程序。当用户登录到系统时shell被装入内存。\n用户登录时，init（进程号1）拉起login，输入密码成功后，由login进程拉起shell进程\n对于大多数用户键入的命令，shell并不执行，它fork子进程来执行命令，shell等待wait子进程结束（等待SIGCHLD信号）。\nshell的主要功能：\n 命令执行 文件名替换 I/O重定向 管道：把简单程序连接到一起来完成一个较为复杂的任务。“|”就是管道操作符 环境控制：用户通过设定，可以变更主目录、命令提示符或工作环境 后台计算：shell的后台计算能力使用户能够在前台进行工作的同时在后台运行程序。 shell脚本  9.1 显示消息：echo命令 echo命令输出字符串，echo hello there就会输出hello there\n一般默认输出禁止换行\n9.2 shell 变量 bash shell 用一个叫做环境变量(environment variable)的特性来存储有关shell会话和工作环境的信息。这项特性允许用户存储信息，以便程序或shell中运行的脚本能够轻松访问。这也是持久存储数据的一种简便方法。\nUNIX支持两种变量:环境变量和局部变量。（shell变量是字符串）\n 环境变量：为系统所知道的变量名，通常由系统管理员定义。 局部变量：用户定义，并完全由用户控制。  9.2.1 显示和清除变量：set和unset命令 使用set命令可以查看当前使用的shell变量\n使用echo显示变量的值。在这种情况下引用某个环境变量的时候，必须在变量前面 加上一个美元符（$）。\n1echo $HOME 在echo命令中，在变量名前加上$可不仅仅是要显示变量当前的值。它能够让变量作为命令 行参数。\n1ls $HOME 全局环境变量可用于进程的所有子shell。\nunset可以清除不想要的变量，也可以用赋值语句来修改用户变量或者标准变量。注意：标准shell变量的改变是占时的，只用于当前会话，当下次登录时，还要重新进行设置。如果想要长久改变系统变量的值，可以把变量放到名为.profile的文件中。\n9.2.2 标准 shell 变量  HOME 变量：shell把用户主目录的完整路径赋值给变量HOME。 IFS 变量：内部字段分隔符，用来用户输入的分隔命令。包括空格，tab，换行符。即IFS=$' \\t\\n' 。 MAIL 变量：接收用户邮件文件的文件名。 PATH 变量：shell在定位命令时所要查找的目录名。UNIX一般把可执行文件存在一个叫做bin的目录中。以下是我的键入shell后的结果：  1PATH=\u0026#39;/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games 9.3 其他元字符 9.3.1 重音符号 shell执行重音符号`中的命令，并将命令的输出插入到命令行的相应位置中，也被称为命令替换符。\n9.3.2 括号 将几个命令放在括号里，可以编组。一个命令组可以像单条命令一样被重定向。\n9.3.3 后台处理\u0026amp; jobs命令列举后台执行的作业\n9.4 其他UNIX工具 9.4.1 延时定时 sleep，让某个命令延缓一段时间执行。\n9.4.2 显示PID 当程序运行在系统上时，我们称之为进程（process）。想监测这些进程，需要熟悉ps命令的 用法。ps命令能输出运行在系统上的所有程序的许多信息。\n默认情况下，ps命令并不会提供那么多的信息,只显示PID,TTY,TIME,COMMAND\n默认情况下，ps命令只会显示运行在当前控制台下的属于当前用户的进程。\n   选项 功能     -a 显示所有进程，但不包括会话leader，不包括无终端进程   -f 显示进程完整信息   -e 显示所有进程   -H 按照树型显示   -j 按照job形式输出    9.4.3 kill命令 终止不想要的进程\n根据执行情况的不同，kill发送给进程的信号范围可以取1-15.\n9.4.4 分离输出 tee将命令结果显示到终端同时保存到指定文件中。\nsort new.list|tee new1.list\n9.4.5 文本排序 sort对文件内容按照字母或数字排序。\n9.5 列出之前输入的命令 Bash在执行命令后，会在内存中记录所有使用的命令。当用户退出登录，所有命令保存在~/.bash_history文件中，history命令则列出到目前为止，执行的所有命令。使用这一功能可以使用用户已经键入过的命令，找到已经执行过的命令。\n~/.bash_history记录的是到上次退出前的所有命令，会一直增加并保存，最终会变得非常大。想要重新记录history的话可以将其删除。\nfc命令:列出、编辑和重复执行history命令列表文件的命令。\nfc first last 先编辑从first到last的命令，然后执行\nfc –s cmd cmd是history的命令编号，执行该编号任务\n9.6 创建别名 alias ll=‘ls –al’设置ll为ls -al命令的别名。\n第10章 Unix通信 UNIX提供了一组与其他用户通信的命令和工具。\n10.1 通信方式 10.1.1 write命令 write命令可以发送消息给系统内其他的已经登陆的用户。另一个用户无论在干什么，消息都会出现在屏幕上。甚至在使用vi时，write消息也会显示在光标处。但仅仅是覆盖在屏幕上的消息，不会破坏用户正在编辑的任务。当然也可以使用mesg禁止终端接收来自write命令的消息。\n10.1.2 显示新闻：news命令 用户可以使用news命令来看看系统正在做什么。news从系统news命令读出消息。默认显示news目录下用户还没有看过的所有文件。\n   选项 操作     -a 显示所有的新闻项，无论是新的还是旧的   -n 仅仅列出新闻名   -s 显示当前新闻的总数    10.1.3 广播消息：wall命令 wall(write all)命令给当前登录到系统上的所有用户发送消息。通常由系统管理员使用，用于通知用户一些紧急事件。\n10.1.4 全双工通信：talk命令 talk命令与write相似，都用于用户与系统中已经登录的其他用户通信。输入talk和用户名，连接建立成功，两个用户就可以进行交谈了。这时，双方的终端屏幕上都将显示信息[Connection established]并响铃，同时屏幕被linux中talk命令程序以一条水平线分割为上下两部分，上半部分用来显示用户自己输入的内容，下半部分用来显示对方输入的内容。两个用户可以同时输入，他们输入的内容将会立即显示在双方的屏幕上。\n在用户进行输入时，可按BACKSPACE见来更正前一个字符，也可按CTRL+w来删除一个完整的单词，或者用CTRL+U来删除一整行，另外，用户还可以通过按CTRL+L来刷新屏幕。如果要结束交谈，可由任何一方按下CTRL+C来中断连接，但在结束对话前最好道声“再见”，并等待对方回应。linux中talk命令程序结束时，在屏幕上将回显示一条信息：\n[Connection closing. Exiting] 并非每次要求对方交谈都能成功，有时对方没有登录，则linux中talk命令程序提示信息：\n[Your party is not logged on] 并退出；如果对方已登录，但因某种原因（如不是正在使用机器）没有响应，那么linux中talk命令程序将会每隔10秒钟给他发一条邀请信息，同时在自己的屏幕上显示：\n[Ringing your party again] 如果用户不愿等待，则可以按CTRL+C终止linux中talk命令程序。还有的时候系统可能出现下面的信息： [Checking for invitation on caller’s machine] 这说明双方的linux中talk命令程序不兼容，这时可以试试ntalk和ytalk命令，如果没有，就只好找系统管理员了。\n如果用户在做某些紧急工作（如编辑邮件）时不希望被linux中talk命令的邀请打搅，他可以使用命令：mesg n来暂时拒绝交谈，这时如果有用户邀请他交谈，只能得到提示信息：[Your party is refusing messages]\n10.2 电子邮件 mailx工具为用户提供电子邮件系统，可以给系统上其他用户发邮件，无论对方是否已经登录到系统。\n当用户使用mailx读取文件时，它处于命令模式，该模式的命令提示符是问号。\n   命令 功能     ! 让用户执行shell命令（shell转义）   cd directory 切换到指定的目录direction，如果没有指定目录，则切换到主目录   d 删除指定消息   f 显示消息头行   q 退出mail，并将消息从系统邮箱移去   h 显示当前消息头   m users 给指定用户users发送邮件   R messages 给消息messages发送者回复消息   r messages 给消息messages发送者和同一消息的其他所有接收者回复消息   s messages 保存消息到filename文件   t messages 显示指定消息messages   u messages 恢复已删除的指定消息messages   x 退出mailx，不将消息从系统邮箱中移去    mailx的~转义命令\n   命令 功能     ~? 显示~转义命令列表   ~! command 在编辑邮件时，让用户调用指定的shell命令command   ~ e 调用编辑器   ~ p 显示当前正编辑的消息   ~r filename 读取filename文件   ~\u0026lt; filename 读取filename文件   ~\u0026lt;! command 执行指定命令command   ~v 调用默认编辑器vi   ~q 推出输入模式   ~w filename 将当前正编辑的消息写到filename文件中    第11章 GNU 工具链 11.1 Gnu工具链 Gnu toolchain是开发操作系统、应用程序的一套完整的程序和库，包括gcc、gdb、glibc：\n11.2 gcc 是一族编译器，包括c、c++、go、java等\n前端+后端\n  .c为后缀的文件，C语言源代码文件；\n  .a为后缀的文件，是由目标文件构成的档案库文件；\n  .C、.cc或.cxx 为后缀的文件，是C++源代码文件；\n  .h为后缀的文件，是程序所包含的头文件；\n  .i 为后缀的文件，是已经预处理过的C源代码文件；\n  .ii为后缀的文件，是已经预处理过的C++源代码文件；\n  .m为后缀的文件，是Objective-C源代码文件；\n  .o为后缀的文件，是编译后的目标文件；\n  .s为后缀的文件，是汇编语言源代码文件；\n  .S为后缀的文件，是经过预编译的汇编语言源代码文件。\n  C语言编译过程\n  gcc -E hello.c -o hello.i\n  gcc -S hello.i -o hello.s\n  gcc -c hello.s -o hello.o\n  gcc -o hello hello.o\n  11.3 gdb  gdb program     命令 缩写 描述     list l 打印当前位置源码   break b 设置断点   run r 运行程序   step s 单步，进入函数   next n 单步，不进入函数   print p 打印变量   continue c 继续运行   backtrace bt 显示调用栈   info threads  显示线程   thread n  切换线程   set scheduler-locking on  关闭线程调度    11.4 makefile Makefile用于工程组织和编译，与常见的命令式语言不同，它是一种依赖推导语言。\nShell语言：变量定义+命令执行\nMakefile：变量定义+依赖描述\n显式规则与隐式规则\n  %.o: %.c\n  $(COMPILE.c) $(OUTPUT_OPTION) $\u0026lt;\n  推导规则\n  检查目标和依赖文件的时间，如果依赖更新，则执行动作\n  显式规则 \u0026gt; 隐式规则\n  推导过程\n  动态规划\n  从target出发，枚举所有规则，直到依赖可达\n  11.5 cmake cross platform make跨平台自动化建置系统。\nCmake vs Makefile\n Makefile的依赖推导不直观 Cmake的语法设计采用命令式 跨平台，可以导出为makefile、sln等  Cmake在不同平台上生成不同的本地化脚本\n Linux下的Gnu Makefile Visual Studio的sln Google等ninja  Cmake管理的代码编译主要有两步：\n  利用cmake生成本地编译脚本\n  利用本地脚本编译程序\n  基本语法\n  定义工程\n  设置变量\n  添加可执行目标\n  添加递归目录\n  添加静态库、动态库\n  条件分支\n  定制命令和目标add_custom_command/add_custom_target\n  11.6 git 虽然之前学了下git，但学得不够深入，最近重新看了一下git的相关知识\nGit 工作区、暂存区和版本库概念：\n **工作区：**就是你在电脑里能看到的目录。 **暂存区：**英文叫 stage 或 index。一般存放在 .git 目录下的 index 文件（.git/index）中，所以我们把暂存区有时也叫作索引（index）。 **版本库：**工作区有一个隐藏目录 .git，这个不算工作区，而是 Git 的版本库。  下面这个图展示了工作区、版本库中的暂存区和版本库之间的关系：\ngit clone、git push、git add 、git commit、git checkout、git pull\n以前只会git push后面不加东西，然后在推送blog时出现了一些问题\n命令格式如下：\n1git push \u0026lt;远程主机名\u0026gt; \u0026lt;本地分支名\u0026gt;:\u0026lt;远程分支名\u0026gt; 如果本地分支名与远程分支名相同，则可以省略冒号：\n1git push \u0026lt;远程主机名\u0026gt; \u0026lt;本地分支名\u0026gt; 实例\n以下命令将本地的 master 分支推送到 origin 主机的 master 分支。\n1$ git push origin master 相等于：\n1$ git push origin master:master 如果本地版本与远程版本有差异，但又要强制推送可以使用 \u0026ndash;force 参数：\n1git push --force origin master 删除主机但分支可以使用 \u0026ndash;delete 参数，以下命令表示删除 origin 主机的 master 分支：\n1git push origin --delete master 分支\n想push时不影响原来的远程分支，怎么办？回退很麻烦，那怎么办？\n创建分支命令：\n1git branch (branchname) 切换分支命令:\n1git checkout (branchname) 当你切换分支的时候，Git 会用该分支的最后提交的快照替换你的工作目录的内容， 所以多个分支不需要多个目录。\n合并分支命令:\n1git merge 你可以多次合并到统一分支， 也可以选择在合并之后直接删除被并入的分支。\n开始前我们先创建一个测试目录：\n1$ mkdir gitdemo$ cd gitdemo/$ git initInitialized empty Git repository...$ touch README$ git add README$ git commit -m \u0026#39;第一次版本提交\u0026#39;[master (root-commit) 3b58100] 第一次版本提交 1 file changed, 0 insertions(+), 0 deletions(-) create mode 100644 README  Git 分支管理 列出分支 列出分支基本命令：\n1git branch 没有参数时，git branch 会列出你在本地的分支。\n1$ git branch* master 此例的意思就是，我们有一个叫做 master 的分支，并且该分支是当前分支。\n当你执行 git init 的时候，默认情况下 Git 就会为你创建 master 分支。\n如果我们要手动创建一个分支。执行 git branch (branchname) 即可。\n1$ git branch testing$ git branch* master testing 现在我们可以看到，有了一个新分支 testing。\n当你以此方式在上次提交更新之后创建了新分支，如果后来又有更新提交， 然后又切换到了 testing 分支，Git 将还原你的工作目录到你创建分支时候的样子。\n接下来我们将演示如何切换分支，我们用 git checkout (branch) 切换到我们要修改的分支。\n1$ lsREADME$ echo \u0026#39;runoob.com\u0026#39; \u0026gt; test.txt$ git add .$ git commit -m \u0026#39;add test.txt\u0026#39;[master 3e92c19] add test.txt 1 file changed, 1 insertion(+) create mode 100644 test.txt$ lsREADME test.txt$ git checkout testingSwitched to branch \u0026#39;testing\u0026#39;$ lsREADME 当我们切换到 testing 分支的时候，我们添加的新文件 test.txt 被移除了。切换回 master 分支的时候，它们有重新出现了。\n1$ git checkout masterSwitched to branch \u0026#39;master\u0026#39;$ lsREADME test.txt 我们也可以使用 git checkout -b (branchname) 命令来创建新分支并立即切换到该分支下，从而在该分支中操作。\n1$ git checkout -b newtestSwitched to a new branch \u0026#39;newtest\u0026#39;$ git rm test.txt rm \u0026#39;test.txt\u0026#39;$ lsREADME$ touch runoob.php$ git add .$ git commit -am \u0026#39;removed test.txt、add runoob.php\u0026#39;[newtest c1501a2] removed test.txt、add runoob.php 2 files changed, 1 deletion(-) create mode 100644 runoob.php delete mode 100644 test.txt$ lsREADME runoob.php$ git checkout masterSwitched to branch \u0026#39;master\u0026#39;$ lsREADME test.txt 如你所见，我们创建了一个分支，在该分支的上移除了一些文件 test.txt，并添加了 runoob.php 文件，然后切换回我们的主分支，删除的 test.txt 文件又回来了，且新增加的 runoob.php 不存在主分支中。\n使用分支将工作切分开来，从而让我们能够在不同开发环境中做事，并来回切换。\n删除分支 删除分支命令：\n1git branch -d (branchname) 例如我们要删除 testing 分支：\n1$ git branch* master testing$ git branch -d testingDeleted branch testing (was 85fc7e7).$ git branch* master 分支合并 一旦某分支有了独立内容，你终究会希望将它合并回到你的主分支。 你可以使用以下命令将任何分支合并到当前分支中去：\n1git merge$ git branch* master newtest$ lsREADME test.txt$ git merge newtestUpdating 3e92c19..c1501a2Fast-forward runoob.php | 0 test.txt | 1 - 2 files changed, 1 deletion(-) create mode 100644 runoob.php delete mode 100644 test.txt$ lsREADME runoob.php 以上实例中我们将 newtest 分支合并到主分支去，test.txt 文件被删除。\n合并完后就可以删除分支:\n1$ git branch -d newtestDeleted branch newtest (was c1501a2). 删除后， 就只剩下 master 分支了：\n1$ git branch* master 合并冲突 合并并不仅仅是简单的文件添加、移除的操作，Git 也会合并修改。\n1$ git branch* master$ cat runoob.php 首先，我们创建一个叫做 change_site 的分支，切换过去，我们将 runoob.php 内容改为:\n1\u0026lt;?phpecho \u0026#39;runoob\u0026#39;;?\u0026gt; 创建 change_site 分支：\n1$ git checkout -b change_siteSwitched to a new branch \u0026#39;change_site\u0026#39;$ vim runoob.php$ head -3 runoob.php\u0026lt;?phpecho \u0026#39;runoob\u0026#39;;?\u0026gt;$ git commit -am \u0026#39;changed the runoob.php\u0026#39;[change_site 7774248] changed the runoob.php 1 file changed, 3 insertions(+) 将修改的内容提交到 change_site 分支中。 现在，假如切换回 master 分支我们可以看内容恢复到我们修改前的(空文件，没有代码)，我们再次修改 runoob.php 文件。\n1$ git checkout master 2Switched to branch \u0026#39;master\u0026#39; 3$ cat runoob.php 4$ vim runoob.php # 修改内容如下 5$ cat runoob.php 6\u0026lt;?php 7echo 1; 8?\u0026gt; 9$ git diff 10diff --git a/runoob.php b/runoob.php 11index e69de29..ac60739 100644 12--- a/runoob.php 13+++ b/runoob.php 14@@ -0,0 +1,3 @@ 15+\u0026lt;?php 16+echo 1; 17+?\u0026gt; 18$ git commit -am \u0026#39;修改代码\u0026#39; 19[master c68142b] 修改代码 20 1 file changed, 3 insertions(+) 现在这些改变已经记录到我的 \u0026ldquo;master\u0026rdquo; 分支了。接下来我们将 \u0026ldquo;change_site\u0026rdquo; 分支合并过来。\n1$ git merge change_site 2Auto-merging runoob.php 3CONFLICT (content): Merge conflict in runoob.php 4Automatic merge failed; fix conflicts and then commit the result. 5 6$ cat runoob.php # 代开文件，看到冲突内容 7\u0026lt;?php 8\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt; HEAD 9echo 1; 10======= 11echo \u0026#39;runoob\u0026#39;; 12\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt; change_site 13?\u0026gt; 我们将前一个分支合并到 master 分支，一个合并冲突就出现了，接下来我们需要手动去修改它。\n1$ vim runoob.php 2$ cat runoob.php 3\u0026lt;?php 4echo 1; 5echo \u0026#39;runoob\u0026#39;; 6?\u0026gt; 7$ git diff 8diff --cc runoob.php 9index ac60739,b63d7d7..0000000 10--- a/runoob.php 11+++ b/runoob.php 12@@@ -1,3 -1,3 +1,4 @@@ 13 \u0026lt;?php 14 +echo 1; 15+ echo \u0026#39;runoob\u0026#39;; 16 ?\u0026gt; 在 Git 中，我们可以用 git add 要告诉 Git 文件冲突已经解决\n1$ git status -sUU runoob.php$ git add runoob.php$ git status -sM runoob.php$ git commit[master 88afe0e] Merge branch \u0026#39;change_site\u0026#39; 现在我们成功解决了合并中的冲突，并提交了结果。\n以上文字大多数摘自runoob.com，我感觉是写得非常有条理了，另外介绍一个学习gitbranch的神奇的网站，无聊的时候可以练练手。\nhttps://learngitbranching.js.org/\n第12章 Shell编程 Shell是一种语言，bash、csh\n Unix的传统是提供基本的功能，由用户自行扩展，包括自己编写shell脚本  12.1.1 编写简单脚本 1endwsl@LAPTOP-U1E6STIA:~$ cat \u0026lt;\u0026lt;EOF\u0026gt;\u0026gt; won.list\u0026gt; ls\u0026gt; -bash: warning: here-document at line 74 delimited by end-of-file (wanted `EOF\u0026#39;)endwsl@LAPTOP-U1E6STIA:~$ cat won.listls 12.1.2 执行脚本 执行脚本 sh won.list :\n1endwsl@LAPTOP-U1E6STIA:~$ sh won.list- ew ew.list goodstuff new.list vinew won.list xxxscriptendwsl@LAPTOP-U1E6STIA:~$ 另一种方法：chmod改变文件权限，使其变成可执行\n脚本工作原理\n  loader程序加载脚本，发现不是elf可执行文件，返回错误\n  bash收到错误，然后打开文件头部，发现是脚本\n  调用脚本执行\n  •基于兼容性考虑\n  #! /bin/sh\n  Debian上的/bin/sh符号链接指向dash\n  dash对标准的兼容性更好\n  12.2.1 使用特殊字符 echo换行：echo \u0026quot;\\nhello\\n\u0026quot;\n12.2.2 退出系统的方式 在shell脚本里写exit是没用的，因为shell会fork子进程来执行命令。\n12.2.3 点命令 可以使用点命令来阻止shell创建子进程。\n12.2.4 读取命令：read 从标准输入设备读取用户输入，并将值存入用户自定义变量中。\n12.3.1 注释 12.3.2 变量 字符串类型，具体内容在前面讲过。\n12.3.3 命令行参数 shell脚本可以从命令行最多读取10个命令行参数存入特殊变量，命令行参数是用户输入命令后所跟的数据项，通常用空格分隔。这些变量按顺序从1到9计数。\n   参数变量     $1-$9，${10}表示参数   $0表示被调用脚本的名字   $#表示参数个数   $*将所有参数使用$IFS隔开，形成一个字符串   $@是每个参数一行，将参数隔开，实际上是多个字符串，可以用在for循环   $$表示当前进程id    特殊变量\n  $?表示进程退出状态\n  ls -al hello\n  echo $? 前面命令退出的状态\n  另外一个给变量赋值的方式是set\nset hello \u0026quot;I love bash\u0026quot; world\n1endwsl@LAPTOP-U1E6STIA:~$ echo $0-bashendwsl@LAPTOP-U1E6STIA:~$ echo $#0endwsl@LAPTOP-U1E6STIA:~$ set hello \u0026#34;i love\u0026#34; worldendwsl@LAPTOP-U1E6STIA:~$ echo $#3 //3个参数hello 和\u0026#34;i love\u0026#34;和worldendwsl@LAPTOP-U1E6STIA:~$ echo $1helloendwsl@LAPTOP-U1E6STIA:~$ echo $2i love bashendwsl@LAPTOP-U1E6STIA:~$ echo $3worldendwsl@LAPTOP-U1E6STIA:~$ echo $* //$*和$@相似hello i love world 1endwsl@LAPTOP-U1E6STIA:~$ echo $*hello i love worldendwsl@LAPTOP-U1E6STIA:~$ echo $@hello i love world 12.3.4 条件与测试 if-then-elif结构：\n1if条件; then command1elif command2then command3else command4fi 真或假：test命令\n实际上，if语句中括住条件的方括号是test命令的一种特殊形式。\n例子：\n1minatoxeon@OMEN:~$ cat eg_conditionechoecho \u0026#34;enter y or n:\\c\u0026#34;read condif [ $cond = y ]then echo \u0026#34;you enter y\u0026#34;else echo \u0026#34;you not enter n\u0026#34;fiechoexit 0minatoxeon@OMEN:~$ sh eg_conditionenter y or n:yyou enter yminatoxeon@OMEN:~$ sh eg_conditionenter y or n:llyou not enter n 12.3.5 不同类型的判断 不单单是相等的判断，test可以进行多种类型的判断\n   操作符 例子 含义     -eq a -eq b a是否等于b   -ne a -ne b a是否不等于b   -gt a -gt b a是否大于b   -ge a -ge b a是否大于大于b   -lt a -lt b a是否小于b   -le a -le b a是否小于等于b    test还可以比较字符串\n    操作符 示例 说明     = “$STR1” = “STR2” 两个字符串是否相同   != “$STR1” != “STR2” 两个字符串是否不同   -n -n “$STR” 字符串不是null   -z -z “$STR” 字符串是null    注意：在引用变量做字符串测试时，一定要加引号\n操作符两侧必须有空格\n[ … ]中括号必须有空格 [ \u0026quot;$VAR1\u0026quot; = \u0026quot;VAR3\u0026quot; ]\n文件\n12.3.6 参数替换 用户可以检验参数的值并根据选项改变它的值。\n格式为${parameter:optionchar word}\n变量替换\n   替换操作 功能     ${VAR:-word} 如果变量不存在，返回word #变量不会创建   ${VAR:=word} 如果变量不存在，设置VAR变量为word，返回word   ${VAR:?message} 如果变量不存在，打印message，退出，但交互shell不会退出   ${VAR:+word} 如果变量存在，返回word；否则返回null    1endwsl@LAPTOP-U1E6STIA:~$ echo ${VAR:-world} #变量不会创建worldendwsl@LAPTOP-U1E6STIA:~$ echo $VAR ${var:?meg}通常用来显示错误信息\n12.4 算术表达式 12.4.1 算术运算：expr命令 在powershell里可以直接输入1+1，会得到2\n但是在shell里直接输入1+1不会有结果，因为Shell会把1单作是字符串而不是变量，那么要想在shell里面计算1+1怎么办？\n1expr 1+1 expr提供数字和非数字的关系运算符\n12.4.2 算术运算：let命令 let命令与expr命令类似，并可以相互替换。\nlet命令自动使用变量的值：\n1minatoxeon@OMEN:~$ x=100minatoxeon@OMEN:~$ let x=x+1minatoxeon@OMEN:~$ echo $x101 let命令的缩写：双括号(())\n下面就是i++的经典问题\n1endwsl@LAPTOP-U1E6STIA:~$ i=4endwsl@LAPTOP-U1E6STIA:~$ echo $i4endwsl@LAPTOP-U1E6STIA:~$ echo $((i++)) $i4 5endwsl@LAPTOP-U1E6STIA:~$ echo $((++i)) $i6 6 12.5 循环结构  Shell提供三种循环：for、while、until 循环与分支类似，都带有一定的结构，是shell语言的支持  12.5.1 for循环：for-in-done 结构 1for variablein list-of-valuesdo\tcommands ...\tlast-commanddone 例子：\n1endwsl@LAPTOP-U1E6STIA:~$ cat sum1.sh#! /bin/bashtotal=0for i in \u0026#34;$@\u0026#34;do total=$(($total + $i)) printf \u0026#34;$i + \u0026#34;doneprintf \u0026#34;\\b\\b= $total\u0026#34; 12.5.2 while循环 直接上例子：\n1endwsl@LAPTOP-U1E6STIA:~$ cat sum.sh 2#! /bin/bash 3#这里的$#每经过一轮循环就会减1 4#位置参数可以用shift命令左移 5total=0 6while [ $# -gt 0 ]; do 7 total=$(($total + $1)) 8 printf \u0026#34;$1+ \u0026#34; 9 shift 10done 11printf \u0026#34;\\b\\b= $total\u0026#34; 12.5.3 until循环 1#! /bin/bash 2total=0 3until [ $# -le 0 ]; do 4 total=$(($total + $1)) 5 printf \u0026#34;$1+ \u0026#34; 6 shift 7done 8printf \u0026#34;\\b\\b= $total\u0026#34; 逻辑连接 这里的\u0026amp;\u0026amp;和||和预想的会很不一样，举例如下：\ncommand1 \u0026amp;\u0026amp; command2当command1正确执行，才会执行command2\n相当于：\n1if command1 : 2 command2 command1 || command2，当command1执行错误，才会执行command2\n1if !command1 : command2 代码分块 将多行命令用分号;隔开，再利用()将多条命令组合在一起\n1endwsl@LAPTOP-U1E6STIA:~$ (date ; echo $$)(date ; echo $$)+ dateMon 26 Apr 2021 09:07:31 PM CST+ echo 1717 算术表达式测试\n 利用$(())计算算术表达式 利用字符串比较 [ $((2+3)) = 5 ]; echo $? i=3; [ $((i+7)) = 10 ];echo $?  调试 替换处理后真实执行的指令，比如展开$$\n1endwsl@LAPTOP-U1E6STIA:~$ echo \u0026#34;hello world\u0026#34;hello worldendwsl@LAPTOP-U1E6STIA:~$ set -vxendwsl@LAPTOP-U1E6STIA:~$ echo \u0026#34;hello world\u0026#34;echo \u0026#34;hello world\u0026#34; #原始命令+ echo \u0026#39;hello world\u0026#39; #替换处理后真实执行的指令hello world# 指令结果endwsl@LAPTOP-U1E6STIA:~$  第13章 Shell脚本：编写应用程序 13.2 UNIX内核：信号 终止一个进程可以通过产生一个中断信号来终止进程。例如Del键、Break键和Ctrl-c键。\n有几类不同的事件导致内核向进程发送信号。信号编号表明它们代表的事件。\n   信号编号 信号名 含义     1 挂起 丢失终端连接   2 中断 按下任一中断键   3 退出 按下任一退出键   9 杀死 发出kill-9命令   15 终止 发出kill命令    挂起信号：信号1用来通知进程系统已经与终端失去联系。当用户终端和计算机的连线断开，或者电话线（用来调制解调器相连）断开时，产生该信号。在某些系统中，如果用户关闭终端，系统也会产生挂起信号。\n中断信号：当按下任何一个中断键时，产生信号2。中断键可以是Del键、Break键或者Ctrl-c键。\n退出信号：当按下Ctrl-\\键时，产生信号3。在进程终止之前，将进行内存信息转储。\n终止信号：信号9和15由kill命令产生。信号15是默认的信号。信号9和15都使收到信号的进程终止。\nkill -l查看信号表\n1endwsl@LAPTOP-U1E6STIA:~$ kill -l 1) SIGHUP 2) SIGINT 3) SIGQUIT 4) SIGILL 5) SIGTRAP 6) SIGABRT 7) SIGBUS 8) SIGFPE 9) SIGKILL 10) SIGUSR111) SIGSEGV 12) SIGUSR2 13) SIGPIPE 14) SIGALRM 15) SIGTERM16) SIGSTKFLT 17) SIGCHLD 18) SIGCONT 19) SIGSTOP 20) SIGTSTP21) SIGTTIN 22) SIGTTOU 23) SIGURG 24) SIGXCPU 25) SIGXFSZ26) SIGVTALRM 27) SIGPROF 28) SIGWINCH 29) SIGIO 30) SIGPWR31) SIGSYS 34) SIGRTMIN 35) SIGRTMIN+1 36) SIGRTMIN+2 37) SIGRTMIN+338) SIGRTMIN+4 39) SIGRTMIN+5 40) SIGRTMIN+6 41) SIGRTMIN+7 42) SIGRTMIN+843) SIGRTMIN+9 44) SIGRTMIN+10 45) SIGRTMIN+11 46) SIGRTMIN+12 47) SIGRTMIN+1348) SIGRTMIN+14 49) SIGRTMIN+15 50) SIGRTMAX-14 51) SIGRTMAX-13 52) SIGRTMAX-1253) SIGRTMAX-11 54) SIGRTMAX-10 55) SIGRTMAX-9 56) SIGRTMAX-8 57) SIGRTMAX-758) SIGRTMAX-6 59) SIGRTMAX-5 60) SIGRTMAX-4 61) SIGRTMAX-3 62) SIGRTMAX-263) SIGRTMAX-1 64) SIGRTMAX 13.2.1 捕捉信号：trap命令 当进程接收到任何信号时，其默认处理功能是立即终止。使用trap命令可以改变进程的默认处理功能，执行指定的处理功能。\ntrap命令的格式：trap\u0026quot;optional commands\u0026quot;signal numbers\ncommands部分是可选的。如果有这一部分，当进程收到任一指定捕捉信号时，执行这些命令。\n注意：trap指定的命令必须用单引号或者双引号括起来。\n说明：1. 可以指定捕捉多个信号。\n​\t2.信号编号是与用户希望用trap命令捕捉的信号相关联的数字。\n13.2.2 捕捉复位 当希望在脚本中的一部分捕捉信号，而另一部分不捕捉信号时，捕捉复位命令就很有用。\n例如：\n $trap \u0026quot; \u0026quot;2 3 15 忽略中断、退出和终止信号，如果按下这些键中的任一个，脚本继续运行。 $trap 2 3 15 复位指定的信号，就是恢复中断、退出和终止键。按下些键中的任一个，正在运行的脚本就会终止。  13.2.3 设置终端参数：stty命令 stty命令用来设置和显示终端属性。不带参数的stty命令显示指定的一组设置。用-a选项可以列出所有的终端设置。\n•stty设定终端模式\n stty –echo禁止回显，输入口令时，同时也会把命令会先禁了 stty echo打开回显，撤销上一步  13.3 对终端的进一步讨论 UNIX操作系统支持多钟终端类型，功能不限于清屏，还有粗字体、闪烁、下划线，等等。利用这些特性能使屏幕显示更有意义或更美观。\n13.3.1 终端数据库：terminfo文件 terminfo数据库是一个文本文件，其中包括各种终端类型的描述。数据库里的每一类终端都有一个功能列表。\n13.3.2 设置终端功能：tput命令 tput实用程序允许用户打印出任一功能的值。这样就可以在shell编程中使用终端的功能。\n•tput向终端缓冲输出控制字符\n•tput clear清屏\n•tput cup row column移动光标到row行column列\n终端功能的简单列表：\n   参数 功能     bel 回显终端的响铃字符   blink 闪烁显示   bold 粗体显示   clear 清屏   cup r c 将光标移到r行c列   dlim 使显示变暗   ed 从光标位置到屏幕底清屏   el 清除从光标位置到行末的字符   smso 启动突显模式   rmso 结束突显模式   smul 启动下划线模式   rmul 结束下划线模式   rev 反色显示，白底上显示黑色   sgr 0 关闭所有属性    13.4 其他命令 多路分支：case结构 当需要使用许多elif语句时，用case结构更好。\ncase、in和esac（case的反序）是保留字（关键字）。case和esac之间的语句称为case结构体。\nshell执行case语句时，将变量的内容与每一个模式比较，知道发现一个匹配或者shell到达关键字esac。shell执行与匹配模式相关联的命令。默认情况用*)表示，必须是程序的最后一种情况。每一种情况用两个分号（；；）结束。\n其他命令 磁盘命令\ndu\n1endwsl@LAPTOP-U1E6STIA:~$ df 2Filesystem 1K-blocks Used Available Use% Mounted on 3/dev/sdb 263174212 788056 248948000 1% / 4tmpfs 6475860 0 6475860 0% /mnt/wsl 5tools 209715196 192647796 17067400 92% /init 6none 6473568 0 6473568 0% /dev 7none 6475860 4 6475856 1% /run 8none 6475860 0 6475860 0% /run/lock 9none 6475860 0 6475860 0% /run/shm 10none 6475860 0 6475860 0% /run/user 11tmpfs 6475860 0 6475860 0% /sys/fs/cgroup 12C:\\ 209715196 192647796 17067400 92% /mnt/c 13D:\\ 289083388 253954812 35128576 88% /mnt/d tar\n•tar zcfv压缩成.tar.gz文件\n•tar zxfv解压.tar.gz文件\n•tar Jcfv压缩成.tar.xz文件\n•tar Jxfv解压.tar.xz文件\n•tar jcfv压缩成.tar.bz2文件\n•tar jxfv解压.tar.bz2文件\nchown修改文件目录的owner,修改inode\nchgrp修改文件目录的group\n","date":"2021-06-17T13:50:16+08:00","permalink":"https://uest.xyz/posts/unix%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/","section":"posts","tags":null,"title":"Unix读书笔记"},{"categories":null,"contents":"19. 删除链表的倒数第 N 个结点 难度中等\n给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。\n**进阶：**你能尝试使用一趟扫描实现吗？\n示例 1：\n1输入：head = [1,2,3,4,5], n = 2 2输出：[1,2,3,5] 示例 2：\n1输入：head = [1], n = 1 2输出：[] 示例 3：\n1输入：head = [1,2], n = 1 2输出：[1] 提示：\n 链表中结点的数目为 sz 1 \u0026lt;= sz \u0026lt;= 30 0 \u0026lt;= Node.val \u0026lt;= 100 1 \u0026lt;= n \u0026lt;= sz  相比昨天写的147题，这个明显就简单很多，一次遍历解题的关键：两个间隔长度为n的指针，当第二个指针滑到最后时，第一个指针就达到的倒数第n个，此时删除这一个节点就行了。\n小技巧，添加dummy节点，以防第一个节点被删除。\n1 public static ListNode removeNthFromEnd(ListNode head, int n) { 2 ListNode dummyHead =new ListNode(0); 3 dummyHead.next=head; 4 ListNode pre=dummyHead; 5 ListNode last=dummyHead; 6 for(int i=0;i\u0026lt;n;i++){ 7 last=last.next; 8 } 9 while(last.next!=null){ 10 last=last.next; 11 pre=pre.next; 12 } 13 pre.next=pre.next.next; 14 15 16 return dummyHead.next; 17 } ","date":"2021-05-05T23:26:12+08:00","permalink":"https://uest.xyz/posts/19%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACn%E4%B8%AA%E7%BB%93%E7%82%B9/","section":"posts","tags":null,"title":"19.删除链表的倒数第N个结点"},{"categories":null,"contents":"147. 对链表进行插入排序  对链表进行插入排序。\n插入排序的动画演示如上。从第一个元素开始，该链表可以被认为已经部分排序（用黑色表示）。 每次迭代时，从输入数据中移除一个元素（用红色表示），并原地将其插入到已排好序的链表中。\n插入排序算法：\n 插入排序是迭代的，每次只移动一个元素，直到所有元素可以形成一个有序的输出列表。 每次迭代中，插入排序只从输入数据中移除一个待排序的元素，找到它在序列中适当的位置，并将其插入。 重复直到所有输入数据插入完为止。  示例 1：\n1输入: 4-\u0026gt;2-\u0026gt;1-\u0026gt;3 2输出: 1-\u0026gt;2-\u0026gt;3-\u0026gt;4 示例 2：\n1输入: -1-\u0026gt;5-\u0026gt;3-\u0026gt;4-\u0026gt;0 2输出: -1-\u0026gt;0-\u0026gt;3-\u0026gt;4-\u0026gt;5  看起来很简单的插入排序花了我一晚上.\n插入排序不需要多讲，题面总结得很精辟，每一步将一个待排序的数据插入到前面已经排好序的有序序列中，直到插完所有元素为止。在其实现过程使用双层循环，外层循环对除了第一个元素之外的所有元素，内层循环对当前元素前面有序表进行待插入位置查找，并进行移动。\n插入排序的平均时间复杂度也是 O(n^2)，空间复杂度为常数阶 O(1)，具体时间复杂度和数组的有序性也是有关联的。\n插入排序中，当待排序数组是有序时，是最优的情况，只需当前数跟前一个数比较一下就可以了，这时一共需要比较 N-1 次，时间复杂度为 O(N)。最坏的情况是待排序数组是逆序的，此时需要比较次数最多，最坏的情况是 O(n^2)。\n但是 链表就不能简单移动了，而是要做到插入（把节点插入相应的地方），遍历找到要插入的地方以后，还要实现交换操作（和数组最大的不同也是最难的地方）\n1 public static ListNode insertionSortList(ListNode head) { 2 3 ListNode todo=head.next; 4 /*最坑的地方是在画图，总结到一个经验，画图其实不如调试，调试起来看变化，再画图微调最好，傻乎乎画图最后会绕死进去 5* 添加一个表头节点非常有必要，这还是看题解发现的，不然插入时只能分情况讨论越来越复杂 6* pre节点防止断裂，注意要及时更新pre节点 7* todo这种变量名就不知所云，下次记得用cur 8* */ 9 10 ListNode dummyHead=new ListNode(0); 11 dummyHead.next=head; 12 ListNode todohead=dummyHead; 13 ListNode todopre=dummyHead.next; 14 while (todo!=null){ 15 16 while(todohead.next!=null\u0026amp;\u0026amp; todo.val\u0026gt;todohead.next.val){ 17 todohead=todohead.next; 18 19 } 20 if(todo==todohead.next){ 21/*不能用值的比较！！！！，这个是作为循环终止的条件（使用continue直接下一步，防止进行5步交换）：等到todohead.next循环到todo时，让todo后移，注意不仅仅要使得todo后移，todopre也要后移，todohead要归零*/ 22 todo=todo.next; 23 todopre=todopre.next; 24 todohead=dummyHead; 25 continue; 26 } 27 todopre.next=todo.next; 28 todo.next=todohead.next; 29 todohead.next=todo; 30 todo=todopre.next; 31 todohead=dummyHead; 32 33 //这5步画图吧 34 } 35 return dummyHead.next; 36 } ","date":"2021-05-04T22:08:41+08:00","permalink":"https://uest.xyz/posts/147%E9%93%BE%E8%A1%A8%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/","section":"posts","tags":null,"title":"147.链表插入排序"},{"categories":null,"contents":"1class moveZeroes { 2 public static void moveZeroes(int[] nums){ 3//快慢指针的思想和removeElement这一题有着异曲同工之妙 4 int i=0,j=0;//i是慢指针 指向第一个0，j是快指针 指向第一个非0 5 for(;;i++){ 6 if(nums[i]==0)break;//虽然我也觉得这里的循环写得很奇怪，但是思想还是很清晰的：第一个找到0！！如果出界就退出 7 if(i+1==nums.length) return; 8 } 9 10 j=i+1;//j是从i右边开始起步的 11 for (;;j++){ 12 if(j\u0026gt;=nums.length) return; 13 if(nums[j]!=0)break; 14 15 } 16 // System.out.println(i+\u0026#34;j\u0026#34;+j+\u0026#34;----------\u0026#34;); 17 for(;j\u0026lt;nums.length;j++){ 18 if(nums[j]!=0){ 19 if(nums[j]!=0){ 20 nums[i]=nums[j]; 21 nums[j]=0; 22 i++; 23 } 24 } 25 26 } 27 } 28 public static void main(String[] args) { 29 int []nums={0,0}; 30 moveZeroes(nums); 31 for(int i=0;i\u0026lt;nums.length;i++){ 32 System.out.println(nums[i]); 33 } 34 35 } 36} ","date":"2021-04-30T17:01:19+08:00","permalink":"https://uest.xyz/posts/283.%E7%A7%BB%E5%8A%A80/","section":"posts","tags":["Leetcode","Medium"],"title":"283.移动0"},{"categories":null,"contents":"来源https://sspai.com/post/59904\n利用github + hugo 搭建轻量化的blog ，非常有用的教程！\n1. 安装 Git 和 Go 使用Hugo前需要安装Git 和 Go 语言开发环境，点击对应网址下载安装包即可。\n2. 安装Hugo 网上存在很多用工具安装的方式，我这里讲述一个我认为最简单的方式，不用涉及太多的代码（本方法针对pc）。\n（1）在Hugo的官网中选择想要的版本下载zip，将其中的hugo.exe文件解压到想要的地方，比如 C:\\Hugo\\bin。\n（2）将Hugo添加到Windows的环境变量 PATH中。\n（3）添加完PATH后，打开Git Bash 输入 hugo version 出现hugo static site generator相关信息表示安装完成。\n3. 生成博客 （1）打开Git Bash 输入hugo new site \u0026quot;你的文件名字\u0026quot;，便可以生成一个用于存放博客的文件夹。\n（2）安装主题。\n不同于hexo，hugo没有自带主题，所以建立完文件夹后要导入主题文件。导入主题方式和hexo相似，可以用git clone 的方式，也可以到相应主题的github中下载zip文件然后解压到自己博客的themes文件夹中。\n推荐几个主题：Pure、Even、Coder\n官网主题库：Hugo Themes\n（3）配置文件\nHugo配置文件放置在源文件下，并且支持三种格式：toml，yaml，yml。这个配置文件可以直接从主题文件中的exampleSite 里copy到博客文件夹下，然后进行修改。\n 注意点1：有些主题没有提供相应的配置文件，得进行自己修改，不建议选用这类主题。 注意点2：配置文件中要确保里面的主题名字和你themes文件夹中相应的主题文件夹名字一样，比如我的主题是pure，那么配置文件里的theme = pure，并且themes 文件夹中也有一个pure的文件夹。这是为了保证工具能依据名字找到相应的主题文件。  （4）生成博文\n在 Git Bash 中输入 hugo new posts/xxxx.md，这时候就会在文件夹 content/posts形成你要的markdown文件，打开进行编辑即可。\n（5）渲染查看效果\n在博客文件夹中打开Git Bash，输入 hugo server，然后打开 http://localhost:1313/ 来查看效果。注意，markdown文件中的 front matter 部分有一个draft 参数，如果draft设置为true 则可正常渲染，如果设置为false则不予以渲染。相应的如果想查看全部效果则输入hugo server -D 表示将草稿文件也进行渲染。\n4. 代码托管 这里主要以GitHub 作为代码托管，假定你已经建立了一个xxx.github.io的一个仓库。官方提供了三四种上传方式，本文采用生成docs的方式进行部署，个人认为这种方式比较简单明了。\n（1）修改配置文件。在配置文件config.toml中添加publishDir = docs，其他格式的配置文件类似。\n（2）打开Git Bash，输入hugo，就会发现博客文件中出现了docs文件夹，这是因为hugo将网页的信息都存储在docs里，而不是public中。\n（3）在博客文件夹中，打开Git Bash，依次输入以下代码（注意 git remote add 后跟随自己github的对应地址）：\n1git remote add origin https://github.com/xxxxx/xxxx.github.io.git 2git add . 3git commit -m \u0026#34;first commit\u0026#34; 4git push -u origin master （4）在GitHub对应的仓库设置中，将Github Pages source改成branch/docs 。\n（5）这时候点击网址会发现内容已经成功渲染了，但是跳转连接出现问题，这是因为我们没有在配置文件中的baseURL中更新我们未来发布的网址链接。因此我们将GitHub Pages 对应的网址进行复制然后添加到配置文件的第一个 baseURL中，重新进行第二步和第三步即可。\n","date":"2021-04-27T21:50:40+08:00","permalink":"https://uest.xyz/posts/%E6%90%AD%E5%BB%BA%E4%B8%8E%E5%8F%91%E5%B8%83blog/","section":"posts","tags":null,"title":"搭建与发布blog"},{"categories":null,"contents":"  这种链表题一定要画图\n  头插法\n  遍历原链表+每次插入到新表最前面\n206. 反转链表 难度简单\n给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。\n示例 1：\n1输入：head = [1,2,3,4,5] 2输出：[5,4,3,2,1] 示例 2：\n1输入：head = [1,2] 2输出：[2,1] 示例 3：\n1输入：head = [] 2输出：[] 提示：\n 链表中节点的数目范围是 [0, 5000] -5000 \u0026lt;= Node.val \u0026lt;= 5000    1package Test; 2class ListNode { 3 int val; 4 ListNode next; 5 ListNode() {} 6 ListNode(int val) { this.val = val; } 7 ListNode(int val, ListNode next) { this.val = val; this.next = next; } 8 }5t 9 10class Test { 11 public static ListNode reverseList(ListNode head){ 12 ListNode first= new ListNode(); 13 ListNode copy; 14 15 if(head!=null){ 16 first.val=head.val; 17 copy=head.next; 18 }else return head; 19 while (copy!=null){ 20 ListNode temp= new ListNode(); 21 temp.val=copy.val; 22 temp.next=first; 23 copy=copy.next; 24 first=temp;//每次first指针前移，让他始终指向第一个元素 25 } 26 return first; 27 } 28 public static void main(String[] args) { 29 ListNode a=new ListNode(5); 30 a.next=new ListNode(4); 31 a.next.next=new ListNode(3); 32 ListNode b=reverseList(a); 33 while(b!=null){ 34 System.out.println(b.val); 35 b=b.next; 36 } 37 } 38} 39 ","date":"2021-04-27T20:27:17+08:00","permalink":"https://uest.xyz/posts/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/","section":"posts","tags":null,"title":"反转链表"},{"categories":null,"contents":"评价手机免不了打打嘴炮，写写垃圾，以下为云评测，如有不对的地方敬请指教。\n1.K40系列\nK40系列只有标准版是比较出众的，可以说把性价比做到了极致，卢伟冰可以说很好地完成了雷军交给红米的任务：极致性价比，留下小米的学生党和性价比党用户，并与realme和iqoo相比不落下风。redmi没有品牌转型的任务，价位段封顶4000元，不需要使用最新的技术，所以小米的120W快充不会下放redmi，红米今年的充电上限还是33w。这一点和iqoo不一样，iqoo作为19年的新品牌，初期仍需要打品牌，做充分的推广。所以iqoo从20年失败的iqoo3到120w的iqoo5p，再到今年的iqoo7，努力想做高端手机。\n红米今年K40系列采用几乎相同的磨具，只在SoC和摄像头做区分，pro的升级点可以说少得可怜，3699的pro+甚至还是33w的快充，只能看做成pro的大内存版，没有充足的理由让人掏钱买pro+；这一点，是redmi头顶上有小米11的无奈，如果小米数字旗舰站稳4999价位，那么红米才会有充足的加价空间。\n采用相同的模具可以降低研发、制造、售后成本，降低售价，并且快速进行产能切换，哪款卖得好就生产哪一款，但是也造成了pro的平庸，无法增加更多的配置打动消费者，仅凭1个系列覆盖2000-4000价位段十分困难，所以才会有去年三种不同的屏幕形态的K30，ultra和s ultra\n小米一直希望极致性价比，但是性价比并不是出路。经过市场的磨练，除了小米，其他玩性价比的厂商都死了，虽然可以证明小米的牛逼，但同时也证明了性价比模式的脆弱。小米也意识到这一点，所以在19年时，将性价比的任务全部交给redmi，但是，红米的骨子里永远摆脱不了小米的基因，始终无法做切割。一是红米的独立性不足，战略受限于小米的高层。二是名字相近，红米==小米的印象已经深深刻入大众的骨子里。不像realme和oppo一加，iqoo和vivo，在绝大部分人眼里，红米就是小米的低端，小米就是中低端性价比手机品牌。而要打破这一品牌认知，没有3-5年的积累是不够的，而且需要在3-5年里在核心技术、渠道、售后超越oppo，vivo，才能做到最后的销量超越。\n（K40的顶配是3月初在小米商城用米金兑换的购买资格，日常用它来打paj，不算云评测了哈，在性能释放方面很舒服，但感觉比k30p烫点，不知道是不是开了90hz的缘故）\n2.Realme GT系列\nrealme显然没有做到iqoo的水平，在中高端旗舰产品上比友商差很多，没有特色功能和眼前一亮的点，总之还没找到感觉。\n3.IQOO neo 5\nneo5在大部分参数做到了甚至超过了k40的水平，imx598胜过k40的582，55w快充也比33w快充牛\n但同时也在价格上超越了k40，在买不到K40 的情况下，是公认的平价替代的最佳选择，最高价12+256可以2800左右拿到，仅比k40的12+256黄牛加价版高一点点。没有什么好评价的，k40的第一竞争对手足以说明实例。\n4.小米11 Pro 和 Ultra 及 MIX FOLD\n预热时说产品很多，没想到这么多，更没想到开两天的发布会。重磅消息一个接一个。小米新logo，三个旗舰手机，一个11青春版，一台屏幕素质高的轻薄笔记本，一颗澎湃芯片，最重要的是小米宣布造车。\n手机方面，最具关注的是ultra，作为小米的最高端手机，背面的副屏赚足了眼球，5999的起售价也刷新了记录，6999的顶配12+512，价格不用多说，小米的顶峰。\n67W有线+67W无线，无线刷新了记录，234g的重量也刷新了记录，小米能给你的最好的堆料，都在这里，我就不复述厂商的PPT了。\n而对小米最大的意义，是有一台手机能在7000元的价位和iPhone华为抢销量，但也有不足，就是缺少了华为苹果独有的东西。华为有麒麟芯片，2020年9月14号前生产的9000系列做到了安卓端至今最强，5G技术领先全球，标志着中国大陆芯片设计的最好水平，可见华为人熬掉了多少头发。被美国制裁，是整个中国的不幸。任正非专注研发这一点，值得尊敬。\n小米相比华为的差距，不是一般的大。而现在小米转向造车，赚钱，芯片的事小米暂时不会碰了，和ov一样打算一辈子躺着挣钱，不打算思考一些如何体面的活着的问题。\nPro同样有竞争力，但是被ultra的光芒掩盖了，补足了4000-5000的价位的短板，同样的GN2,同样的IP68，更轻的重量208g，可以说比去年的10pro竞争力大大提高，就看出货了。\nMIX FOLD：最便宜的折叠屏，搭载小米自研的isp，，加上液态镜头。适合手上有闲钱的米粉。首发5w台销量，作为探索者，这个目标达到了。但是和友商mate和galaxy相比有差距，能不能稳定迭代更新，拭目以待吧。\n暂时小米在线上还没有对手，今年的find x3系列和一加9系列不够猛，在纯硬件竞争上比不过Pro,上半年线上市场收割问题不大。但是下半年有复出的荣耀，是有华为级别实力和财力的竞争对手，一旦走上正轨，不容小觑。\n","date":"2021-04-24T20:15:28+08:00","permalink":"https://uest.xyz/posts/%E4%BA%91%E6%B5%8B%E8%AF%84/","section":"posts","tags":null,"title":"云测评"},{"categories":null,"contents":"14. 最长公共前缀 编写一个函数来查找字符串数组中的最长公共前缀。\n如果不存在公共前缀，返回空字符串 \u0026quot;\u0026quot;。\n示例 1：\n1输入：strs = [\u0026#34;flower\u0026#34;,\u0026#34;flow\u0026#34;,\u0026#34;flight\u0026#34;] 2输出：\u0026#34;fl\u0026#34; 示例 2：\n1输入：strs = [\u0026#34;dog\u0026#34;,\u0026#34;racecar\u0026#34;,\u0026#34;car\u0026#34;] 2输出：\u0026#34;\u0026#34; 3解释：输入不存在公共前缀。 提示：\n 0 \u0026lt;= strs.length \u0026lt;= 200 0 \u0026lt;= strs[i].length \u0026lt;= 200 strs[i] 仅由小写英文字母组成  先上我写的垃圾代码：\n1public class Test { 2 public static String longestCommonPrefix(String strs[]) { 3 try {//trycatch是针对输入空字符串的情况，输出空字符串 4 int len = strs[0].length(); 5 for (String s : strs) {//这是一个foreach循环，算出最小的长度，这样在接下来就只要循环最小的长度了 6 if (s.length() \u0026lt; len) { 7 len = s.length(); 8 } 9 } 10 int count = -1;//用作计数 11 for (int i = 0; i \u0026lt; len; i++) { 12 char c0 = strs[0].charAt(i); //这里将第一个字符串作为标准，将后面的字符串与第一个分别比较 13 for (String s : strs) {//这也是一个foreach循环 14 if (c0 != s.charAt(i)) {//一旦遇到不相等，就为count赋值，停止所有循环 15 count = i; 16 break; 17 } 18 if(i+1==len){count=i+1;}//针对情况：“ab”，“a”，循环结束仍然没有为count赋值，那就手动赋值 19 } 20 21 if ( count != -1) {//一旦count被赋值了（即不等于-1），立即break 22 break; 23 } 24 }//完成循环，开始输出结果 25 26 return strs[0].substring(0, count);//如果count==-1或者0，不用担心，exception会帮我们处理掉哦 27 }catch (Exception x){return \u0026#34;\u0026#34;;} 28 } 29 30 public static void main(String[] args) { 31 String strs[] =new String[3]; 32 strs[0]=\u0026#34;floger\u0026#34;; 33 strs[1]= \u0026#34;flog\u0026#34;; 34 strs[2]=\u0026#34;floght\u0026#34;; 35 System.out.println(strs.length); 36 System.out.println(longestCommonPrefix(strs)); 37 38 } 39} 40 暴力求解，逐个循环，相信你一定没心情看我的烂代码。时隔不少天我再编辑时，发现我也看不懂了。\n下面给大家分享一个大神解法\n字典序最大和最小字符串的公共前缀 悠远的苍穹L3发布于 2020-06-1514.1kC++PythonPython3\n解题思路 先找出数组中字典序最小和最大的字符串，最长公共前缀即为这两个字符串的公共前缀 代码 下面是 C++17 的代码\n1class Solution { 2public: 3 string longestCommonPrefix(vector\u0026lt;string\u0026gt;\u0026amp; strs) { 4 if(strs.empty()) return \u0026#34;\u0026#34;; 5 // c++17 结构化绑定 6 // str0, str1 分别是一个 pair\u0026lt;string, string\u0026gt; 的 first 和 second 7 const auto [str0, str1] = minmax_element(strs.begin(), strs.end()); 8 for(int i = 0; i \u0026lt; str0-\u0026gt;size(); ++i) 9 if(str0-\u0026gt;at(i) != str1-\u0026gt;at(i)) return str0-\u0026gt;substr(0, i); 10 return *str0; 11 } 12}; 等同的 C++11 代码如下\n1class Solution { 2public: 3 string longestCommonPrefix(vector\u0026lt;string\u0026gt;\u0026amp; strs) { 4 if(strs.empty()) return \u0026#34;\u0026#34;; 5 const auto p = minmax_element(strs.begin(), strs.end()); 6 for(int i = 0; i \u0026lt; p.first-\u0026gt;size(); ++i) 7 if(p.first-\u0026gt;at(i) != p.second-\u0026gt;at(i)) return p.first-\u0026gt;substr(0, i); 8 return *p.first; 9 } 10}; Python 代码\n1class Solution: 2 def longestCommonPrefix(self, strs: List[str]) -\u0026gt; str: 3 if not strs: return \u0026#34;\u0026#34; 4 str0 = min(strs) 5 str1 = max(strs) 6 for i in range(len(str0)): 7 if str0[i] != str1[i]: 8 return str0[:i] 9 return str0 这里关键在于minmax_elements的使用\n该函数是返回指定范围内的最大最小值的元素的迭代器组成的一个pair, 如果最值多于一个， first返回的是第一个出现的最小值的迭代器，second返回的是最后一个出现的最大值的迭代器 。\n下面是一个例子：\n1void minmaxelement(){ 2 vector\u0026lt;int\u0026gt; vi{3,5,4,1,3,1,9,9,5}; 3 cout\u0026lt;\u0026lt;\u0026#34;vi=\u0026#34;; 4 for(int i:vi) 5 cout\u0026lt;\u0026lt;i\u0026lt;\u0026lt;\u0026#34; \u0026#34;; 6 cout\u0026lt;\u0026lt;endl; 7 auto it=minmax_element(vi.begin(),vi.end()); 8 cout\u0026lt;\u0026lt;\u0026#34; auto it=minmax_element(vi.begin(),vi.end())\u0026#34;\u0026lt;\u0026lt;endl; 9 cout\u0026lt;\u0026lt;\u0026#34;*it.first=\u0026#34;\u0026lt;\u0026lt;*it.first\u0026lt;\u0026lt;\u0026#34; ,*it.second=\u0026#34;\u0026lt;\u0026lt;*it.second\u0026lt;\u0026lt;endl; 10 cout\u0026lt;\u0026lt;\u0026#34;*(it.first-1)=\u0026#34;\u0026lt;\u0026lt;*(it.first-1)\u0026lt;\u0026lt;\u0026#34; ,*(it.second-1)=\u0026#34;\u0026lt;\u0026lt;*(it.second-1)\u0026lt;\u0026lt;endl; 11} 12 13// auto it=minmax_element(vi.begin(),vi.end()) 14//it.first=1 it.second=9 15//*(it.first-1)=4 *(it.second-1)=9 注意 string 比较采用的是 ”字典序“，a,bc,aac按照字典序比较就是：a,aac,bc.\n1template\u0026lt;class ForwardIt, class Compare\u0026gt; 2std::pair\u0026lt;ForwardIt, ForwardIt\u0026gt; 3 minmax_element(ForwardIt first, ForwardIt last, Compare comp) 4{ 5 auto min = first, max = first; 6 if (first == last || ++first == last) 7 return {min, max}; 8 9if (comp(*first, *min)) { 10 min = first; 11} else { 12 max = first; 13} 14 15while (++first != last) { 16 auto i = first; 17 if (++first == last) { 18 if (comp(*i, *min)) min = i; 19 else if (!(comp(*i, *max))) max = i; 20 break; 21 } else { 22 if (comp(*first, *i)) { 23 if (comp(*first, *min)) min = first; 24 if (!(comp(*i, *max))) max = i; 25 } else { 26 if (comp(*i, *min)) min = i; 27 if (!(comp(*first, *max))) max = first; 28 } 29 } 30} 31return {min, max}; 32} 33 https://en.cppreference.com/w/cpp/algorithm/minmax_element\n这是最初c语言第一节课的知识，strcmp的比较方法\ncomparison function object (i.e. an object that satisfies the requirements of Compare) which returns true if if *a is less than *b. The signature of the comparison function should be equivalent to the following:\nbool cmp(const Type1 \u0026amp;a, const Type2 \u0026amp;b);\nWhile the signature does not need to have const \u0026amp;, the function must not modify the objects passed to it and must be able to accept all values of type (possibly const) Type1 and Type2 regardless of value category (thus, Type1 \u0026amp; is not allowed, nor is Type1 unless for Type1 a move is equivalent to a copy (since C++11)). The types Type1 and Type2 must be such that an object of type ForwardIt can be dereferenced and then implicitly converted to both of them.\nhttps://en.cppreference.com/w/cpp/algorithm/minmax_element\n","date":"2021-04-20T16:32:05+08:00","permalink":"https://uest.xyz/posts/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80/","section":"posts","tags":null,"title":"最长公共前缀"},{"categories":null,"contents":"secTest ","date":"2021-04-20T16:00:12+08:00","permalink":"https://uest.xyz/posts/sec/","section":"posts","tags":null,"title":"Sec"}]