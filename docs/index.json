[{"categories":null,"contents":"415. 字符串相加  给定两个字符串形式的非负整数 num1 和num2 ，计算它们的和。\n提示：\n num1 和num2 的长度都小于 5100 num1 和num2 都只包含数字 0-9 num1 和num2 都不包含任何前导零 你不能使用任何內建 BigInteger 库， 也不能直接将输入的字符串转换为整数形式   根据朴素的加法思想，关键在于模拟竖式计算，用一个字符串存储进位，每一列超过十进位。\n注意要对齐，在短的字符串首部补零。字符串的生成使用拼接的方法。\npublic static String addStrings(String num1, String num2) { String numjinwei=\u0026#34;0\u0026#34;; String addsum=\u0026#34;\u0026#34;; int n1=num1.length(); int n2=num2.length(); if(n1\u0026gt;n2) for(int i=0;i\u0026lt;n1-n2;i++) num2=\u0026#34;0\u0026#34;+num2; else for(int i=0;i\u0026lt;n2-n1;i++) num1=\u0026#34;0\u0026#34;+num1; //对齐  int n_max=Integer.max(n1,n2); int jinwei=0; for(int i=0;i\u0026lt;n_max;i++){ int temp_lenthof_numjinwei=numjinwei.length(); int t1=num1.charAt(n_max-1-i)-48; int t2=num2.charAt(n_max-1-i)-48; int t3=numjinwei.charAt(temp_lenthof_numjinwei-1-i)-48; int temp=t1+t2+t3; jinwei=temp/10; int val=temp%10; numjinwei=jinwei+numjinwei; addsum=val+addsum; } if(jinwei==1){ addsum=jinwei+addsum; } return addsum; } ","date":"2021-07-18T19:39:21+08:00","permalink":"https://uest.xyz/posts/415%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E5%8A%A0/","section":"posts","tags":null,"title":"415字符串相加"},{"categories":null,"contents":"48. 旋转图像  48. 旋转图像 难度中等933收藏分享切换为英文接收动态反馈\n给定一个 n × n 的二维矩阵 matrix 表示一个图像。请你将图像顺时针旋转 90 度。\n你必须在**原地** 旋转图像，这意味着你需要直接修改输入的二维矩阵。**请不要** 使用另一个矩阵来旋转图像。\n示例 1：\n输入：matrix = [[1,2,3],[4,5,6],[7,8,9]] 输出：[[7,4,1],[8,5,2],[9,6,3]] 示例 2：\n输入：matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]] 输出：[[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]] 示例 3：\n输入：matrix = [[1]] 输出：[[1]] 示例 4：\n输入：matrix = [[1,2],[3,4]] 输出：[[3,1],[4,2]] 提示：\n matrix.length == n matrix[i].length == n 1 \u0026lt;= n \u0026lt;= 20 -1000 \u0026lt;= matrix[i][j] \u0026lt;= 1000  通过次数192,922\n提交次数263,618\n 一个很久就看到的题目，一直没写，不过上手发现思路不难。\n观察旋转过程中坐标的变化,以3*3矩阵来举例：\n(1,1)-\u0026gt; (1,3)\n(1,2)-\u0026gt;(2,3)\n(1,3)-\u0026gt;(3,3)\n(2,1)-\u0026gt;(1,2)\n(2,2)-\u0026gt;(2,2)\n(2,3)-\u0026gt;(3,2)\n多写几个就可以发现规律了：(i,j)-\u0026gt;(j,n+1-i)，这就意味着，将所有(i,j)位置上的值移到(j,n+1-i)位置上就行了，为了方便，可以另起一个矩阵，填入新值，就完成了。\n注意下标是从0开始的，坐标转化应该是(i,j)-\u0026gt;(j,n-1-i)\npublic static void rotate(int[][] matrix) { int n_temp=matrix.length; int bb[][]=new int[n_temp][n_temp]; // System.out.println(matrix.length);  for( int i=0;i\u0026lt;matrix.length;i++){ for(int j=0;j\u0026lt;n_temp;j++){ bb[i][j]=matrix[i][j]; }} for( int i=0;i\u0026lt;matrix.length;i++){ for(int j=0;j\u0026lt;n_temp;j++){ matrix[j][n_temp-1-i]=bb[i][j]; } } 这就是一个最简单的旋转移动的思路了。可以拿一个图像试验一下，这里使用matlab\n原始图片是这样，\n使用matlab获得rgb值，进行旋转变换：\ntu = imread(\u0026#39;image2022.png\u0026#39;); tu1=tu(:,:,1); s=size(tu1) tu2=zeros(s(2),s(1)); for i=1:s(1) for j=1:s(2) tu2(j,s(1)+1-i)=tu1(i,j); end end image(tu2) 得到的结果：\n注意matlab中数组下标是从1开始的。\n回到题目中来，题目要求请不要 使用另一个矩阵来旋转图像，怎么办？\n观察(i,j)-\u0026gt;(j,n+1-i)，能不能看成两步(i,j)-\u0026gt;(n+1-i,j)，(n+1-i,j)-\u0026gt;(j,n+1-i)\n第一步是左右颠倒，(1,3)移到了(3,3);(3,3)移到了(1,3)，这样就可以交换了。\n第二步是对称交换，根据对角线对称。\n这样不需要使用另外一个矩阵进行保存数据了。\nclass Solution { public void rotate(int[][] matrix) { int n = matrix.length; // 水平翻转  for (int i = 0; i \u0026lt; n / 2; ++i) { for (int j = 0; j \u0026lt; n; ++j) { int temp = matrix[i][j]; matrix[i][j] = matrix[n - i - 1][j]; matrix[n - i - 1][j] = temp; } } // 主对角线翻转  for (int i = 0; i \u0026lt; n; ++i) { for (int j = 0; j \u0026lt; i; ++j) { int temp = matrix[i][j]; matrix[i][j] = matrix[j][i]; matrix[j][i] = temp; } } } } //官方题解 第三种方法：\n一次性移动4格，详见官方题解。（公式的复制出现问题了，不然我就粘贴在这里了）\npublic void rotate(int[][] matrix) { int n = matrix.length; for (int i = 0; i \u0026lt; n / 2; ++i) { for (int j = 0; j \u0026lt; (n + 1) / 2; ++j) { int temp = matrix[i][j]; matrix[i][j] = matrix[n - j - 1][i]; matrix[n - j - 1][i] = matrix[n - i - 1][n - j - 1]; matrix[n - i - 1][n - j - 1] = matrix[j][n - i - 1]; matrix[j][n - i - 1] = temp; } } }  作者：LeetCode-Solution 链接：https://leetcode-cn.com/problems/rotate-image/solution/xuan-zhuan-tu-xiang-by-leetcode-solution-vu3m/ 来源：力扣（LeetCode） 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n ","date":"2021-07-17T19:56:17+08:00","permalink":"https://uest.xyz/posts/48%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F/","section":"posts","tags":null,"title":"48旋转图像"},{"categories":null,"contents":"UNIX 读书笔记 第2章：UNIX 发展历史以及系统架构 发展历史：\n1965年 MULTICS ( Multiplexed Information and Computing Service) 的开发 1970年 Ken Thompson 和 Dennis Ritchie 在PDP7上用汇编语言开发出UNICS 1971年 在PDP-11上用汇编开发出UNIX v.1 1972年 增加管道功能后开发出UNIX v.2 1973年 Dennis Ritchie 在B language基础上发明了C language 并用C重写UNIX, 形成v.5 \u0026mdash;- 当时第一个高级语言OS\n1975年 发表UNIX v.6 并广泛扩散到大学和科研单位, 为后期发展奠定了良好的基础 1978年 优化后发布UNIX v.7 \u0026mdash;- UNIX的第一个商业版本 \u0026mdash;- 我国开始研究应用的最早版本 1981年 AT\u0026amp;T发布UNIX System III, 完全转向为社会提供的商品软件 1983年 AT\u0026amp;T发布UNIX System V, 系统功能已趋于稳定和完善. 此后System V又有一系列的公布号:1.0/2.0/2.3/3.5/4.0/4.2 等, 现在最后版本为 System V Release 4 (SVR4)\n有代表性的版本：\nAIX IBM公司 XENIX/OpenServer Microsoft、SCO公司 HP-UX HP公司 BSD 加州大学伯克利分校 Solaris SUN公司 IRIX SGI公司 Ultrix DEC公司 Linux 开放源代码\n系统结构： 内核：负责管理所有与硬件相关的功能，这些功能由UNIX内核中的各个模块实现。内核包括直接控制硬件的各个模块，这样能够极大程度上保护这些硬件，以避免应用程序直接操作而导致混乱。用户不能直接访问内核。\n 注意：系统工具和UNIX命令不是内核组件。\n用户应用程序得到保护，避免被其他用户的无意写操作破坏。\n 常驻模块层：提供执行用户请求服务的例程，包括IO控制服务，文件/磁盘访问服务，以及进程创建和终止服务。\n工具层：是UNIX的用户接口，通常成为shell在后面会详细讲到shell\n虚拟计算机：UNIX操作系统向系统中的每个用户指定一个执行环境，这个环境成为虚拟计算机，包括一个用户终端和共享的其他的计算机资源。而UNIX上可以存在多个用户，所以每一个用户都有自己的专用虚拟计算机。不同的用户的虚拟计算机共享CPU和其他计算机资源，所以虚拟计算机比真实的计算机要慢。\n进程：一个重要的概念。一般面试时都会问进程和线程 的区别。UNIX系统通过进程向用户和程序分配资源（这句话不怎么懂）。每个进程都有一个进程号pid和一组与之相关的资源。进程在虚拟计算机环境下运行，就好像在一个专用CPU上执行一样。\n第3章 UNIX入门 3.1登录与退出 1.登录\n输入用户名，密码\n2.修改密码：passwd和一般的修改要验证旧密码并两次重新输入新密码，具体操作不再赘述\n3.退出系统：[ctrl+d] 或是exit，即可退出\n3.2 简单的UNIX命令 命令行格式：[命令] [选项] [参数]\n字段间要用一个或多个空格隔开。选项的前面一般会有连字符-，一个命令同时也可以有多个，例如下列著名的命令：\nrm表示删除，-rf表示两个选项：r和f，/*表示的磁盘路径就是参数，告诉系统在哪里要删除什么文件\n下面介绍一些简单的命令：\n1.date：显示日期和时间\n2.who：列出登录系统的所有用户的用户名，终端号，和登录时间。这里wsl没有这个命令，原因如下\n who程序跟Linux内核无关，只是读取Unix里约定俗成的utmp,wtmp登录文件。你第一次打开wsl2的终端，或者通过其他方式运行wsl2的这个系统，就是第一次登录。但是wsl2子系统不会用utmp/wtmp记录这些，没有任何意义\n但在wsl里/init does not create /var/run/utmp\n解决方案： Use \u0026lsquo;touch /var/run/utmp\u0026rsquo; in some \u0026ldquo;system startup script\u0026rdquo;\n来源：https://github.com/Microsoft/WSL/issues/573\n who还有一些的选项：-q -H -b。\n3.显示日历：cal\n3.3 获取帮助信息 learn和help，使用时需要安装\n比如我不知道exit的用法\n3.3.3 man手册： 学习新命令时使用，可以得到该man(manual)命令的详细说明，当然\n在简洁的wsl中也是没有man的，需要先sudo apt install man-db manpages manpages-dev,之后才能愉快地使用man\n3.4 更正键盘输入错误 中断程序的执行，在大多数系统中，del或者ctrl-c就是中断键，比如不小心按了rm -rf /，这是就要猛敲[ctrl-c]\n3.5 使用shell 命令的处理是位于用户和操作系统的其他部分之间的shell完成的，每输入一个命令以后，命令被传到shell，先进行分析，然后执行。\nbulitin命令：包含的是一些比较简单的linux系统命令，这些命令由shell程序识别并在shell程序内部完成运行，通常在linux系统加载运行时shell就被加载并驻留在系统内存中。内部命令是写在bashy源码里面的，其执行速度比外部命令快，因为解析内部命令shell不需要创建子进程。比如：exit，history，cd，echo等。\n外部命令是linux系统中的实用程序部分，因为实用程序的功能通常都比较强大，所以其包含的程序量也会很大，在系统加载时并不随系统一起被加载到内存中，而是在需要时才将其调用内存。通常外部命令的实体并不包含在shell中，但是其命令执行过程是由shell程序控制的。shell程序管理外部命令执行的路径查找、加载存放，并控制命令的执行。外部命令是在bash之外额外安装的，通常放在/bin，/usr/bin，/sbin，/usr/sbin\u0026hellip;\u0026hellip;等等。可通过“echo $PATH”命令查看外部命令的存储路径，比如：ls、vi等。\n用type命令可以分辨内部命令与外部命令\n关于内部命令和外部命令执行顺序的问题：\n pwd命令用于显示当前工作目录，是Linux系统下最常用的命令之一。在不太能确定当前位置时，可以使用pwd命令来判断目录在文件系统内的确切位置。而涉及pwd指令，就不得不提及三个环境变量：PATH、OLDPWD、PWD。\nPATH：执行文件路径的变量；\u0026ldquo;echo $PATH\u0026rdquo;（PATH前面加$表示后面接的是变量）\nOLDPWD：表示前一次的工作目录；\nPWD：表示当前的工作目录。\n问题缘由：当输入“man pwd”时可以查看pwd的帮助文档，而输入“pwd \u0026ndash;help”就提示有错误bash: pwd: \u0026ndash;: invalid option；若输入“ /bin/pwd \u0026ndash;help”就能正常显示pwd的帮助文档。\n从网上查找原因并经过整合可知，这主要是由于内部命令和外部命令的区别，pwd是内部命令，而/bin/pwd就是外部命令。在显示当前目录时，/bin/pwd能显示当前工作目录的完整文件路径，能更准确些。在多人共享同一台Linux机器时，经常会发现当前目录被别人删除后，pwd命令仍然会显示那个目录。\n后续试验：切换至root权限下，将/bin目录下的执行文件ls移动到非正规目录中去，mv /bin/ls /root（#mv为移动，可将文件在不同的目录间进行移动操作），然后不管在哪个目录底下输入任何与ls相关的指令，都不能顺利执行ls了（因为/root这个目录并不在PATH指定的目录中，外部命令ls是没法通过PATH路径找到执行文件ls），除非用/root/ls 才行。\n如果想要让root在任何目录下均可执行/root底下的ls，那么可以将/root加入到PATH当中，该命令PATH=\u0026quot;$PATH\u0026quot;:/root即可。若有两个ls指令在不同的目录中，例如/usr/local/bin/ls 和/bin/ls ，那么当我下达 ls命令时，是根据PATH里面哪个目录先被查询到，则那个目录下的指令就先被执行。\n而即使采用相同的方法移动/bin目录下的执行文件pwd，仍可以输入pwd命令执行，因为这时仍是调用内部命令pwd指令。\n故shell命令解释器在执行命令时，是应先执行内部指令，若要执行的指令不是内部指令，则应是调用的外部指令。 ———————————————— 版权声明：本文为CSDN博主「JustDo-IT」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。 原文链接：https://blog.csdn.net/taohuaxinmu123/article/details/10845001\n 3.5.2 更改用户shell 可以在 /etc/passwd里查看用户登录的shell\n例如第一行：root:x:0:0:root:/root:/bin/bash 用户名：密码：UID：GID：描述性信息：用户主目录：Shell　具体shell的内容将在第9章中详细说明\n第4章 vi 编辑器入门 vi 文件名启动vi 编辑器，进入的是shell的命令模式,如果你要输入文本，可以按i进入文本输入模式，退出vi：先esc，再输入:wq，即可保存或退出。\n以上就是最最基础的用法。下面介绍高级用法：\n4.1模式： 从命令模式进入文本输入模式：\n   文本输入模式        i  在光标左侧加入文本    I  在光标所在行首插入文本    a  在光标右侧加入文本    A  在光标所在行尾加入文本    o  在光标所在行下面新加一行    O  在光标所在行上面新加一行    ESC  退出文本输入模式     4.2 命令模式： 光标移动：\n   光标移动        h j k l  左下上右移动    ^  行首    $  行尾    +  下一行的行首    _  上一行的行首    Space  右移    Backspace  左移    w  下一个字    b  前一个字    e  当前字的末尾     文本修改：\n   文本修改       x  删除光标所在字符   dw  删除光标所在词的从光标开始到该词结尾   D  删除从光标到行尾   dd  删除光标所在行   u  撤销上一次修改   r  把当前光标所在字符替换为紧跟在r后的一个字    x,dw,dd前都可加上数字，表示同时删除多个单位\n.可以重复最近一次对文本的修改操作\n搜索文本\n   搜索      / 输入搜索词并回车，向尾部查找下一个词   ? 与/相同，查找方向相反    4.3 退出 在命令模式时，\n   退出      :wq 保存文本，退出vi，返回shell   :w 保存文本，不退出   :w file 把文本保存到文件file中，不退出   :q 退出vi，返回shell   ZZ 快速保存文件并退出    4.4 存储缓冲区 vi编辑器为用户所要创建或修改的文件建立了一个临时工作区，用户编辑的过程中只作用于工作区的文件副本而不是源文件。如果用户需要保存，必须用命令将修改的文件替换原文件。\n4.5 高级操作 希望能在vim中完成大多数工作，而不是频繁的退出vim 首先:tabnew创建一个标签 然后:e 文件名打开一个文件 :tabnext在窗口上打开下一个tab :tabprevious在窗口上打开前一个tab :q或者:tabclose关闭tab 更多的高级用法将在第6章讲到\n第5章 UNIX 文件系统介绍 5.1 磁盘组织 UNIX允许用户将硬盘分为很多单元（称为目录）和子单元（子目录），这样可以在目录里嵌套子目录。UNIX提供命令，可以在磁盘上创建、组织、和查找目录和文件。\n文件系统原理\nUnix有三大抽象\n 进程、线程对执行过程 文件对io 地址空间对内存  Unix有四种io：文件系统、块设备、字符设备、socket\n 块设备和字符设备出现在文件系统的名字空间 Socket仅表现为文件  考虑到磁盘的空间组织，主要有边长的堆、定长的记录、索引\nUnix文件系统选择：堆 + 索引\n5.2 UNIX中的文件类型 普通文件：包含字节序列，如程序代码、数据、文本。\n目录文件：目录文件和其他文件一样，用户可以像命名其他文件一样来命名目录文件。区别在于不是标准的ascii文本文件，包含的是关于其他文件的信息。\n特殊文件：包含与外部设备，如打印机、磁盘等相联系的的特定信息。unix的一大抽象就是将io设备视同文件对待，系统中的每个设备都分别对应一个文件。\n5.3 目录详述 目录结构以层次形式组织，称为层次结构（其实可以理解为树）。最高层目录为根目录。\n5.3.1 重要的目录： /usr 用户主目录，当用户在系统中登录时，会自动进入用户主目录，它在/usr/[username]下。\n/bin 可执行文件\n/dev设备文件，代表物理设备的抽象，如终端是/dev/tty文件。/dev/null是一个特殊设备，即空设备，所有发给空设备的信息都被删除。\n/sbin 存放系统文件，在3.5章讲到：\n 外部命令是在bash之外额外安装的，通常放在/bin，/usr/bin，/sbin，/usr/sbin\u0026hellip;\u0026hellip;等等\n /etc 存放unix配置文件，通常是文本，只要特权用户才有权限编辑。\n5.3.2 路径 绝对路径名：从根目录到该文件的路径，以/开始\n相对路径名：从当前路径到目的文件，开头没有/\n5.4 目录命令 1.打印工作目录 pwd(print working directory)\n2.改变工作目录 cd \n   cd命令      cd 返回用户主目录，缺省值   cd $HOME 返回用户主目录   cd .. 返回上一级目录    3.创建目录 mkdir\n选项有-p\nmkdir -p xx/yy/zz 创建xx目录，在xx下创建yy目录，在yy下创建zz目录\n4.删除目录 rmdir\n注意只能删除空目录，即除了本目录（.）和父目录（..）外，该目录不包含其他任何子目录和文件。\n5.目录列表 ls\n显示指定目录的信息，如果没有指定目录，则列出当前目录。\n   UNIX选项 linux选项 功能     -a \u0026ndash;all 列出所有文件，包括隐藏文件   -C \u0026ndash;format=vertical \u0026ndash;format=horizontal 用多列方式列出文件，按列排列   -F \u0026ndash;classify 将子目录与普通文件类型分开，子目录加/，可执行文件加*   -l \u0026ndash;format=single-column 详细列出文件的属性，每行一个文件   -m \u0026ndash;format=commas 按页宽列出文件，用逗号隔开   -p  在目录文件名后加斜杠 /   -r \u0026ndash;reverse 以反字母顺序列出文件   -R \u0026ndash;recursive 递归列出子目录的内容   -s \u0026ndash;size 以block为单位列出文件大小   -x \u0026ndash;format=horizontal \u0026ndash;format=across 以多列方式列出文件，按行排列    \u0026ndash;help 显示帮助信息    例如：\ndrwxr-xr-x 为属性字段\n文件属性字段总共有10个字母组成；第一个字符代表文件的类型。\n字母**“-”**表示该文件是一个普通文件\n字母**“d”**表示该文件是一个目录，字母\u0026quot;d\u0026quot;，是dirtectory(目录)的缩写\n**注意：**目录或者是特殊文件，这个特殊文件存放其他文件或目录的相关信息\n字母**“l”**表示该文件是一个链接文件。字母\u0026quot;l\u0026quot;是link(链接)的缩写，类似于windows下的快捷方式\n字母**“b”**的表示块设备文件(block)，一般置于/dev目录下，设备文件是普通文件和程序访问硬件设备的入口，是很特殊的文件。没有文件大小，只有一个主设备号和一个辅设备号。一次传输数据为一整块的被称为块设备，如硬盘、光盘等。最小数据传输单位为一个数据块(通常一个数据块的大小为512字节)\n字母**“c”**表示该文件是一个字符设备文件(character)，一般置于/dev目录下，一次传输一个字节的设备被称为字符设备，如键盘、字符终端等，传输数据的最小单位为一个字节。\n字母**“p”**表示该文件为命令管道文件。与shell编程有关的文件。\n字母**“s”**表示该文件为sock文件。与shell编程有关的文件。\n后面的是文件访问模式：rwx分别为read，write，执行的权限。分为3组，第一组rwx是文件所有者，第二组r-x是同组用户权限，第三组r-x是其他用户权限。\n第2列是链接数，第3列是文件所有者，第4列是文件组，第5列是文件大小，第6列是上次修改的日期和时间，第7列是文件名。\n6.隐藏文件\n文件名以点开始的文件，不可见。\nchmod命令 chmod命令可以使用八进制数来指定权限。文件或目录的权限位是由9个权限位来控制，每三位为一组，它们分别是文件所有者（User）的读、写、执行，用户组（Group）的读、写、执行以及其它用户（Other）的读、写、执行。历史上，文件权限被放在一个比特掩码中，掩码中指定的比特位设为1，用来说明一个类具有相应的优先级。\n   # 权限 rwx 二进制     7 读 + 写 + 执行 rwx 111   6 读 + 写 rw- 110   5 读 + 执行 r-x 101   4 只读 r\u0026ndash; 100   3 写 + 执行 -wx 011   2 只写 -w- 010   1 只执行 \u0026ndash;x 001   0 无 \u0026mdash; 000    .和. .目录项\n本目录（.）和父目录（..）mkdir命令自动将两项放到创建的每个目录中。分别代表当前目录和上一级目录。\n5.5 显示文件 cat concatenate命令 可以显示一个、多个、创建文件、连接文件。\n5.6 打印文件内容 lp 将文件发送给打印机\nLinux中的打印请求 lpr命令\n取消打印命令cancel\n获取打印机状态lpstat\n5.7 删除文件 rm可以删除指定的文件\n   选项 功能     -i 删除文件前，给出确认信息   -r 删除指定的目录及目录下的所有文件和子目录   -rf 无提示地强制递归删除文件    如果想无提示删除所有文件，可以作死尝试sudo rm -rf /*\n第6章 vi编辑器的高级用法 6.1 更多vi知识 6.1.1 启动vi编辑器 以不依靠文件的方式启动vi，可以最后用:w filename保存（如果有同名文件会提示）\n启动选项：\n-R 只读，如果希望保存的话，必须用!强制执行写选项\nview filename同样可以以只读模式打开\n6.1.2 编辑多个文件 :n 启动下一个编辑文件，此时用下一个文件替换工作缓冲区的内容（源文件要保存）。我觉得唯一作用就是可以省略退出的操作。\n:e编辑另一个文件，感觉这种方法和:n一样啊\n:r读另一个文件，将指定文件的副本放到缓冲区中光标位置之后，指定文件成为当前文件的一部分。保存到源文件。\n:w将正在编辑的文件写入另一个文件中，就相当于6.1.1中最后的保存操作\n6.2 重排文本 vi提供了删除，复制，剪贴操作。就是命令有点复杂。\n书中讲了几个例子：\n1.剪贴行（使用删除和put操作符）\n在某一行按dd，会发现这一行消失了，但并没有完全消失，只是保存到临时缓冲区中，在合适的地方按p，这时刚才被删除的行就被放在当前行下。\n2.复制行（使用复制和put操作符）\n在某一行按yy，这一行保存到临时缓冲区中，在合适的地方按p，粘贴。\n当然先要精细化粘贴怎么办呢？\n6.3 操作符的域 命令=操作符+域\n确定操作域后，可以使用户更好地控制编辑任务。\n   键 功能说明     $ 标识域为从光标位置后到当前行尾   0 标识域为从光标位置前到当前行首   e/w 标识域为从光标位置后到当前字尾   b 标识域为从光标位置前到当前字首    比如要复制从光标到行尾的所有，可以按d$，这就实现了复制，再按p粘贴。\n删除2行，d2d\n6.4 使用缓冲区 6.4.1 数字编号缓冲区 编号1-9，每次删除或复制的文本就会放在这些地方。使用\u0026quot;1p就可以把1号缓冲区粘贴到下一行。\n6.4.2 字母编号缓冲区 编号a-z，用户可以保存指定文本到某字母编号缓冲区。\n比如\u0026quot;wdd将当前行删除，删除的副本保存在w号缓冲区\n\u0026quot;z7yy，复制7行内容到z缓冲区\n6.5 光标定位键    键 功能说明     Ctrl-d 将光标向下移动到文件尾，通常每次移动12行   Ctrl-u 将光标向下移动到文件头，通常每次移动12行   Ctrl-f 将光标向下移动到文件尾，通常每次移动24行   Ctrl-b 将光标向下移动到文件头，通常每次移动24行    6.6 定制vi 用户可以调整vi编辑器的设置\n可以看到有众多选项可以自定义。\n下面介绍一些常用选项：\n   选项 缩写 功能     autoindent ai 将新行与前一行的行首对齐   ignorecase ic 在搜索选项中忽略大小写   magic  允许在搜索时使用特殊字符   number nu 显示行号   report  通知用户上一个命令影响的行号   scroll  设定Ctrl-d命令翻动的行数   shiftwidth sw 设置缩进的空格数，与autoindent选项一起使用   showmode smd 在屏幕的右角显示vi编辑器的模式   terse  缩短错误信息   wrapmargin wm 设置距屏幕右边界为指定的字符数    6.6.4 缩写ab 在命令模式输入:ab hos harmony OS，进入文本模式，在任何地方输入hos，注意前后要有空格，vi就会把hos替换为harmony OS。\n:ab [return]可以查看所有的缩写\n宏操作符map：可以指定单个键代表键序列。例如：想要用q代替删除5行5dd，可以在命令模式输入:map q 5dd\n以上取消可以按:unab hos和:unmap q\n6.6.5 .exrc文件 用户的设置都是临时的，如果想要永久保存对vi的设置，可以在.exrc文件保存设置\n6.7 其他命令 当你想在vi编辑时运行shell命令，为了在vi中编辑文件不被打断，可以:! 执行shell命令\n第7章 正则表达式 Regular Expressions RE分为BRE和ERE\nBasic RE：\n   字 符 BRE/ERE 含义     \\ Both 转义   . Both 匹配单个字符   * Both 匹配任意次，可以是0次。a*表示匹配任意多次a，.*表示任意字符串   ^ Both 锚定匹配位置，从一行的行首开始   $ Both 锚定匹配位置，到一行的行尾   […] Both 匹配中括号内的某个字符。x-y表示一个范围；[^…]表示不匹配中括号中的任意字符。[开括号后跟-或]，-]转义为普通字符   \\{n,m\\} BRE 匹配次数为[n,m]，{n}匹配n次，{n,}最小匹配次数为n   \\ (\\ ) BRE 定义一个匹配位置，在后部可以引用该位置。例如，\\(ab\\).*\\1表示ab字符串包夹了一个任意字符串。   \\n BRE 引用已经定义的位置，可以从\\1到\\9    下面是一些例子：\na*g$ 匹配到行尾\n^a*g 匹配到行首（*表示0-任意次）\na[a-z]g可以匹配aag，abg，\u0026hellip;,azg都可以\na[^0-9]g不匹配a9g\n []中也可以加[[:alnum:]]表示字符+数字\n[[:alpha:]]表示字符\n[[:digit:]]表示数字\n[[:lower:]]表示小写字符\n[[:upper:]]大写字符\n[[:space:]]空字符：空格、tab\n a{3}匹配aaa,aaaaaa\na{3,}匹配aaa，aaaa，aaaaaa\n例子 在leetcode上有shell分类，随便点开一题，发现是正则表达式的题目\n 给定一个包含电话号码列表（一行一个电话号码）的文本文件 file.txt，写一个单行 bash 脚本输出所有有效的电话号码。\n你可以假设一个有效的电话号码必须满足以下两种格式： (xxx) xxx-xxxx 或 xxx-xxx-xxxx。（x 表示一个数字）\n你也可以假设每行前后没有多余的空格字符。\n示例：\n假设 file.txt 内容如下：\n987-123-4567 123 456 7890 (123) 456-7890 你的脚本应当输出下列有效的电话号码：\n987-123-4567 (123) 456-7890\n来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/valid-phone-numbers\n 首先当然是匹配行首到行尾，^和$不能少\n三位数字怎么弄：[0-9]{3}\n^[0-9]{3}-[0-9]{3}-[0-9]{4}$|^(\\([0-9]{3}\\) [0-9]{3}-[0-9]{4})$ 当然也可以不同，下面截取一个leetcode网友的题解\ncat file.txt | grep -P \u0026#34;^(\\([0-9]{3}\\)\\s|[0-9]{3}-)[0-9]{3}-[0-9]{4}$\u0026#34; 简单修改一下在支持re的idea中搜索(\\([0-9]{3}\\)\\s|[0-9]{3}-)[0-9]{3}-[0-9]{4}$成功匹配到了正确的电话号码\n第8章 UNIX文件系统的高级操作 8.1 重定向   C语言程序一般会打开三个缺省文件，stdin、stdout、stderr，文件描述符分别是0,1,2。\n  在Unix系统中，文件是io的基本抽象。标准输入、标准输出、错误输出可以替换为其它文件。\n  输出重定向\ncommand \u0026gt; file\ncommand \u0026gt;\u0026gt; file 追加\n标准输入重定向\ncommand \u0026lt; file\ncommand \u0026lt;\u0026lt; EOF 标准输入，当碰到EOF字符串时，输入结束\n标准错误输出重定向\ncommand 2\u0026gt; file 将command的错误输出重定向到file文件\ncommand 2\u0026gt;\u0026gt; file 追加重定向\nls \u0026gt; mydir.list cat mydir.list //显示mydir.list 此时再 ls .. \u0026gt;\u0026gt; mydir.list //将新的内容追加到mydir.list rmdir ggg \u0026amp;\u0026gt;\u0026gt; mydir.list//将报错消息追加到mydir.list cat mydir.list ! anaconda3 CLionProjects Downloads examples.desktop mydir.list myfirst snap rmdir: 删除 'ggg' 失败: 没有那个文件或目录 为了提高效率，可以直接使用cat和\u0026gt;创建文件：cat file1\ncat file1 file2\u0026gt; file3可以将file1和file2文件内容复制到file3中。\ncat file3 \u0026gt;\u0026gt; file4 将file3追加到file4的末尾。\n8.2 管道 shell将一个程序的标准输出作为另一个程序的标准输入，形成管道（pipeline）\ncommand A | command B\n注意两条命令之间是以一个匿名文件传输\n单向通过，没有格式，以流的形式进行通信\n例如，我想在查找ls -l的结果中以正则表达式搜索s.*h，可以执行\nls -l|grep -e\u0026quot;s.*h\u0026quot;\n8.2.1 Shell如何实现管道？ 1.pipe()函数创建一个管道，两个文件描述符，一个输入，一个输出\n2.fork()创建子进程\n3.父进程关闭管道的输出端。\n4.子进程dup2，将标准输入替换为管道输入。\n5.子进程进一步关闭管道输入和输出。\n6.父进程写完数据后，关闭管道输出。\n7.子进程从父进程收到EOF，输入数据完毕。\n8.3 文件操作 cp拷贝源文件成目标文件\n   短选项 长选项 功能     -b \u0026ndash;backup 如果目标文件存在，创建备份   -i \u0026ndash;interactive 如果目标文件存在，要求确认   -r \u0026ndash;recursive 将目录复制到新的目录    \u0026ndash;verbose 解释操作    \u0026ndash;help 显示帮助页并退出    mv移动文件\n   短选项 长选项 功能     -b \u0026ndash;backup 如果目标文件存在，创建备份   -i \u0026ndash;interactive 如果目标文件存在，要求确认   -f \u0026ndash;force 强制移动，不要求确认   -v \u0026ndash;verbose 解释操作    \u0026ndash;help 显示帮助页并退出    \u0026ndash;version 显示版本信息并退出    8.4 ln链接文件 用于为已存在的文件创建另外的名字（链接）。\n假设有一个a.txt文件，想给他另一个名字b.txt\n输入$ sudo ln a.txt b.txt\n再查看一下目录$ ls -li\n10878 -rw-r--r-- 2 endwsl endwsl 0 Apr 12 20:08 a.txt 10878 -rw-r--r-- 2 endwsl endwsl 0 Apr 12 20:08 b.txt endwsl@LAPTOP-U1E6STIA:/home$ cat \u0026gt;\u0026gt;a.txt atxt //修改一下a.txt的内容 endwsl@LAPTOP-U1E6STIA:/home$ cat b.txt //再去看b.txt的内容 atxt //发现竟然也是atxt 甚至ln命令不会创建新的i-node，而是引用已有i-node，增加引用计数。\nln –s符号链接，分配一个新的inode，内部记录指向原有文件。\n8.5 其他wc,head,tail wc统计字数\n   短选项 长选项 功能     -l \u0026ndash;lines 统计行数   -w \u0026ndash;words 统计单词数量   -c \u0026ndash;chars 统计字符数量    \u0026ndash;help 帮助    (base) minatoxeon@OMEN:~$ wc -l mydir.list 19 mydir.list (base) minatoxeon@OMEN:~$ wc -w mydir.list 23 mydir.list (base) minatoxeon@OMEN:~$ wc -c mydir.list 215 mydir.list (base) minatoxeon@OMEN:~$ head显示文件头部，缺省显示头部10行。\n   短选项 长选项 功能     -n \u0026ndash;lines=n 显示头部n行   -c \u0026ndash;chars=n 显示头部n个字符    \u0026ndash;help 显示帮助页并退出    \u0026ndash;version 显示版本信息并退出    tail显示文件尾部，缺省是尾部10行，与head类似就不再列举出。\npaste命令横向连接两个文件。缺省分隔符为TAB制表符。\n   短选项 长选项 功能     -d x \u0026ndash;delimiters=x 指定域分隔符    \u0026ndash;help 显示帮助页并退出    \u0026ndash;version 显示版本信息并退出    8.6 sed替换    选项 含义     -e 脚本命令 该选项会将其后跟的脚本命令添加到已有的命令中。   -f 脚本命令文件 该选项会将其后文件中的脚本命令添加到已有的命令中。   -n 默认情况下，sed 会在所有的脚本指定执行完毕后，会自动输出处理后的内容，而该选项会屏蔽启动输出，需使用 print 命令来完成输出。   -i 此选项会直接修改源文件，要慎用。    一个使用的例子：\n我在使用群晖时发现：一旦ssd温度升高到61度就会引起自动关机,由于我的群晖没有风扇，对于ssd达到这个温度轻而易举，一个24小时工作的设备肯定不希望它经常关机，根据教程查看群晖的配置文件发现\nadmin@DiskStation:/usr/syno/etc.defaults$ cat scemd.xml | grep -E \u0026quot;61\u0026quot; \u0026lt;disk_temperature fan_speed=\u0026quot;FULL\u0026quot; action=\u0026quot;SHUTDOWN\u0026quot;\u0026gt;61\u0026lt;/disk_temperature\u0026gt; \u0026lt;disk_temperature fan_speed=\u0026quot;FULL\u0026quot; action=\u0026quot;SHUTDOWN\u0026quot;\u0026gt;61\u0026lt;/disk_temperature\u0026gt; \u0026lt;disk_temperature fan_speed=\u0026quot;FULL\u0026quot; action=\u0026quot;SHUTDOWN\u0026quot;\u0026gt;61\u0026lt;/disk_temperature\u0026gt; \u0026lt;disk_temperature fan_speed=\u0026quot;FULL\u0026quot; 群晖的温度墙为61度，此时使用sed替换所有的61为70\nsudo sed -i\u0026quot;s/61/70/g\u0026quot; scemd.xml\nadmin@DiskStation:/usr/syno/etc.defaults$ cat scemd.xml | grep -E \u0026quot;70\u0026quot; action=\u0026quot;SHUTDOWN\u0026quot;\u0026gt;70\u0026lt;/disk_temperature\u0026gt; \u0026lt;disk_temperature fan_speed=\u0026quot;FULL\u0026quot; action=\u0026quot;SHUTDOWN\u0026quot;\u0026gt;70\u0026lt;/disk_temperature\u0026gt; \u0026lt;disk_temperature fan_speed=\u0026quot;FULL\u0026quot; action=\u0026quot;SHUTDOWN\u0026quot;\u0026gt;70\u0026lt;/disk_temperature\u0026gt; \u0026lt;disk_temperature fan_speed=\u0026quot;FULL\u0026quot; action=\u0026quot;SHUTDOWN\u0026quot;\u0026gt;70\u0026lt;/disk_temperature\u0026gt; 这样就让温度墙设定为70度\n（由于群晖基于的是freebsd，因此在群晖的控制面板打开ssh即可使用ssh client登陆，注意：SSH 仅支持属于 local administrators 群组的帐户登录系统。默认端口为22）\n（尴尬的是改完温度墙以后，使用一段时间温度就会达到70°，只好去加了个风扇）\n不过使用s///g对替换里面字符里面要是有路径的话就会很难受,所以可以用s:::g来表示同样的意思。\n8.7 打开文件：grep命令 grep命令打开文件，在文件中以RE方式搜索字符串\n   短选项 长选项 功能     -c \u0026ndash;count 只显示匹配的行数   -i \u0026ndash;ignore-case 忽略大小写匹配   -G \u0026ndash;basic-regexp BRE，grep缺省   -E \u0026ndash;extended-regexp ERE，egrep缺省   -e PATTERNS \u0026ndash;regexp=PATTERNS 指定一个或多个RE   -v \u0026ndash;invert-match 显示不匹配的行   -n \u0026ndash;line-number 输出行号   -o \u0026ndash;only-matching 只输出匹配的部分    8.8 find查找文件    选项 功能     -name filename 根据给定的filename查找文件。   -size ± n 查找文件大小为n的文件   -type file type 查找指定类型的文件   -atime ± n 查找n天以前访问的文件   -mtime ± n 查找n天以前修改的文件   -newer filename 查找比filename更近期更新的文件   -print 显示找到的每个文件的路径名   -exec command\\； 对找到的文件执行command   -ok command\\； 在执行command之前要求确认      -name选项实例：\n  -find.-name first.c-print[Return] 查找文件名为first.c的文件。\n  $find.-name \u0026ldquo;*.？\u0026quot;-print[Return] 查找文件名为点和单个字符结尾的文件。\n    -size ± n选项：+表示大于，-表示小于。\n  -type选项：\n -b : 块特殊文件（如磁盘） -c ：字符特殊文件（如终端） -d ： 目录文件 -f ： 普通文件    -emax\n  统计/usr/include/sys目录下的所有目录及子目录个数\nfind /usr/include/sys -type d|wc -l 查找epoll_wait函数在那个文件： find /usr/include –name “*.h” -type f | xargs grep ‘epoll_wait’\n搜索/usr/include目录中，引用EPOLLIN常数的头文件\nfind -name \u0026quot;*.h\u0026quot; -type f|xargs grep \u0026quot;EPOLLIN\u0026quot;./linux/eventpoll.h:#define EPOLLIN\t0x00000001./x86_64-linux-gnu/sys/epoll.h: EPOLLIN = 0x001,./x86_64-linux-gnu/sys/epoll.h:#define EPOLLIN EPOLLIN 在usr/include中查找文件名以.h结尾的所有普通文件。\nfind /usr/include -name \u0026#34;*.h\u0026#34; 8.9 文件系统 unix文件系统将每一个文件名与一个数字(inode)连接起来，并用文件的inode来标识每一个文件。\n磁盘结构：\n在unix先，磁盘是标准的块设备，unix的磁盘分为4个块\n  引导块\n  超级块 包含有关磁盘自身的信息\n 磁盘的总块数 空闲块数 块的大小 已使用的块数    inode列表块\n保存inode列表，列表中的每一个表项是一个inode，有64字节存储空间。普通文件或者目录文件的inode包含文件在磁盘块的位置。特殊文件的inode包含标识外部设备的信息。除了以上，还有：\n 文件访问权限（读写执行） 文件属主和组id 文件链接数 文件最后修改时间 文件最后访问时间 每个普通文件和目录文件的块位置 特殊文件的设备标识号    文件和目录块\n第二个inode包含根目录所在块的位置。创建目录时，系统自动创建两个表项：.（表示子目录）和..（表示父目录）\n  第9章 探索Shell unix由内核和系统工具组成。内核是核心，所有直接与硬件通信的常规程序都集中在内核中。\nshell是用户和系统交流的工具，自身是一个应用程序。当用户登录到系统时shell被装入内存。\n用户登录时，init（进程号1）拉起login，输入密码成功后，由login进程拉起shell进程\n对于大多数用户键入的命令，shell并不执行，它fork子进程来执行命令，shell等待wait子进程结束（等待SIGCHLD信号）。\nshell的主要功能：\n 命令执行 文件名替换 I/O重定向 管道：把简单程序连接到一起来完成一个较为复杂的任务。“|”就是管道操作符 环境控制：用户通过设定，可以变更主目录、命令提示符或工作环境 后台计算：shell的后台计算能力使用户能够在前台进行工作的同时在后台运行程序。 shell脚本  9.1 显示消息：echo命令 echo命令输出字符串，echo hello there就会输出hello there\n一般默认输出禁止换行\n9.2 shell 变量 bash shell 用一个叫做环境变量(environment variable)的特性来存储有关shell会话和工作环境的信息。这项特性允许用户存储信息，以便程序或shell中运行的脚本能够轻松访问。这也是持久存储数据的一种简便方法。\nUNIX支持两种变量:环境变量和局部变量。（shell变量是字符串）\n 环境变量：为系统所知道的变量名，通常由系统管理员定义。 局部变量：用户定义，并完全由用户控制。  9.2.1 显示和清除变量：set和unset命令 使用set命令可以查看当前使用的shell变量\n使用echo显示变量的值。在这种情况下引用某个环境变量的时候，必须在变量前面 加上一个美元符（$）。\necho $HOME 在echo命令中，在变量名前加上$可不仅仅是要显示变量当前的值。它能够让变量作为命令 行参数。\nls $HOME 全局环境变量可用于进程的所有子shell。\nunset可以清除不想要的变量，也可以用赋值语句来修改用户变量或者标准变量。注意：标准shell变量的改变是占时的，只用于当前会话，当下次登录时，还要重新进行设置。如果想要长久改变系统变量的值，可以把变量放到名为.profile的文件中。\n9.2.2 标准 shell 变量  HOME 变量：shell把用户主目录的完整路径赋值给变量HOME。 IFS 变量：内部字段分隔符，用来用户输入的分隔命令。包括空格，tab，换行符。即IFS=$' \\t\\n' 。 MAIL 变量：接收用户邮件文件的文件名。 PATH 变量：shell在定位命令时所要查找的目录名。UNIX一般把可执行文件存在一个叫做bin的目录中。以下是我的键入shell后的结果：  PATH=\u0026#39;/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games 9.3 其他元字符 9.3.1 重音符号 shell执行重音符号`中的命令，并将命令的输出插入到命令行的相应位置中，也被称为命令替换符。\n9.3.2 括号 将几个命令放在括号里，可以编组。一个命令组可以像单条命令一样被重定向。\n9.3.3 后台处理\u0026amp; jobs命令列举后台执行的作业\n9.4 其他UNIX工具 9.4.1 延时定时 sleep，让某个命令延缓一段时间执行。\n9.4.2 显示PID 当程序运行在系统上时，我们称之为进程（process）。想监测这些进程，需要熟悉ps命令的 用法。ps命令能输出运行在系统上的所有程序的许多信息。\n默认情况下，ps命令并不会提供那么多的信息,只显示PID,TTY,TIME,COMMAND\n默认情况下，ps命令只会显示运行在当前控制台下的属于当前用户的进程。\n   选项 功能     -a 显示所有进程，但不包括会话leader，不包括无终端进程   -f 显示进程完整信息   -e 显示所有进程   -H 按照树型显示   -j 按照job形式输出    9.4.3 kill命令 终止不想要的进程\n根据执行情况的不同，kill发送给进程的信号范围可以取1-15.\n9.4.4 分离输出 tee将命令结果显示到终端同时保存到指定文件中。\nsort new.list|tee new1.list\n9.4.5 文本排序 sort对文件内容按照字母或数字排序。\n9.5 列出之前输入的命令 Bash在执行命令后，会在内存中记录所有使用的命令。当用户退出登录，所有命令保存在~/.bash_history文件中，history命令则列出到目前为止，执行的所有命令。使用这一功能可以使用用户已经键入过的命令，找到已经执行过的命令。\n~/.bash_history记录的是到上次退出前的所有命令，会一直增加并保存，最终会变得非常大。想要重新记录history的话可以将其删除。\nfc命令:列出、编辑和重复执行history命令列表文件的命令。\nfc first last 先编辑从first到last的命令，然后执行\nfc –s cmd cmd是history的命令编号，执行该编号任务\n9.6 创建别名 alias ll=‘ls –al’设置ll为ls -al命令的别名。\n第10章 Unix通信 UNIX提供了一组与其他用户通信的命令和工具。\n10.1 通信方式 10.1.1 write命令 write命令可以发送消息给系统内其他的已经登陆的用户。另一个用户无论在干什么，消息都会出现在屏幕上。甚至在使用vi时，write消息也会显示在光标处。但仅仅是覆盖在屏幕上的消息，不会破坏用户正在编辑的任务。当然也可以使用mesg禁止终端接收来自write命令的消息。\n10.1.2 显示新闻：news命令 用户可以使用news命令来看看系统正在做什么。news从系统news命令读出消息。默认显示news目录下用户还没有看过的所有文件。\n   选项 操作     -a 显示所有的新闻项，无论是新的还是旧的   -n 仅仅列出新闻名   -s 显示当前新闻的总数    10.1.3 广播消息：wall命令 wall(write all)命令给当前登录到系统上的所有用户发送消息。通常由系统管理员使用，用于通知用户一些紧急事件。\n10.1.4 全双工通信：talk命令 talk命令与write相似，都用于用户与系统中已经登录的其他用户通信。输入talk和用户名，连接建立成功，两个用户就可以进行交谈了。这时，双方的终端屏幕上都将显示信息[Connection established]并响铃，同时屏幕被linux中talk命令程序以一条水平线分割为上下两部分，上半部分用来显示用户自己输入的内容，下半部分用来显示对方输入的内容。两个用户可以同时输入，他们输入的内容将会立即显示在双方的屏幕上。\n在用户进行输入时，可按BACKSPACE见来更正前一个字符，也可按CTRL+w来删除一个完整的单词，或者用CTRL+U来删除一整行，另外，用户还可以通过按CTRL+L来刷新屏幕。如果要结束交谈，可由任何一方按下CTRL+C来中断连接，但在结束对话前最好道声“再见”，并等待对方回应。linux中talk命令程序结束时，在屏幕上将回显示一条信息：\n[Connection closing. Exiting] 并非每次要求对方交谈都能成功，有时对方没有登录，则linux中talk命令程序提示信息：\n[Your party is not logged on] 并退出；如果对方已登录，但因某种原因（如不是正在使用机器）没有响应，那么linux中talk命令程序将会每隔10秒钟给他发一条邀请信息，同时在自己的屏幕上显示：\n[Ringing your party again] 如果用户不愿等待，则可以按CTRL+C终止linux中talk命令程序。还有的时候系统可能出现下面的信息： [Checking for invitation on caller’s machine] 这说明双方的linux中talk命令程序不兼容，这时可以试试ntalk和ytalk命令，如果没有，就只好找系统管理员了。\n如果用户在做某些紧急工作（如编辑邮件）时不希望被linux中talk命令的邀请打搅，他可以使用命令：mesg n来暂时拒绝交谈，这时如果有用户邀请他交谈，只能得到提示信息：[Your party is refusing messages]\n10.2 电子邮件 mailx工具为用户提供电子邮件系统，可以给系统上其他用户发邮件，无论对方是否已经登录到系统。\n当用户使用mailx读取文件时，它处于命令模式，该模式的命令提示符是问号。\n   命令 功能     ! 让用户执行shell命令（shell转义）   cd directory 切换到指定的目录direction，如果没有指定目录，则切换到主目录   d 删除指定消息   f 显示消息头行   q 退出mail，并将消息从系统邮箱移去   h 显示当前消息头   m users 给指定用户users发送邮件   R messages 给消息messages发送者回复消息   r messages 给消息messages发送者和同一消息的其他所有接收者回复消息   s messages 保存消息到filename文件   t messages 显示指定消息messages   u messages 恢复已删除的指定消息messages   x 退出mailx，不将消息从系统邮箱中移去    mailx的~转义命令\n   命令 功能     ~? 显示~转义命令列表   ~! command 在编辑邮件时，让用户调用指定的shell命令command   ~ e 调用编辑器   ~ p 显示当前正编辑的消息   ~r filename 读取filename文件   ~\u0026lt; filename 读取filename文件   ~\u0026lt;! command 执行指定命令command   ~v 调用默认编辑器vi   ~q 推出输入模式   ~w filename 将当前正编辑的消息写到filename文件中    第11章 GNU 工具链 11.1 Gnu工具链 Gnu toolchain是开发操作系统、应用程序的一套完整的程序和库，包括gcc、gdb、glibc：\n11.2 gcc 是一族编译器，包括c、c++、go、java等\n前端+后端\n  .c为后缀的文件，C语言源代码文件；\n  .a为后缀的文件，是由目标文件构成的档案库文件；\n  .C、.cc或.cxx 为后缀的文件，是C++源代码文件；\n  .h为后缀的文件，是程序所包含的头文件；\n  .i 为后缀的文件，是已经预处理过的C源代码文件；\n  .ii为后缀的文件，是已经预处理过的C++源代码文件；\n  .m为后缀的文件，是Objective-C源代码文件；\n  .o为后缀的文件，是编译后的目标文件；\n  .s为后缀的文件，是汇编语言源代码文件；\n  .S为后缀的文件，是经过预编译的汇编语言源代码文件。\n  C语言编译过程\n  gcc -E hello.c -o hello.i\n  gcc -S hello.i -o hello.s\n  gcc -c hello.s -o hello.o\n  gcc -o hello hello.o\n  11.3 gdb  gdb program     命令 缩写 描述     list l 打印当前位置源码   break b 设置断点   run r 运行程序   step s 单步，进入函数   next n 单步，不进入函数   print p 打印变量   continue c 继续运行   backtrace bt 显示调用栈   info threads  显示线程   thread n  切换线程   set scheduler-locking on  关闭线程调度    11.4 makefile Makefile用于工程组织和编译，与常见的命令式语言不同，它是一种依赖推导语言。\nShell语言：变量定义+命令执行\nMakefile：变量定义+依赖描述\n显式规则与隐式规则\n  %.o: %.c\n  $(COMPILE.c) $(OUTPUT_OPTION) $\u0026lt;\n  推导规则\n  检查目标和依赖文件的时间，如果依赖更新，则执行动作\n  显式规则 \u0026gt; 隐式规则\n  推导过程\n  动态规划\n  从target出发，枚举所有规则，直到依赖可达\n  11.5 cmake cross platform make跨平台自动化建置系统。\nCmake vs Makefile\n Makefile的依赖推导不直观 Cmake的语法设计采用命令式 跨平台，可以导出为makefile、sln等  Cmake在不同平台上生成不同的本地化脚本\n Linux下的Gnu Makefile Visual Studio的sln Google等ninja  Cmake管理的代码编译主要有两步：\n  利用cmake生成本地编译脚本\n  利用本地脚本编译程序\n  基本语法\n  定义工程\n  设置变量\n  添加可执行目标\n  添加递归目录\n  添加静态库、动态库\n  条件分支\n  定制命令和目标add_custom_command/add_custom_target\n  11.6 git 虽然之前学了下git，但学得不够深入，最近重新看了一下git的相关知识\nGit 工作区、暂存区和版本库概念：\n **工作区：**就是你在电脑里能看到的目录。 **暂存区：**英文叫 stage 或 index。一般存放在 .git 目录下的 index 文件（.git/index）中，所以我们把暂存区有时也叫作索引（index）。 **版本库：**工作区有一个隐藏目录 .git，这个不算工作区，而是 Git 的版本库。  下面这个图展示了工作区、版本库中的暂存区和版本库之间的关系：\ngit clone、git push、git add 、git commit、git checkout、git pull\n以前只会git push后面不加东西，然后在推送blog时出现了一些问题\n命令格式如下：\ngit push \u0026lt;远程主机名\u0026gt; \u0026lt;本地分支名\u0026gt;:\u0026lt;远程分支名\u0026gt; 如果本地分支名与远程分支名相同，则可以省略冒号：\ngit push \u0026lt;远程主机名\u0026gt; \u0026lt;本地分支名\u0026gt; 实例\n以下命令将本地的 master 分支推送到 origin 主机的 master 分支。\n$ git push origin master 相等于：\n$ git push origin master:master 如果本地版本与远程版本有差异，但又要强制推送可以使用 \u0026ndash;force 参数：\ngit push --force origin master 删除主机但分支可以使用 \u0026ndash;delete 参数，以下命令表示删除 origin 主机的 master 分支：\ngit push origin --delete master 分支\n想push时不影响原来的远程分支，怎么办？回退很麻烦，那怎么办？\n创建分支命令：\ngit branch (branchname) 切换分支命令:\ngit checkout (branchname) 当你切换分支的时候，Git 会用该分支的最后提交的快照替换你的工作目录的内容， 所以多个分支不需要多个目录。\n合并分支命令:\ngit merge 你可以多次合并到统一分支， 也可以选择在合并之后直接删除被并入的分支。\n开始前我们先创建一个测试目录：\n$ mkdir gitdemo$ cd gitdemo/$ git initInitialized empty Git repository...$ touch README$ git add README$ git commit -m '第一次版本提交'[master (root-commit) 3b58100] 第一次版本提交 1 file changed, 0 insertions(+), 0 deletions(-) create mode 100644 README  Git 分支管理 列出分支 列出分支基本命令：\ngit branch 没有参数时，git branch 会列出你在本地的分支。\n$ git branch* master 此例的意思就是，我们有一个叫做 master 的分支，并且该分支是当前分支。\n当你执行 git init 的时候，默认情况下 Git 就会为你创建 master 分支。\n如果我们要手动创建一个分支。执行 git branch (branchname) 即可。\n$ git branch testing$ git branch* master testing 现在我们可以看到，有了一个新分支 testing。\n当你以此方式在上次提交更新之后创建了新分支，如果后来又有更新提交， 然后又切换到了 testing 分支，Git 将还原你的工作目录到你创建分支时候的样子。\n接下来我们将演示如何切换分支，我们用 git checkout (branch) 切换到我们要修改的分支。\n$ lsREADME$ echo 'runoob.com' \u0026gt; test.txt$ git add .$ git commit -m 'add test.txt'[master 3e92c19] add test.txt 1 file changed, 1 insertion(+) create mode 100644 test.txt$ lsREADME test.txt$ git checkout testingSwitched to branch 'testing'$ lsREADME 当我们切换到 testing 分支的时候，我们添加的新文件 test.txt 被移除了。切换回 master 分支的时候，它们有重新出现了。\n$ git checkout masterSwitched to branch 'master'$ lsREADME test.txt 我们也可以使用 git checkout -b (branchname) 命令来创建新分支并立即切换到该分支下，从而在该分支中操作。\n$ git checkout -b newtestSwitched to a new branch 'newtest'$ git rm test.txt rm 'test.txt'$ lsREADME$ touch runoob.php$ git add .$ git commit -am 'removed test.txt、add runoob.php'[newtest c1501a2] removed test.txt、add runoob.php 2 files changed, 1 deletion(-) create mode 100644 runoob.php delete mode 100644 test.txt$ lsREADME runoob.php$ git checkout masterSwitched to branch 'master'$ lsREADME test.txt 如你所见，我们创建了一个分支，在该分支的上移除了一些文件 test.txt，并添加了 runoob.php 文件，然后切换回我们的主分支，删除的 test.txt 文件又回来了，且新增加的 runoob.php 不存在主分支中。\n使用分支将工作切分开来，从而让我们能够在不同开发环境中做事，并来回切换。\n删除分支 删除分支命令：\ngit branch -d (branchname) 例如我们要删除 testing 分支：\n$ git branch* master testing$ git branch -d testingDeleted branch testing (was 85fc7e7).$ git branch* master 分支合并 一旦某分支有了独立内容，你终究会希望将它合并回到你的主分支。 你可以使用以下命令将任何分支合并到当前分支中去：\ngit merge$ git branch* master newtest$ lsREADME test.txt$ git merge newtestUpdating 3e92c19..c1501a2Fast-forward runoob.php | 0 test.txt | 1 - 2 files changed, 1 deletion(-) create mode 100644 runoob.php delete mode 100644 test.txt$ lsREADME runoob.php 以上实例中我们将 newtest 分支合并到主分支去，test.txt 文件被删除。\n合并完后就可以删除分支:\n$ git branch -d newtestDeleted branch newtest (was c1501a2). 删除后， 就只剩下 master 分支了：\n$ git branch* master 合并冲突 合并并不仅仅是简单的文件添加、移除的操作，Git 也会合并修改。\n$ git branch* master$ cat runoob.php 首先，我们创建一个叫做 change_site 的分支，切换过去，我们将 runoob.php 内容改为:\n\u0026lt;?phpecho 'runoob';?\u0026gt; 创建 change_site 分支：\n$ git checkout -b change_siteSwitched to a new branch 'change_site'$ vim runoob.php$ head -3 runoob.php\u0026lt;?phpecho 'runoob';?\u0026gt;$ git commit -am 'changed the runoob.php'[change_site 7774248] changed the runoob.php 1 file changed, 3 insertions(+) 将修改的内容提交到 change_site 分支中。 现在，假如切换回 master 分支我们可以看内容恢复到我们修改前的(空文件，没有代码)，我们再次修改 runoob.php 文件。\n$ git checkout master Switched to branch 'master' $ cat runoob.php $ vim runoob.php # 修改内容如下 $ cat runoob.php \u0026lt;?php echo 1; ?\u0026gt; $ git diff diff --git a/runoob.php b/runoob.php index e69de29..ac60739 100644 --- a/runoob.php +++ b/runoob.php @@ -0,0 +1,3 @@ +\u0026lt;?php +echo 1; +?\u0026gt; $ git commit -am '修改代码' [master c68142b] 修改代码 1 file changed, 3 insertions(+) 现在这些改变已经记录到我的 \u0026ldquo;master\u0026rdquo; 分支了。接下来我们将 \u0026ldquo;change_site\u0026rdquo; 分支合并过来。\n$ git merge change_site Auto-merging runoob.php CONFLICT (content): Merge conflict in runoob.php Automatic merge failed; fix conflicts and then commit the result. $ cat runoob.php # 代开文件，看到冲突内容 \u0026lt;?php \u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt; HEAD echo 1; ======= echo 'runoob'; \u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt; change_site ?\u0026gt; 我们将前一个分支合并到 master 分支，一个合并冲突就出现了，接下来我们需要手动去修改它。\n$ vim runoob.php $ cat runoob.php \u0026lt;?php echo 1; echo 'runoob'; ?\u0026gt; $ git diff diff --cc runoob.php index ac60739,b63d7d7..0000000 --- a/runoob.php +++ b/runoob.php @@@ -1,3 -1,3 +1,4 @@@ \u0026lt;?php +echo 1; + echo 'runoob'; ?\u0026gt; 在 Git 中，我们可以用 git add 要告诉 Git 文件冲突已经解决\n$ git status -sUU runoob.php$ git add runoob.php$ git status -sM runoob.php$ git commit[master 88afe0e] Merge branch 'change_site' 现在我们成功解决了合并中的冲突，并提交了结果。\n以上文字大多数摘自runoob.com，我感觉是写得非常有条理了，另外介绍一个学习gitbranch的神奇的网站，无聊的时候可以练练手。\nhttps://learngitbranching.js.org/\n第12章 Shell编程 Shell是一种语言，bash、csh\n Unix的传统是提供基本的功能，由用户自行扩展，包括自己编写shell脚本  12.1.1 编写简单脚本 endwsl@LAPTOP-U1E6STIA:~$ cat \u0026lt;\u0026lt;EOF\u0026gt;\u0026gt; won.list\u0026gt; ls\u0026gt; -bash: warning: here-document at line 74 delimited by end-of-file (wanted `EOF')endwsl@LAPTOP-U1E6STIA:~$ cat won.listls 12.1.2 执行脚本 执行脚本 sh won.list :\nendwsl@LAPTOP-U1E6STIA:~$ sh won.list- ew ew.list goodstuff new.list vinew won.list xxxscriptendwsl@LAPTOP-U1E6STIA:~$ 另一种方法：chmod改变文件权限，使其变成可执行\n脚本工作原理\n  loader程序加载脚本，发现不是elf可执行文件，返回错误\n  bash收到错误，然后打开文件头部，发现是脚本\n  调用脚本执行\n  •基于兼容性考虑\n  #! /bin/sh\n  Debian上的/bin/sh符号链接指向dash\n  dash对标准的兼容性更好\n  12.2.1 使用特殊字符 echo换行：echo \u0026quot;\\nhello\\n\u0026quot;\n12.2.2 退出系统的方式 在shell脚本里写exit是没用的，因为shell会fork子进程来执行命令。\n12.2.3 点命令 可以使用点命令来阻止shell创建子进程。\n12.2.4 读取命令：read 从标准输入设备读取用户输入，并将值存入用户自定义变量中。\n12.3.1 注释 12.3.2 变量 字符串类型，具体内容在前面讲过。\n12.3.3 命令行参数 shell脚本可以从命令行最多读取10个命令行参数存入特殊变量，命令行参数是用户输入命令后所跟的数据项，通常用空格分隔。这些变量按顺序从1到9计数。\n   参数变量     $1-$9，${10}表示参数   $0表示被调用脚本的名字   $#表示参数个数   $*将所有参数使用$IFS隔开，形成一个字符串   $@是每个参数一行，将参数隔开，实际上是多个字符串，可以用在for循环   $$表示当前进程id    特殊变量\n  $?表示进程退出状态\n  ls -al hello\n  echo $? 前面命令退出的状态\n  另外一个给变量赋值的方式是set\nset hello \u0026quot;I love bash\u0026quot; world\nendwsl@LAPTOP-U1E6STIA:~$ echo $0-bashendwsl@LAPTOP-U1E6STIA:~$ echo $#0endwsl@LAPTOP-U1E6STIA:~$ set hello \u0026#34;i love\u0026#34; worldendwsl@LAPTOP-U1E6STIA:~$ echo $#3 //3个参数hello 和\u0026#34;i love\u0026#34;和worldendwsl@LAPTOP-U1E6STIA:~$ echo $1helloendwsl@LAPTOP-U1E6STIA:~$ echo $2i love bashendwsl@LAPTOP-U1E6STIA:~$ echo $3worldendwsl@LAPTOP-U1E6STIA:~$ echo $* //$*和$@相似hello i love world endwsl@LAPTOP-U1E6STIA:~$ echo $*hello i love worldendwsl@LAPTOP-U1E6STIA:~$ echo $@hello i love world 12.3.4 条件与测试 if-then-elif结构：\nif条件; then command1elif command2then command3else command4fi 真或假：test命令\n实际上，if语句中括住条件的方括号是test命令的一种特殊形式。\n例子：\nminatoxeon@OMEN:~$ cat eg_conditionechoecho \u0026#34;enter y or n:\\c\u0026#34;read condif [ $cond = y ]then echo \u0026#34;you enter y\u0026#34;else echo \u0026#34;you not enter n\u0026#34;fiechoexit 0minatoxeon@OMEN:~$ sh eg_conditionenter y or n:yyou enter yminatoxeon@OMEN:~$ sh eg_conditionenter y or n:llyou not enter n 12.3.5 不同类型的判断 不单单是相等的判断，test可以进行多种类型的判断\n   操作符 例子 含义     -eq a -eq b a是否等于b   -ne a -ne b a是否不等于b   -gt a -gt b a是否大于b   -ge a -ge b a是否大于大于b   -lt a -lt b a是否小于b   -le a -le b a是否小于等于b    test还可以比较字符串\n    操作符 示例 说明     = “$STR1” = “STR2” 两个字符串是否相同   != “$STR1” != “STR2” 两个字符串是否不同   -n -n “$STR” 字符串不是null   -z -z “$STR” 字符串是null    注意：在引用变量做字符串测试时，一定要加引号\n操作符两侧必须有空格\n[ … ]中括号必须有空格 [ \u0026quot;$VAR1\u0026quot; = \u0026quot;VAR3\u0026quot; ]\n文件\n12.3.6 参数替换 用户可以检验参数的值并根据选项改变它的值。\n格式为${parameter:optionchar word}\n变量替换\n   替换操作 功能     ${VAR:-word} 如果变量不存在，返回word #变量不会创建   ${VAR:=word} 如果变量不存在，设置VAR变量为word，返回word   ${VAR:?message} 如果变量不存在，打印message，退出，但交互shell不会退出   ${VAR:+word} 如果变量存在，返回word；否则返回null    endwsl@LAPTOP-U1E6STIA:~$ echo ${VAR:-world} #变量不会创建worldendwsl@LAPTOP-U1E6STIA:~$ echo $VAR ${var:?meg}通常用来显示错误信息\n12.4 算术表达式 12.4.1 算术运算：expr命令 在powershell里可以直接输入1+1，会得到2\n但是在shell里直接输入1+1不会有结果，因为Shell会把1单作是字符串而不是变量，那么要想在shell里面计算1+1怎么办？\nexpr 1+1 expr提供数字和非数字的关系运算符\n12.4.2 算术运算：let命令 let命令与expr命令类似，并可以相互替换。\nlet命令自动使用变量的值：\nminatoxeon@OMEN:~$ x=100minatoxeon@OMEN:~$ let x=x+1minatoxeon@OMEN:~$ echo $x101 let命令的缩写：双括号(())\n下面就是i++的经典问题\nendwsl@LAPTOP-U1E6STIA:~$ i=4endwsl@LAPTOP-U1E6STIA:~$ echo $i4endwsl@LAPTOP-U1E6STIA:~$ echo $((i++)) $i4 5endwsl@LAPTOP-U1E6STIA:~$ echo $((++i)) $i6 6 12.5 循环结构  Shell提供三种循环：for、while、until 循环与分支类似，都带有一定的结构，是shell语言的支持  12.5.1 for循环：for-in-done 结构 for variablein list-of-valuesdo\tcommands ...\tlast-commanddone 例子：\nendwsl@LAPTOP-U1E6STIA:~$ cat sum1.sh#! /bin/bashtotal=0for i in \u0026quot;$@\u0026quot;do total=$(($total + $i)) printf \u0026quot;$i + \u0026quot;doneprintf \u0026quot;\\b\\b= $total\u0026quot; 12.5.2 while循环 直接上例子：\nendwsl@LAPTOP-U1E6STIA:~$ cat sum.sh #! /bin/bash #这里的$#每经过一轮循环就会减1 #位置参数可以用shift命令左移 total=0 while [ $# -gt 0 ]; do total=$(($total + $1)) printf \u0026quot;$1 + \u0026quot; shift done printf \u0026quot;\\b\\b= $total\u0026quot; 12.5.3 until循环 #! /bin/bash total=0 until [ $# -le 0 ]; do total=$(($total + $1)) printf \u0026quot;$1 + \u0026quot; shift done printf \u0026quot;\\b\\b= $total\u0026quot; 逻辑连接 这里的\u0026amp;\u0026amp;和||和预想的会很不一样，举例如下：\ncommand1 \u0026amp;\u0026amp; command2当command1正确执行，才会执行command2\n相当于：\nif command1 : command2 command1 || command2，当command1执行错误，才会执行command2\nif !command1 : command2 代码分块 将多行命令用分号;隔开，再利用()将多条命令组合在一起\nendwsl@LAPTOP-U1E6STIA:~$ (date ; echo $$)(date ; echo $$)+ dateMon 26 Apr 2021 09:07:31 PM CST+ echo 1717 算术表达式测试\n 利用$(())计算算术表达式 利用字符串比较 [ $((2+3)) = 5 ]; echo $? i=3; [ $((i+7)) = 10 ];echo $?  调试 替换处理后真实执行的指令，比如展开$$\nendwsl@LAPTOP-U1E6STIA:~$ echo \u0026quot;hello world\u0026quot;hello worldendwsl@LAPTOP-U1E6STIA:~$ set -vxendwsl@LAPTOP-U1E6STIA:~$ echo \u0026quot;hello world\u0026quot;echo \u0026quot;hello world\u0026quot; #原始命令+ echo 'hello world' #替换处理后真实执行的指令hello world# 指令结果endwsl@LAPTOP-U1E6STIA:~$  第13章 Shell脚本：编写应用程序 13.2 UNIX内核：信号 终止一个进程可以通过产生一个中断信号来终止进程。例如Del键、Break键和Ctrl-c键。\n有几类不同的事件导致内核向进程发送信号。信号编号表明它们代表的事件。\n   信号编号 信号名 含义     1 挂起 丢失终端连接   2 中断 按下任一中断键   3 退出 按下任一退出键   9 杀死 发出kill-9命令   15 终止 发出kill命令    挂起信号：信号1用来通知进程系统已经与终端失去联系。当用户终端和计算机的连线断开，或者电话线（用来调制解调器相连）断开时，产生该信号。在某些系统中，如果用户关闭终端，系统也会产生挂起信号。\n中断信号：当按下任何一个中断键时，产生信号2。中断键可以是Del键、Break键或者Ctrl-c键。\n退出信号：当按下Ctrl-\\键时，产生信号3。在进程终止之前，将进行内存信息转储。\n终止信号：信号9和15由kill命令产生。信号15是默认的信号。信号9和15都使收到信号的进程终止。\nkill -l查看信号表\nendwsl@LAPTOP-U1E6STIA:~$ kill -l 1) SIGHUP 2) SIGINT 3) SIGQUIT 4) SIGILL 5) SIGTRAP 6) SIGABRT 7) SIGBUS 8) SIGFPE 9) SIGKILL 10) SIGUSR111) SIGSEGV 12) SIGUSR2 13) SIGPIPE 14) SIGALRM 15) SIGTERM16) SIGSTKFLT 17) SIGCHLD 18) SIGCONT 19) SIGSTOP 20) SIGTSTP21) SIGTTIN 22) SIGTTOU 23) SIGURG 24) SIGXCPU 25) SIGXFSZ26) SIGVTALRM 27) SIGPROF 28) SIGWINCH 29) SIGIO 30) SIGPWR31) SIGSYS 34) SIGRTMIN 35) SIGRTMIN+1 36) SIGRTMIN+2 37) SIGRTMIN+338) SIGRTMIN+4 39) SIGRTMIN+5 40) SIGRTMIN+6 41) SIGRTMIN+7 42) SIGRTMIN+843) SIGRTMIN+9 44) SIGRTMIN+10 45) SIGRTMIN+11 46) SIGRTMIN+12 47) SIGRTMIN+1348) SIGRTMIN+14 49) SIGRTMIN+15 50) SIGRTMAX-14 51) SIGRTMAX-13 52) SIGRTMAX-1253) SIGRTMAX-11 54) SIGRTMAX-10 55) SIGRTMAX-9 56) SIGRTMAX-8 57) SIGRTMAX-758) SIGRTMAX-6 59) SIGRTMAX-5 60) SIGRTMAX-4 61) SIGRTMAX-3 62) SIGRTMAX-263) SIGRTMAX-1 64) SIGRTMAX 13.2.1 捕捉信号：trap命令 当进程接收到任何信号时，其默认处理功能是立即终止。使用trap命令可以改变进程的默认处理功能，执行指定的处理功能。\ntrap命令的格式：trap\u0026quot;optional commands\u0026quot;signal numbers\ncommands部分是可选的。如果有这一部分，当进程收到任一指定捕捉信号时，执行这些命令。\n注意：trap指定的命令必须用单引号或者双引号括起来。\n说明：1. 可以指定捕捉多个信号。\n​\t2.信号编号是与用户希望用trap命令捕捉的信号相关联的数字。\n13.2.2 捕捉复位 当希望在脚本中的一部分捕捉信号，而另一部分不捕捉信号时，捕捉复位命令就很有用。\n例如：\n $trap \u0026quot; \u0026quot;2 3 15 忽略中断、退出和终止信号，如果按下这些键中的任一个，脚本继续运行。 $trap 2 3 15 复位指定的信号，就是恢复中断、退出和终止键。按下些键中的任一个，正在运行的脚本就会终止。  13.2.3 设置终端参数：stty命令 stty命令用来设置和显示终端属性。不带参数的stty命令显示指定的一组设置。用-a选项可以列出所有的终端设置。\n•stty设定终端模式\n stty –echo禁止回显，输入口令时，同时也会把命令会先禁了 stty echo打开回显，撤销上一步  13.3 对终端的进一步讨论 UNIX操作系统支持多钟终端类型，功能不限于清屏，还有粗字体、闪烁、下划线，等等。利用这些特性能使屏幕显示更有意义或更美观。\n13.3.1 终端数据库：terminfo文件 terminfo数据库是一个文本文件，其中包括各种终端类型的描述。数据库里的每一类终端都有一个功能列表。\n13.3.2 设置终端功能：tput命令 tput实用程序允许用户打印出任一功能的值。这样就可以在shell编程中使用终端的功能。\n•tput向终端缓冲输出控制字符\n•tput clear清屏\n•tput cup row column移动光标到row行column列\n终端功能的简单列表：\n   参数 功能     bel 回显终端的响铃字符   blink 闪烁显示   bold 粗体显示   clear 清屏   cup r c 将光标移到r行c列   dlim 使显示变暗   ed 从光标位置到屏幕底清屏   el 清除从光标位置到行末的字符   smso 启动突显模式   rmso 结束突显模式   smul 启动下划线模式   rmul 结束下划线模式   rev 反色显示，白底上显示黑色   sgr 0 关闭所有属性    13.4 其他命令 多路分支：case结构 当需要使用许多elif语句时，用case结构更好。\ncase、in和esac（case的反序）是保留字（关键字）。case和esac之间的语句称为case结构体。\nshell执行case语句时，将变量的内容与每一个模式比较，知道发现一个匹配或者shell到达关键字esac。shell执行与匹配模式相关联的命令。默认情况用*)表示，必须是程序的最后一种情况。每一种情况用两个分号（；；）结束。\n其他命令 磁盘命令\ndu\nendwsl@LAPTOP-U1E6STIA:~$ df Filesystem 1K-blocks Used Available Use% Mounted on /dev/sdb 263174212 788056 248948000 1% / tmpfs 6475860 0 6475860 0% /mnt/wsl tools 209715196 192647796 17067400 92% /init none 6473568 0 6473568 0% /dev none 6475860 4 6475856 1% /run none 6475860 0 6475860 0% /run/lock none 6475860 0 6475860 0% /run/shm none 6475860 0 6475860 0% /run/user tmpfs 6475860 0 6475860 0% /sys/fs/cgroup C:\\ 209715196 192647796 17067400 92% /mnt/c D:\\ 289083388 253954812 35128576 88% /mnt/d tar\n•tar zcfv压缩成.tar.gz文件\n•tar zxfv解压.tar.gz文件\n•tar Jcfv压缩成.tar.xz文件\n•tar Jxfv解压.tar.xz文件\n•tar jcfv压缩成.tar.bz2文件\n•tar jxfv解压.tar.bz2文件\nchown修改文件目录的owner,修改inode\nchgrp修改文件目录的group\n","date":"2021-06-17T13:50:16+08:00","permalink":"https://uest.xyz/posts/unix%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/","section":"posts","tags":null,"title":"Unix读书笔记"},{"categories":null,"contents":"19. 删除链表的倒数第 N 个结点 难度中等\n给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。\n**进阶：**你能尝试使用一趟扫描实现吗？\n示例 1：\n输入：head = [1,2,3,4,5], n = 2 输出：[1,2,3,5] 示例 2：\n输入：head = [1], n = 1 输出：[] 示例 3：\n输入：head = [1,2], n = 1 输出：[1] 提示：\n 链表中结点的数目为 sz 1 \u0026lt;= sz \u0026lt;= 30 0 \u0026lt;= Node.val \u0026lt;= 100 1 \u0026lt;= n \u0026lt;= sz  相比昨天写的147题，这个明显就简单很多，一次遍历解题的关键：两个间隔长度为n的指针，当第二个指针滑到最后时，第一个指针就达到的倒数第n个，此时删除这一个节点就行了。\n小技巧，添加dummy节点，以防第一个节点被删除。\npublic static ListNode removeNthFromEnd(ListNode head, int n) { ListNode dummyHead =new ListNode(0); dummyHead.next=head; ListNode pre=dummyHead; ListNode last=dummyHead; for(int i=0;i\u0026lt;n;i++){ last=last.next; } while(last.next!=null){ last=last.next; pre=pre.next; } pre.next=pre.next.next; return dummyHead.next; } ","date":"2021-05-05T23:26:12+08:00","permalink":"https://uest.xyz/posts/19%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACn%E4%B8%AA%E7%BB%93%E7%82%B9/","section":"posts","tags":null,"title":"19删除链表的倒数第N个结点"},{"categories":null,"contents":"147. 对链表进行插入排序  对链表进行插入排序。\n插入排序的动画演示如上。从第一个元素开始，该链表可以被认为已经部分排序（用黑色表示）。 每次迭代时，从输入数据中移除一个元素（用红色表示），并原地将其插入到已排好序的链表中。\n插入排序算法：\n 插入排序是迭代的，每次只移动一个元素，直到所有元素可以形成一个有序的输出列表。 每次迭代中，插入排序只从输入数据中移除一个待排序的元素，找到它在序列中适当的位置，并将其插入。 重复直到所有输入数据插入完为止。  示例 1：\n输入: 4-\u0026gt;2-\u0026gt;1-\u0026gt;3 输出: 1-\u0026gt;2-\u0026gt;3-\u0026gt;4 示例 2：\n输入: -1-\u0026gt;5-\u0026gt;3-\u0026gt;4-\u0026gt;0 输出: -1-\u0026gt;0-\u0026gt;3-\u0026gt;4-\u0026gt;5  看起来很简单的插入排序花了我一晚上.\n插入排序不需要多讲，题面总结得很精辟，每一步将一个待排序的数据插入到前面已经排好序的有序序列中，直到插完所有元素为止。在其实现过程使用双层循环，外层循环对除了第一个元素之外的所有元素，内层循环对当前元素前面有序表进行待插入位置查找，并进行移动。\n插入排序的平均时间复杂度也是 O(n^2)，空间复杂度为常数阶 O(1)，具体时间复杂度和数组的有序性也是有关联的。\n插入排序中，当待排序数组是有序时，是最优的情况，只需当前数跟前一个数比较一下就可以了，这时一共需要比较 N-1 次，时间复杂度为 O(N)。最坏的情况是待排序数组是逆序的，此时需要比较次数最多，最坏的情况是 O(n^2)。\n但是 链表就不能简单移动了，而是要做到插入（把节点插入相应的地方），遍历找到要插入的地方以后，还要实现交换操作（和数组最大的不同也是最难的地方）\npublic static ListNode insertionSortList(ListNode head) { ListNode todo=head.next; /*最坑的地方是在画图，总结到一个经验，画图其实不如调试，调试起来看变化，再画图微调最好，傻乎乎画图最后会绕死进去 * 添加一个表头节点非常有必要，这还是看题解发现的，不然插入时只能分情况讨论越来越复杂 * pre节点防止断裂，注意要及时更新pre节点 * todo这种变量名就不知所云，下次记得用cur * */ ListNode dummyHead=new ListNode(0); dummyHead.next=head; ListNode todohead=dummyHead; ListNode todopre=dummyHead.next; while (todo!=null){ while(todohead.next!=null\u0026amp;\u0026amp; todo.val\u0026gt;todohead.next.val){ todohead=todohead.next; } if(todo==todohead.next){ /*不能用值的比较！！！！，这个是作为循环终止的条件（使用continue直接下一步，防止进行5步交换）：等到todohead.next循环到todo时，让todo后移，注意不仅仅要使得todo后移，todopre也要后移，todohead要归零*/ todo=todo.next; todopre=todopre.next; todohead=dummyHead; continue; } todopre.next=todo.next; todo.next=todohead.next; todohead.next=todo; todo=todopre.next; todohead=dummyHead; //这5步画图吧  } return dummyHead.next; } ","date":"2021-05-04T22:08:41+08:00","permalink":"https://uest.xyz/posts/147%E9%93%BE%E8%A1%A8%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/","section":"posts","tags":null,"title":"147链表插入排序"},{"categories":null,"contents":"class moveZeroes { public static void moveZeroes(int[] nums){ //快慢指针的思想和removeElement这一题有着异曲同工之妙 int i=0,j=0;//i是慢指针 指向第一个0，j是快指针 指向第一个非0 for(;;i++){ if(nums[i]==0)break;//虽然我也觉得这里的循环写得很奇怪，但是思想还是很清晰的：第一个找到0！！如果出界就退出 if(i+1==nums.length) return; } j=i+1;//j是从i右边开始起步的 for (;;j++){ if(j\u0026gt;=nums.length) return; if(nums[j]!=0)break; } // System.out.println(i+\u0026quot;j\u0026quot;+j+\u0026quot;----------\u0026quot;); for(;j\u0026lt;nums.length;j++){ if(nums[j]!=0){ if(nums[j]!=0){ nums[i]=nums[j]; nums[j]=0; i++; } } } } public static void main(String[] args) { int []nums={0,0}; moveZeroes(nums); for(int i=0;i\u0026lt;nums.length;i++){ System.out.println(nums[i]); } } } ","date":"2021-04-30T17:01:19+08:00","permalink":"https://uest.xyz/posts/283.%E7%A7%BB%E5%8A%A80/","section":"posts","tags":null,"title":"283"},{"categories":null,"contents":"来源https://sspai.com/post/59904\n利用github + hugo 搭建轻量化的blog ，非常有用的教程！\n1. 安装 Git 和 Go 使用Hugo前需要安装Git 和 Go 语言开发环境，点击对应网址下载安装包即可。\n2. 安装Hugo 网上存在很多用工具安装的方式，我这里讲述一个我认为最简单的方式，不用涉及太多的代码（本方法针对pc）。\n（1）在Hugo的官网中选择想要的版本下载zip，将其中的hugo.exe文件解压到想要的地方，比如 C:\\Hugo\\bin。\n（2）将Hugo添加到Windows的环境变量 PATH中。\n（3）添加完PATH后，打开Git Bash 输入 hugo version 出现hugo static site generator相关信息表示安装完成。\n3. 生成博客 （1）打开Git Bash 输入hugo new site \u0026quot;你的文件名字\u0026quot;，便可以生成一个用于存放博客的文件夹。\n（2）安装主题。\n不同于hexo，hugo没有自带主题，所以建立完文件夹后要导入主题文件。导入主题方式和hexo相似，可以用git clone 的方式，也可以到相应主题的github中下载zip文件然后解压到自己博客的themes文件夹中。\n推荐几个主题：Pure、Even、Coder\n官网主题库：Hugo Themes\n（3）配置文件\nHugo配置文件放置在源文件下，并且支持三种格式：toml，yaml，yml。这个配置文件可以直接从主题文件中的exampleSite 里copy到博客文件夹下，然后进行修改。\n 注意点1：有些主题没有提供相应的配置文件，得进行自己修改，不建议选用这类主题。 注意点2：配置文件中要确保里面的主题名字和你themes文件夹中相应的主题文件夹名字一样，比如我的主题是pure，那么配置文件里的theme = pure，并且themes 文件夹中也有一个pure的文件夹。这是为了保证工具能依据名字找到相应的主题文件。  （4）生成博文\n在 Git Bash 中输入 hugo new posts/xxxx.md，这时候就会在文件夹 content/posts形成你要的markdown文件，打开进行编辑即可。\n（5）渲染查看效果\n在博客文件夹中打开Git Bash，输入 hugo server，然后打开 http://localhost:1313/ 来查看效果。注意，markdown文件中的 front matter 部分有一个draft 参数，如果draft设置为true 则可正常渲染，如果设置为false则不予以渲染。相应的如果想查看全部效果则输入hugo server -D 表示将草稿文件也进行渲染。\n4. 代码托管 这里主要以GitHub 作为代码托管，假定你已经建立了一个xxx.github.io的一个仓库。官方提供了三四种上传方式，本文采用生成docs的方式进行部署，个人认为这种方式比较简单明了。\n（1）修改配置文件。在配置文件config.toml中添加publishDir = docs，其他格式的配置文件类似。\n（2）打开Git Bash，输入hugo，就会发现博客文件中出现了docs文件夹，这是因为hugo将网页的信息都存储在docs里，而不是public中。\n（3）在博客文件夹中，打开Git Bash，依次输入以下代码（注意 git remote add 后跟随自己github的对应地址）：\ngit remote add origin https://github.com/xxxxx/xxxx.github.io.git git add . git commit -m \u0026quot;first commit\u0026quot; git push -u origin master （4）在GitHub对应的仓库设置中，将Github Pages source改成branch/docs 。\n（5）这时候点击网址会发现内容已经成功渲染了，但是跳转连接出现问题，这是因为我们没有在配置文件中的baseURL中更新我们未来发布的网址链接。因此我们将GitHub Pages 对应的网址进行复制然后添加到配置文件的第一个 baseURL中，重新进行第二步和第三步即可。\n","date":"2021-04-27T21:50:40+08:00","permalink":"https://uest.xyz/posts/%E6%90%AD%E5%BB%BA%E4%B8%8E%E5%8F%91%E5%B8%83blog/","section":"posts","tags":null,"title":"搭建与发布blog"},{"categories":null,"contents":"  这种链表题一定要画图\n  头插法\n  遍历原链表+每次插入到新表最前面\n206. 反转链表 难度简单\n给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。\n示例 1：\n输入：head = [1,2,3,4,5] 输出：[5,4,3,2,1] 示例 2：\n输入：head = [1,2] 输出：[2,1] 示例 3：\n输入：head = [] 输出：[] 提示：\n 链表中节点的数目范围是 [0, 5000] -5000 \u0026lt;= Node.val \u0026lt;= 5000    package Test; class ListNode { int val; ListNode next; ListNode() {} ListNode(int val) { this.val = val; } ListNode(int val, ListNode next) { this.val = val; this.next = next; } }5t class Test { public static ListNode reverseList(ListNode head){ ListNode first= new ListNode(); ListNode copy; if(head!=null){ first.val=head.val; copy=head.next; }else return head; while (copy!=null){ ListNode temp= new ListNode(); temp.val=copy.val; temp.next=first; copy=copy.next; first=temp;//每次first指针前移，让他始终指向第一个元素  } return first; } public static void main(String[] args) { ListNode a=new ListNode(5); a.next=new ListNode(4); a.next.next=new ListNode(3); ListNode b=reverseList(a); while(b!=null){ System.out.println(b.val); b=b.next; } } } ","date":"2021-04-27T20:27:17+08:00","permalink":"https://uest.xyz/posts/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/","section":"posts","tags":null,"title":"反转链表"},{"categories":null,"contents":"评价手机免不了打打嘴炮，写写垃圾，以下为云评测，如有不对的地方敬请指教。\n1.K40系列\nK40系列只有标准版是比较出众的，可以说把性价比做到了极致，卢伟冰可以说很好地完成了雷军交给红米的任务：极致性价比，留下小米的学生党和性价比党用户，并与realme和iqoo相比不落下风。redmi没有品牌转型的任务，价位段封顶4000元，不需要使用最新的技术，所以小米的120W快充不会下放redmi，红米今年的充电上限还是33w。这一点和iqoo不一样，iqoo作为19年的新品牌，初期仍需要打品牌，做充分的推广。所以iqoo从20年失败的iqoo3到120w的iqoo5p，再到今年的iqoo7，努力想做高端手机。\n红米今年K40系列采用几乎相同的磨具，只在SoC和摄像头做区分，pro的升级点可以说少得可怜，3699的pro+甚至还是33w的快充，只能看做成pro的大内存版，没有充足的理由让人掏钱买pro+；这一点，是redmi头顶上有小米11的无奈，如果小米数字旗舰站稳4999价位，那么红米才会有充足的加价空间。\n采用相同的模具可以降低研发、制造、售后成本，降低售价，并且快速进行产能切换，哪款卖得好就生产哪一款，但是也造成了pro的平庸，无法增加更多的配置打动消费者，仅凭1个系列覆盖2000-4000价位段十分困难，所以才会有去年三种不同的屏幕形态的K30，ultra和s ultra\n小米一直希望极致性价比，但是性价比并不是出路。经过市场的磨练，除了小米，其他玩性价比的厂商都死了，虽然可以证明小米的牛逼，但同时也证明了性价比模式的脆弱。小米也意识到这一点，所以在19年时，将性价比的任务全部交给redmi，但是，红米的骨子里永远摆脱不了小米的基因，始终无法做切割。一是红米的独立性不足，战略受限于小米的高层。二是名字相近，红米==小米的印象已经深深刻入大众的骨子里。不像realme和oppo一加，iqoo和vivo，在绝大部分人眼里，红米就是小米的低端，小米就是中低端性价比手机品牌。而要打破这一品牌认知，没有3-5年的积累是不够的，而且需要在3-5年里在核心技术、渠道、售后超越oppo，vivo，才能做到最后的销量超越。\n（K40的顶配是3月初在小米商城用米金兑换的购买资格，日常用它来打paj，不算云评测了哈，在性能释放方面很舒服，但感觉比k30p烫点，不知道是不是开了90hz的缘故）\n2.Realme GT系列\nrealme显然没有做到iqoo的水平，在中高端旗舰产品上比友商差很多，没有特色功能和眼前一亮的点，总之还没找到感觉。\n3.IQOO neo 5\nneo5在大部分参数做到了甚至超过了k40的水平，imx598胜过k40的582，55w快充也比33w快充牛\n但同时也在价格上超越了k40，在买不到K40 的情况下，是公认的平价替代的最佳选择，最高价12+256可以2800左右拿到，仅比k40的12+256黄牛加价版高一点点。没有什么好评价的，k40的第一竞争对手足以说明实例。\n4.小米11 Pro 和 Ultra 及 MIX FOLD\n预热时说产品很多，没想到这么多，更没想到开两天的发布会。重磅消息一个接一个。小米新logo，三个旗舰手机，一个11青春版，一台屏幕素质高的轻薄笔记本，一颗澎湃芯片，最重要的是小米宣布造车。\n手机方面，最具关注的是ultra，作为小米的最高端手机，背面的副屏赚足了眼球，5999的起售价也刷新了记录，6999的顶配12+512，价格不用多说，小米的顶峰。\n67W有线+67W无线，无线刷新了记录，234g的重量也刷新了记录，小米能给你的最好的堆料，都在这里，我就不复述厂商的PPT了。\n而对小米最大的意义，是有一台手机能在7000元的价位和iPhone华为抢销量，但也有不足，就是缺少了华为苹果独有的东西。华为有麒麟芯片，2020年9月14号前生产的9000系列做到了安卓端至今最强，5G技术领先全球，标志着中国大陆芯片设计的最好水平，可见华为人熬掉了多少头发。被美国制裁，是整个中国的不幸。任正非专注研发这一点，值得尊敬。\n小米相比华为的差距，不是一般的大。而现在小米转向造车，赚钱，芯片的事小米暂时不会碰了，和ov一样打算一辈子躺着挣钱，不打算思考一些如何体面的活着的问题。\nPro同样有竞争力，但是被ultra的光芒掩盖了，补足了4000-5000的价位的短板，同样的GN2,同样的IP68，更轻的重量208g，可以说比去年的10pro竞争力大大提高，就看出货了。\nMIX FOLD：最便宜的折叠屏，搭载小米自研的isp，，加上液态镜头。适合手上有闲钱的米粉。首发5w台销量，作为探索者，这个目标达到了。但是和友商mate和galaxy相比有差距，能不能稳定迭代更新，拭目以待吧。\n暂时小米在线上还没有对手，今年的find x3系列和一加9系列不够猛，在纯硬件竞争上比不过Pro,上半年线上市场收割问题不大。但是下半年有复出的荣耀，是有华为级别实力和财力的竞争对手，一旦走上正轨，不容小觑。\n","date":"2021-04-24T20:15:28+08:00","permalink":"https://uest.xyz/posts/%E4%BA%91%E6%B5%8B%E8%AF%84/","section":"posts","tags":null,"title":"云测评"},{"categories":null,"contents":"14. 最长公共前缀 编写一个函数来查找字符串数组中的最长公共前缀。\n如果不存在公共前缀，返回空字符串 \u0026quot;\u0026quot;。\n示例 1：\n输入：strs = [\u0026quot;flower\u0026quot;,\u0026quot;flow\u0026quot;,\u0026quot;flight\u0026quot;] 输出：\u0026quot;fl\u0026quot; 示例 2：\n输入：strs = [\u0026quot;dog\u0026quot;,\u0026quot;racecar\u0026quot;,\u0026quot;car\u0026quot;] 输出：\u0026quot;\u0026quot; 解释：输入不存在公共前缀。 提示：\n 0 \u0026lt;= strs.length \u0026lt;= 200 0 \u0026lt;= strs[i].length \u0026lt;= 200 strs[i] 仅由小写英文字母组成  先上我写的垃圾代码：\npublic class Test { public static String longestCommonPrefix(String strs[]) { try {//trycatch是针对输入空字符串的情况，输出空字符串  int len = strs[0].length(); for (String s : strs) {//这是一个foreach循环，算出最小的长度，这样在接下来就只要循环最小的长度了  if (s.length() \u0026lt; len) { len = s.length(); } } int count = -1;//用作计数  for (int i = 0; i \u0026lt; len; i++) { char c0 = strs[0].charAt(i); //这里将第一个字符串作为标准，将后面的字符串与第一个分别比较  for (String s : strs) {//这也是一个foreach循环  if (c0 != s.charAt(i)) {//一旦遇到不相等，就为count赋值，停止所有循环  count = i; break; } if(i+1==len){count=i+1;}//针对情况：“ab”，“a”，循环结束仍然没有为count赋值，那就手动赋值  } if ( count != -1) {//一旦count被赋值了（即不等于-1），立即break  break; } }//完成循环，开始输出结果  return strs[0].substring(0, count);//如果count==-1或者0，不用担心，exception会帮我们处理掉哦  }catch (Exception x){return \u0026#34;\u0026#34;;} } public static void main(String[] args) { String strs[] =new String[3]; strs[0]=\u0026#34;floger\u0026#34;; strs[1]= \u0026#34;flog\u0026#34;; strs[2]=\u0026#34;floght\u0026#34;; System.out.println(strs.length); System.out.println(longestCommonPrefix(strs)); } } 暴力求解，逐个循环，相信你一定没心情看我的烂代码。时隔不少天我再编辑时，发现我也看不懂了。\n下面给大家分享一个大神解法\n字典序最大和最小字符串的公共前缀 悠远的苍穹L3发布于 2020-06-1514.1kC++PythonPython3\n解题思路 先找出数组中字典序最小和最大的字符串，最长公共前缀即为这两个字符串的公共前缀 代码 下面是 C++17 的代码\nclass Solution { public: string longestCommonPrefix(vector\u0026lt;string\u0026gt;\u0026amp; strs) { if(strs.empty()) return \u0026quot;\u0026quot;; // c++17 结构化绑定 // str0, str1 分别是一个 pair\u0026lt;string, string\u0026gt; 的 first 和 second const auto [str0, str1] = minmax_element(strs.begin(), strs.end()); for(int i = 0; i \u0026lt; str0-\u0026gt;size(); ++i) if(str0-\u0026gt;at(i) != str1-\u0026gt;at(i)) return str0-\u0026gt;substr(0, i); return *str0; } }; 等同的 C++11 代码如下\nclass Solution { public: string longestCommonPrefix(vector\u0026lt;string\u0026gt;\u0026amp; strs) { if(strs.empty()) return \u0026quot;\u0026quot;; const auto p = minmax_element(strs.begin(), strs.end()); for(int i = 0; i \u0026lt; p.first-\u0026gt;size(); ++i) if(p.first-\u0026gt;at(i) != p.second-\u0026gt;at(i)) return p.first-\u0026gt;substr(0, i); return *p.first; } }; Python 代码\nclass Solution: def longestCommonPrefix(self, strs: List[str]) -\u0026gt; str: if not strs: return \u0026quot;\u0026quot; str0 = min(strs) str1 = max(strs) for i in range(len(str0)): if str0[i] != str1[i]: return str0[:i] return str0 这里关键在于minmax_elements的使用\n该函数是返回指定范围内的最大最小值的元素的迭代器组成的一个pair, 如果最值多于一个， first返回的是第一个出现的最小值的迭代器，second返回的是最后一个出现的最大值的迭代器 。\n下面是一个例子：\nvoid minmaxelement(){ vector\u0026lt;int\u0026gt; vi{3,5,4,1,3,1,9,9,5}; cout\u0026lt;\u0026lt;\u0026#34;vi=\u0026#34;; for(int i:vi) cout\u0026lt;\u0026lt;i\u0026lt;\u0026lt;\u0026#34; \u0026#34;; cout\u0026lt;\u0026lt;endl; auto it=minmax_element(vi.begin(),vi.end()); cout\u0026lt;\u0026lt;\u0026#34; auto it=minmax_element(vi.begin(),vi.end())\u0026#34;\u0026lt;\u0026lt;endl; cout\u0026lt;\u0026lt;\u0026#34;*it.first=\u0026#34;\u0026lt;\u0026lt;*it.first\u0026lt;\u0026lt;\u0026#34; ,*it.second=\u0026#34;\u0026lt;\u0026lt;*it.second\u0026lt;\u0026lt;endl; cout\u0026lt;\u0026lt;\u0026#34;*(it.first-1)=\u0026#34;\u0026lt;\u0026lt;*(it.first-1)\u0026lt;\u0026lt;\u0026#34; ,*(it.second-1)=\u0026#34;\u0026lt;\u0026lt;*(it.second-1)\u0026lt;\u0026lt;endl; } // auto it=minmax_element(vi.begin(),vi.end()) //it.first=1 it.second=9 //*(it.first-1)=4 *(it.second-1)=9 注意 string 比较采用的是 ”字典序“，a,bc,aac按照字典序比较就是：a,aac,bc.\ntemplate\u0026lt;class ForwardIt, class Compare\u0026gt; std::pair\u0026lt;ForwardIt, ForwardIt\u0026gt; minmax_element(ForwardIt first, ForwardIt last, Compare comp) { auto min = first, max = first; if (first == last || ++first == last) return {min, max}; if (comp(*first, *min)) { min = first; } else { max = first; } while (++first != last) { auto i = first; if (++first == last) { if (comp(*i, *min)) min = i; else if (!(comp(*i, *max))) max = i; break; } else { if (comp(*first, *i)) { if (comp(*first, *min)) min = first; if (!(comp(*i, *max))) max = i; } else { if (comp(*i, *min)) min = i; if (!(comp(*first, *max))) max = first; } } } return {min, max}; } https://en.cppreference.com/w/cpp/algorithm/minmax_element\n这是最初c语言第一节课的知识，strcmp的比较方法\ncomparison function object (i.e. an object that satisfies the requirements of Compare) which returns true if if *a is less than *b. The signature of the comparison function should be equivalent to the following:\nbool cmp(const Type1 \u0026amp;a, const Type2 \u0026amp;b);\nWhile the signature does not need to have const \u0026amp;, the function must not modify the objects passed to it and must be able to accept all values of type (possibly const) Type1 and Type2 regardless of value category (thus, Type1 \u0026amp; is not allowed, nor is Type1 unless for Type1 a move is equivalent to a copy (since C++11)). The types Type1 and Type2 must be such that an object of type ForwardIt can be dereferenced and then implicitly converted to both of them.\nhttps://en.cppreference.com/w/cpp/algorithm/minmax_element\n","date":"2021-04-20T16:32:05+08:00","permalink":"https://uest.xyz/posts/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80/","section":"posts","tags":null,"title":"最长公共前缀"},{"categories":null,"contents":"secTest ","date":"2021-04-20T16:00:12+08:00","permalink":"https://uest.xyz/posts/sec/","section":"posts","tags":null,"title":"Sec"}]